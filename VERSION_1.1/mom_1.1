#DECK accel.h
c====================== include file "accel.h" =========================
c
c     depth dependent tracer timestep acceleration multipliers used to
c     hasten the convergence to equilibrium of the deeper portions of
c     ocean-climate models.
c
c     accelerate abyssal processes by varying the length of the tracer
c     timestep with depth.  by using longer timesteps at depth, one can
c     in effect reduce the heat capacity of the deeper levels and speed
c     convergence to equilibrium.
c     note:
c     by applying this method, one is assuming that there is a single
c     steady-state solution to the model being considered.
c     also, since the diagnostic timestep calculations of "termbt" do
c     not attempt to account for depth variant timestep lengths, the
c     truncation error reported will increase, because it will include
c     the tracer changes due to variations in "dtxcel".
c
c     reference:
c       Bryan, K., 1984: accelerating the convergence to equilibrium
c     of ocean climate models, J. Phys. Oceanogr., 14, 666-673.
c     ("dtxcel" here is the same as 1/gamma in the above reference)
c     set "dtxcel" to 1.0 at the surface and for upper levels not
c     to be accelerated
c     set "dtxcel" to values greater than 1.0 at deeper levels to
c     accelerate convergence if above requirements are met
c
c     dtxcel   = model level dependent tracer timestep multipliers
#ifdef isopycmix
c     dtxsqr   = square root of "dtxcel" (used in computation of
c                maximum slope constraint for isopycnal mixing)
#endif
#ifndef implicitvmix
c     dztxcl   = layer thickness divided by the timestep multiplier
c                (needed for convection code)
c     dzwxcl   = multiplication factor relating to the vertical
c                distance between ts points, scaled according
c                to timestep multipliers for use in convection code
#endif
c
      common /accel/ dtxcel(km)
#ifdef isopycmix
     $,              dtxsqr(km)
#endif
#ifndef implicitvmix
     $,              dztxcl(km), dzwxcl(km)
#endif
c
#DECK cbihar.h
c====================== include file "cbihar.h" ========================
#ifndef multitasking
# define task
#endif
c
c     del**2 of prognostic variables
c
      task common /cbihar/ del2(imt,km,nvarbh,numjpt)
c
#DECK ccfl.h
c====================== include file "ccfl.h" ==========================
c
c
c     cflcrt  = factor by which the cfl criteria must be exceeded in
c               order to stop MOM  (see blkdta.F)
c     cflum   = zonal velocity which comes closest to its cfl criteria
c     cflup   = percent of cfl criteria reached by "cflum"
c     icflu   = "i" coordinate of "cflum"
c     jcflu   = "j" coordinate of "cflum"
c     kcflu   = "k" coordinate of "cflum"
c
c     cflvm   = meridional velocity which comes closest to its cfl
c               criteria
c     cflvp   = percent of cfl criteria reached by "cflvm"
c     icflv   = "i" coordinate of "cflvm"
c     jcflv   = "j" coordinate of "cflvm"
c     kcflv   = "k" coordinate of "cflvm"
c
c     cflwm   = vertical velocity which comes closest to its cfl
c               criteria
c     cflwp   = percent of cfl criteria reached by "cflwm"
c     icflw   = "i" coordinate of "cflwm"
c     jcflw   = "j" coordinate of "cflwm"
c     kcflw   = "k" coordinate of "cflwm"
c
      common /ccfl/ cflup, cflum, icflu, jcflu, kcflu
     $,             cflvp, cflvm, icflv, jcflv, kcflv
     $,             cflwp, cflwm, icflw, jcflw, kcflw
     $,             cflcrt
c
#DECK cdiag.h
c====================== include file "cdiag.h" =========================
c
c     variables used for computing diagnostics:
c
c     for precision purposes, ektot, dtabs are summed over i for each
c     k & j. tvar, engint, & buoy are summed over i & j for each k.
c     the total integrals are then summed over k and stored into the
c     zeroth element (k=0)
c
c     energetics are done over the entire ocean domain:
c
c     ektot    = total kinetic energy per unit volume
c     dtabs    = rate of change of tracer per unit volume
c     engint   = internal mode energy integral components per
c                unit volume
c     engext   = external mode energy integral components per
c                unit volume
c     buoy     = buoyancy per unit volume
c
c     term balances are instantaneous breakdowns of all terms in the
c     momentum & tracer equations. They are averaged over ocean volumes
c     defined by horizontal and vertical regional masks (see ocean.F):
c
c
c     termbt   = term balance components for time rate of change of
c                tracers per unit volume. the total time rate of change
c                is broken down into components as follows:
c                (1) = total time rate of change for the tracer
c                (2) = change due to zonal advection
c                (3) = change due to meridional advection
c                (4) = change due to vertical advection
c                (5) = change due to zonal diffusion
c                (6) = change due to meridional diffusion
c                (7) = change due to vertical diffusion
c                (8) = change due to source term
c                (9) = change due to isopycnal diffusion
c     tconv    = time rate of change due to convection per unit volume
c     tvar     = rate of change of tracer variance per unit volume
c     atwv     = average tracer within volume
c     asst     = average sea surface tracer for regional surface areas
c     stflx    = surface tracer flux per unit volume
c
c     termbm   = term balance components for time rate of change of
c                momentum per unit volume. the total time rate of change
c                is broken down into components as follows:
c                (1) = total time rate of change for the momentum
c                (2) = change due to the pressure gradient
c                (3) = change due to zonal advection
c                (4) = change due to meridional advection
c                (5) = change due to vertical advection
c                (6) = change due to zonal diffusion
c                (7) = change due to meridional diffusion
c                (8) = change due to vertical diffusion
c                (9) = change due to metric terms
c                (10) = change due to coriolis terms
c                (11) = change due to source terms
c                (12) = change due to surface pressure gradient
c                (13) = change due to metric advection
c     smflx    = surface momentum flux per unit volume
c     avwv     = average velocity within volume
c
c     zuneng   = vertical average of zonal forcing on row j
c     zuseng   = vertical average of zonal forcing on row j-1
c     zvneng   = vertical average of meridional forcing on row j
c     zvseng   = vertical average of meridional forcing on row j-1
c
c
      common /cdiag/ ektot(0:km,jmt), dtabs(0:km,nt,jmt)
     $,              engint(0:km,8), engext(8), tconv(nt)
     $,              atwv(nt,0:numreg), asst(nt,0:nhreg), avwv(3,numreg)
     $,              termbt(0:km,8,nt,0:numreg)
     $,              termbm(0:km,13,2,numreg)
     $,              tvar(0:km,nt,0:numreg), smflx(2,0:nhreg)
     $,              stflx(nt,0:nhreg), buoy(0:km), zuneng(imt,8)
     $,              zuseng(imt,8), zvneng(imt,8), zvseng(imt,8)
c
c     vbr      = zonal sum of meridional velocity
c     tbrn     = zonal sum of tracer (north row)
c     tbrs     = zonal sum of tracer (south row)
c     ttn      = northward transport of tracer
c     tmt      = meridional mass transport
c     ustf     = names & units for surface tracer fluxes
c
      common /cdiaga/ vbr(km), tbrn(km,nt),
     $          tbrs(km,nt), ttn(8,jmt,ntmin2), tmt(jmt,km)
      character*15 ustf(nt,2)
      common /cdiagb/ ustf
c
#DECK chmix.h
c====================== include file "chmix.h" =========================
c
c     horizontal mixing coefficients
c
c     am  = lateral eddy viscosity (cm**2/sec)
c     ah  = lateral eddy diffusivity (cm**2/sec)
c     aq  = lateral turbulent kinetic energy diffusivity (cm**2/sec)
c
      common /chmix/ am, ah, asubh, asubm
#ifdef tcvmix
     $,              aq
#endif
     $,              bbu(jmt), ccu(jmt), ddu(jmt), ggu(jmt), hhu(jmt)
     $,              bbt(jmt), cct(jmt), ddt(jmt)
c
#DECK cisop.h
c====================== include file "cisop.h" =========================
c
c           variables for isopycnal diffusion scheme
c
c    "ahisop" = along isopycnal diffusion coefficient for mixing of
c               tracers  [cm**2/sec]
c               ("ah" = in "chmix.h is used as background horizontal
c               diffusion to prevent checkerboarding)
c    "slmxr"  = maximum slope of isopycnal allowed in mixing scheme
c               limited to prevent excessively large vertical mixing
c               that could create numerical instabilities
c               a value of 200 translates to a slope of 1:200
c    "rx", "ry" & "rz" terms = store density differences used to compute
c               isopycnal diffusion tensor components "fk#"
c    "rxp" = east - central density difference at the row j+1
c    "rx"  = east - central density difference at the current j row
c    "ryn" = north - central density difference (row j+1  -  row j)
c    "rys" = central - south density difference (row j  -  row j-1)
c    "rzp" = above - central vertical density difference at the row j+1
c    "rz"  = above - central vertical density difference at current row
c
c    "e" = different things in different places...
c      in isop0 = density gradients (1=zonal; 2=meridional; 3=vertical)
c      in isop1 = who knows what
c    "fk#" = isopycnal diffusion tensor components (compute five)
c          "fk1(3)" is resolved at center of eastern face of t,s box
c          "fk2(3)" is resolved at center of northern face of t,s box
c          "fk3(1-3)" are resolved at center of top face of t,s box
c     components (1,1) & (2,2) of tensor are assumed = 1.0
c     components (1,2) & (2,1) of tensor are assumed = 0.0
c
c
      common /cisop/ rxp(imt,km), ryn(imt,km), rzp(imt,kmp1),
     $               rx (imt,km), rys(imt,km), rz (imt,kmp1),
     $               fk1(imt,km,3:3), fk2(imt,km,3:3), fk3(imt,km,3),
     $               e(imt,kmp1,3), esav(imt,km,nt),
     $               ahisop, slmxr
c
#DECK cnlmix.h
c====================== include file "cnlmix.h" ========================
c
c     arrays used for non-linear horizontal viscosity
c
c     dten     = tension rate of strain
c     dtens    = tension rate of strain at southern row
c     dshear   = shear rate of strain
c     dshers   = shear rate of strain at southern row
c     dpure    = pure rate of deformation
c     dpures   = pure rate of deformation at southern row
c     dpuret   = pure rate of deformation
c     dkmc     = non-linear equivalent of am
c     effk     = effective  wavenumber in x direction
c     effky    = effective  wavenumber in y direction
c     bbtj     = nonlinear diffusion coefficient for tracers
c     cctj     = nonlinear diffusion coefficient for tracers
c     ddtj     = nonlinear diffusion coefficient for tracers
c
c
c
      common /cnlmix/ dten(imt,km),   dtens(imt,km)
     $,               dshear(imt,km), dshers(imt,km)
     $,               dpure(imt,km),  dpures(imt,km), dpuret(imt,km)
     $,               dkmc(imt,km)
     $,               dkhcx(imt,km), dkhcy(imt,km)
     $,               bbtj(imt,km), cctj(imt,km), ddtj(imt,km)
     $,               effk(imt), effky(jmt)
c
#DECK coord.h
c====================== include file "coord.h" =========================
c
c                    model grid point coordinates
c
c     grid definition:
c
c     the model uses a staggard arakawa "b" grid. horizontally, tracer
c     quantities are defined at the centers of "t" grid boxes and
c     velocities are defined at the centers of "u,v" grid boxes.
c     the centers of "u,v" grid boxes are located at the northeast
c     corners of "t" grid boxes. the 1st "t" grid box is located in
c     the southwest corner of the "t" grid. this grid system is
c     replicated and stacked vertically one on top of another from the
c     surface of the ocean downward. vertically, tracers & velocities
c     are defined at the centers of their corresponding boxes and are
c     at the same depths.
c
c
c     inputs:  (data initialized in "blkdta.F")
c
c     stlon = starting longitude of the "t" grid in degrees. It defines
c             the west face of the 1st "t" grid box.
c     stlat = starting latitude of the "t" grid in degrees. It defines
c             the south face of the 1st "t" grid  box
c
c
c
c     in the longitudinal direction, the "t" grid may be divided into
c     one or more sub domains with the following characteristics:
c
c     nxres = number of sub domains of either constant or smoothly
c             varying grid box width (set in "param.h")
c     xmax  = max grid box width on side of the sub domain (degrees)
c     xmin  = min grid box width on side of the sub domain (degrees)
c     xwid  = longitudinal width of the sub domain (degrees)
c     idir  = (1,-1) implies that the longitudinal box width
c             (increases, decreases) going from from west to east
c
c     note:   2*xwid/(xmax+xmin) is the number of boxes which exactly
c             fit within the sub domain. this number must be an integer.
c
c     example:  parameter (imt=140, nxres=2)
c               data xmax /0.5, 1.0/
c               data xmin /0.5, 0.5/
c               data xwid /50.0, 30.0/
c               data idir /1, 1/
c               data stlon /10.0/
c
c     describes a grid with 2 distinct sub domains of resolution. the
c     1st sub domain contains 100 "t" grid boxes
c     { 100 = xwid(1)/(0.5*(xmax(1)+xmin(1))) } between longitude
c     10.0 deg east { stlon=10.0 } & 60.0 deg east {xwid(1) = 50.0}.
c     the grid box width { delta x = 0.5*(xmax(1)+xmin(1)) } is a
c     constant 0.5 deg. the 1st "t" grid point is at 10.25 deg east
c     and the 100th is at 59.75 deg east. the 2nd sub domain contains
c     40 "t" grid boxes
c     { 40 = xwid(2)/(0.5*(xmax(2)+xmin(2))) } between longitude
c     60.0 deg east { where the first domain ends } & 90.0 deg east.
c     the box width (delta x) gradually increases from 0.5 deg at
c     60.0 deg east to 1.0 deg at 90 deg east. the variation is
c     fitted to a cosine function. idir = 1 says the grid delta x
c     increases with increasing longitude. ( 0.5 deg in the west and
c     1.0 deg in the east. idir = -1 would indicate the reverse)
c     Note that 100 + 40 must equal imt.
c
c
c     in the latitudinal direction, the "t" grid may be divided into
c     one or more sub domains with the following characteristics:
c
c     nyres = number of sub domains of either constant or smoothly
c             varying grid box height (set in "param.h")
c     ymax  = max grid box height on side of the sub domain (degrees)
c     ymin  = min grid box height on side of the sub domain (degrees)
c     ywid  = latitudinal height of the sub domain (degrees)
c     jdir  = (1,-1) implies that the latitudinal box height
c             (increases, decreases) going from from south to north
c
c     note:   2*ywid/(ymax+ymin) is the number of boxes which exactly
c             fit within the sub domain. it must be an integer.
c
c     see above example:
c
c     primary grid coordinates:
c
c     xt(i) = longitude of the ith "t" point in degrees.   i=1..imt
c     xu(i) = longitude of the ith "u,v" point in degrees. i=1..imt
c     yt(j) = latitude of the jth "t" point in degrees.    j=1..jmt
c     yu(j) = latitude of the jth "u,v" point in degrees.  j=1..jmt
c     zt(k)   = distance from surface down to center of level k (in cm)
c               (depth of "t" and "u,v" grid points)
c     zw(k)   = distance from surface down to bottom of level k (in cm)
c
c
      common /coord/ stlon, stlat, xt(imt), yt(jmt), xu(imt), yu(jmt)
     $,              zw(km), zt(kmp1)
c
      common /cdmesh/ idir(nxres), jdir(nyres)
     $,               xmax(nxres), xmin(nxres), xwid(nxres)
     $,               ymax(nyres), ymin(nyres), ywid(nyres)
c
#DECK cpolar.h
c====================== include file "cpolar.h" =========================
c
c     polar transform coefficients used to transform velocities near
c     poles before filtering
c
      common /cpolar/ spsin(imt), spcos(imt)
c
#DECK cppmix.h
c====================== include file "cppmix.h" ========================
c
c     variables for vertical mixing scheme of pacanowski & philander
c
c     inputs: (initialized in include file "blkdta.h")
c
c
c     fricmx = max vertical mixing coefficient
c     wndmix = min vertical mixing in level 1 to simulate wind mixing
c
c
c     derived quantities:
c
c     drhop   = vertical density difference on row j+1  (p for j+1)
c                ("t" grid box bottoms)
c     drhoc   = vertical density difference on row j (c for central row)
c                ("t" grid box bottoms)
c     riuc   = richardson number for row j   ("u" grid box bottoms)
c     rium   = richardson number for row j-1 ("u" grid box bottoms)
c
c
#ifndef multitasking
# define task
#endif
      task common /cppmix/ drhop(imt,km), drhoc(imt,km)
     $,                    riuc(imt,km), rium(imt,km)
      common /cppmx1/ wndmix, fricmx
c
#DECK cprnts.h
c====================== include file "cprnts.h" =======================
c
c     variables used for controlling matrix printouts during diagnostic
c     timesteps:
c
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     prlat  = latitudes (deg) at which (x,z) printouts are desired
c
c     start & end coordinates for matrix printouts of (x,z) sections
c
c     prslon = starting longitudes (deg)
c     prelon = ending longitudes (deg)
c     prsdpt = starting depths  (cm)
c     predpt = ending depths  (cm)
c
c     start & end coordinates for matrix printouts of (x,y) sections
c
c     slonxy = starting longitude (deg)
c     elonxy = ending longitude (deg)
c     slatxy = starting latitude (deg)
c     elatxy = ending latitude (deg)
c
c     matrix printouts of (y,z) sections will use above coordinates
c
      parameter (nlatpr=10)
c
      common /cprnts/ prlat(nlatpr), prslon(nlatpr), prelon(nlatpr)
     $,               prsdpt(nlatpr), predpt(nlatpr)
     $,               slatxy, elatxy, slonxy, elonxy
c
#DECK cregin.h
c====================== include file "cregin.h" ========================
c
c     variables used for computing regional tracer averages (see
c     "reg1st.F" & "region.F") and for computing term balances for
c     tracer and momentum equations (see "clinic.F", "tracer.F"
c      and "diag2.F")
c
c
c     mskhr = mask field defining regions in the horizontal
c              (ie: mskhr(i,j) = n indicates point (i,j) is in the
c               "nth" horizontal region   where n=1..nhreg)
c               The "mskhr" masks are used in "region.F" when
c               computing volume weighted tracer averages and in
c               "clinic.F", "tracer.F" and "diag2.F" when computing
c               term balances for tracers and momentum.
c     mskvr  =  mask field defining regions in the vertical
c              (ie: mskvr(k) = m indicates all points under a horizontal
c               mask at level "k" are in the "mth" vertical region
c               where m=1..nvreg)
c               The "mskvr" masks are used in "diag.F", but not
c               in "region.F", where tracer averages are calculated
c               for each k-level.
c
c     hregnm = horizontal region name
c     vregnm = vertical region name
c     volbt  = total volume under a given horizontal region
c     volbk  = volume contained in a horizontal region at level "k"
c     volgt  = total ocean volume
c     volgk  = total ocean volume at level "k"
c     areab  = total ocean surface area for a given horizontal region
c     areag  = total ocean surface area
c
c     volt   = ocean volume within a particular horizontal & vertical
c              region (on the "t" grid) for tracer term balances
c     areat  = horizontal ocean area corresponding to "volt"
c     volu   = ocean volume within a particular horizontal & vertical
c              region (on the "u" grid") for momentum term balances
c     areau  = horizontal ocean area corresponding to "volu"
c     llvreg = level limits for defining vertical regions in term
c              balance calculations (not used in computing volume
c              weighted tracer averages)
c              (ie: llvreg(3,1) = 4... means that starting level for
c                  the third region in the vertical is 4. similarly,
c                  llvreg(3,2) = 6 means the ending level is 6 for that
c                  region. note regions should not overlap.)
c
      character*40 hregnm
      character*20 vregnm
c
      common /cregni/ mskhr(imt,jmt), mskvr(km), llvreg(numreg,2)
      common /cregnr/ volbk(nhreg,km), volbt(nhreg), volgk(km)
     $,               volgt, areab(nhreg), areag, volt(0:numreg)
     $,               volu(0:numreg), areat(0:numreg), areau(0:numreg)
      common /cregnc/ hregnm(nhreg), vregnm(nvreg)
c
#DECK crelax.h
c====================== include file "crelax.h" ========================
c
c     variables used in relaxation. see "relax.F" & "hyper.F"
c
c     inputs:  ( set in namelist)

c     mxscan  = max number of allowable scans
c     crit    = criterian used to stop relaxation
c     sor     = sucessive over-relaxation constant
c
c     output:  (from relax or hyper)
c
c     mscan   = actual number of scans taken
c
      common /crelax/  mxscan, mscan, crit, sor
c
#DECK cshrbf.h
c====================== include file "cshrbf.h" =======================
c
c
c     when multitasking ... only shared variables are allowed to be
c     used outside the parallel region. "ta" & "bufsl" are shared
c     variables with the same name as their private counterparts (which
c     are in "slabs.h") . this approach leads to no increase in memory
c     when not multitasking
c
      common /cshrbf/ ta(imt,km,nvar)
      dimension bufsl(imt,km,nvar)
      equivalence (ta,bufsl)
c
#DECK ctask.h
c====================== include file "ctask.h" =========================
c
c     variables used to control how slabs are distributed in terms of
c     tasks among processors in "step.F"
c
c
c     inputs:  (set through namelist & blkdta.F)
c
c     a task is defined as one or more latitude rows (slabs). with the
c     ifdef "multitasking" directive turned on, each task goes to a
c     separate processor.
c
c     ntasks = maximum number of tasks. if ntasks=jmt then each row
c              becomes a separate task. if ntasks=1 then all
c              rows become one task. if ntasks=n (n < jmt) then
c              each task is composed of approximately "jmt/n" rows.
c              ideally "ntasks" should equal the number of available
c              processors in a dedicated environment.
c
c     note:    when not "multitasking" then  "ntasks" = 1 by default.
c              "ntasks" can be set > 1 as long as the ifdef "diskless"
c              is not chosen.
c              when "ifdef multitasking" is chosen, try to set "ntasks"
c              so that each processor has the same work load. if
c              it is known a priori that all slabs do not contain
c              similar work, then adjust "jsrowb" & "jerowb" in ocean.F
c              to keep the amount of work similar for all tasks.
c
c     outputs:
c
c     jsrowb  = array of starting j rows for tasks. "jsrowb" only needs
c               to be dimensioned by "nchunk" which is <= "jmt"
c     jerowb  = array of ending j rows for tasks. "jerowb" only needs
c               to be dimensioned by "nchunk" which is <= "jmt"
c     jsrow   = starting j row for the current task (=jsrowb(ntask))
c     jerow   = ending j row for the current task (=jerowb(ntask))
c     nchunk  = used as the tasking loop limit
c
#ifndef multitasking
# define task
#endif
      task common /ctask/ jsrow, jerow
      common /ctask1/ jsrowb(jmt), jerowb(jmt), ntasks, nchunk
c
#DECK ctcmix.h
c====================== include file "ctcmix.h"=========================
c
c    variables for turbulence closure scheme
c
c    inputs:
c           initialized in include "dtcmix.h" & namelist
c
c    derived quantities:
c    tke     = turbulent kinetic energy tendency
c    advq2   = advection of tke
c    hdq2    = horizontal diffusion of tke
c    sprod   = shear production
c    bprod   = buoyancy production
c    dissp   = dissipation of tke
c
c
#ifndef multitasking
# define task
#endif
c
      task common   /ctcmix/
     $               bprod(imt,km), sprod(imt,km), dissp(imt,km)
     $,             tke(imt,km), bprol(imt,km)
     $,             advq2(imt,km), fvsq(imt,km)
     $,             hdq2(imt,km)
     $,             el(imt,km,nslabs), elmax(imt,km)
     $,             eeq(imt,km), ffq(imt,km)
     $,             gmp1(imt,km), gh(imt,km)
     $,             sm(imt,km), sh(imt,km)
#ifdef leq
     $,             tkel(imt,km)
     $,             advq2l(imt,km)
     $,             hdq2l(imt,km)
#endif
      common /ctcmx1/
     $              a1, b1, a2, b2, cc1, e1, e2, e3
     $,             vdqlim
     $,             alpha, vk, sq
     $,             rhoh2o
     $,             small, big, deps
     $,             p032, p1, p154, p4, p48
     $,             c15, c100
     $,             jpr1,ipr1,jpr2,ipr2
c
#DECK ctmngr.h
c====================== include file "ctmngr.h" ========================
c
c     time manager clock parameters for setting time of model
c     initial conditions.
c
c     year0  = starting year   ( >= 0)
c     month0 = starting month  (1..12)
c     day0   = starting day    (1..last day of month)
c     hour0  = starting hour   (0..23)
c     minut0 = starting minute (0..59)
c     sec0   = starting second (0..59)
c
      integer year0, month0, day0, hour0, minut0, sec0
c
      common /ctmngr/ year0, month0, day0, hour0, minut0, sec0
c
c     time manager variables corresponding to current model time step
c
c     tyear   = year                     (ie: 1900)
c     tmonth  = month of the year        (ie: 1..12)
c     tday    = day of the month         (ie: 1..31)
c     thour   = hour of the day          (ie: 0..23)
c     tmin    = minute of the hour       (ie: 0..59)
c     tsec    = seconds after the minute (ie: 0..59)
c     relyr   = relative year referenced to time at model
c               initial conditions
c     yrnorm  = number of days in a normal year
c     yrleap  = number of days in a leap year
c     nleap   = number of years between leap years
c     time0   = time (in years) at initial conditions
c     totday  = accumulated time in days from jan 1, year 0
c     julian  = (true, false) = (real, simple) calendar
c     stamp   = date & time stamp corresponding to itt
c
      logical julian
      character*32 stamp
      common /ctmngr/ tyear, tmonth, tday, thour, tmin, tsec, relyr
     $,               time0, totday, yrnorm, yrleap, nleap, julian
     $,               stamp
c
c     the following variables are used to update file "kontrl" every
c     time step and written to a restart file at the end of the run.
c
c     itt     = current time step number
c     years   = number of years of model integration corresponding
c               to "itt"
c
      common /ctmngr/ itt, years
c
#DECK cvbc.h
c====================== include file "cvbc.h" ==========================
c
c     vertical boundary condition variables:
c
c     smf = surface momentum flux
c          1 => zonal wind stress (dynes/cm**2)
c          2 => meridional wind stress (dynes/cm**2)
c     bmf = bottom momentum flux
c          1 => zonal bottom drag (dynes/cm**2)
c          2 => meridional bottom drag (dynes/cm**2)
c     stf = surface tracer flux
c          1 => surface heat flux (cal/cm**2/sec = cm*degC/sec = ly/sec)
c                             ( assuming rho*cp = 1 cal/degC/cm**3)
c          2 => surface water flux (ppt/cm**2/sec)
c     btf = bottom tracer flux (for consistency but normally zero!)
c          1 => bottom heat flux (cal/cm**2/sec = cm*degC/sec = ly/sec)
c                             ( assuming rho*cp = 1 cal/degC/cm**3)
c          2 => bottom water flux (ppt/cm**2/sec)
c
#ifndef multitasking
# define task
#endif
      task common /cvbc/ smf(imt,2),  bmf(imt,2)
     $,                  stf(imt,nt), btf(imt,nt)
c
#DECK cvmix.h
c====================== include file "cvmix.h" =========================
c
c     variables used for vertical diffusion
c
c     inputs: (set through namelist)
c
c     fkph   = vertical diffusion coefficient (cm**2/sec)
c     fkpm   = vertical viscosity coefficient (cm**2/sec)
c     bvdc   = background vertical diffusion constant
c     bvvc   = background vertical viscosity constant
c     vvclim = vertical viscosity coefficient limit
c     vdclim = vertical diffusion coefficient limit
c
c     aidif  = coefficient for implicit time differencing for
c              vertical diffusion. aidif=1 gives the fully implicit
c              case. aidif=0 gives the fully explicit case
c              note: not used unless "implicitvmix" or "isopycmix"
c                    is enabled
c
c
c     derived quantities:
c
c     vvc  = vertical viscosity coeff
c     vdc  = vertical diffusion coeff
c
#ifndef tcvmix
# ifndef multitasking
#  define task
# endif
      task common /cvmix/ vvc(imt,km), vdc(imt,km)
#endif
c
      common /cvmix1/ fkph, fkpm, bvdc, bvvc, vvclim, vdclim
     $,               aidif
c
#DECK dncoef.h
c====================== include file "dncoef.h" ==========================
c
c
c     enter normalizing temperatures, salinities and coefficients
c     generated by program "eqstat" which fits 3rd order polynomials
c     to the equation 'of state for each model level.
c
      data to /
     $        13.4979166,13.4926169,13.4845768,13.4727122, 8.4665976,
     $         8.4484312, 5.9367561, 4.4197725, 2.9018104, 2.8627440,
     $         2.8119188, 2.7478969, 2.6693535, 2.5760430, 2.9494306/
c
      data so /
     $        -0.0022500,-0.0022500,-0.0022500,-0.0022500, 0.0001500,
     $         0.0001500,-0.0001000,-0.0001000,-0.0002500,-0.0002500,
     $        -0.0002000,-0.0002000,-0.0002000,-0.0002000,-0.0002000/
c
      data (c( 1,n),n=1,9)/
     $         -.2017851E-03,0.7729900E+00,-.4916357E-05,-.2021094E-02,
     $         0.3168210E+00,0.3606242E-07,0.3773530E-02,0.3601930E-04,
     $         0.1605978E+01/
c
      data (c( 2,n),n=1,9)/
     $         -.2024842E-03,0.7727355E+00,-.4904976E-05,-.2017314E-02,
     $         0.3160354E+00,0.3591818E-07,0.3768401E-02,0.3595768E-04,
     $         0.1598916E+01/
c
      data (c( 3,n),n=1,9)/
     $         -.2035380E-03,0.7723525E+00,-.4887711E-05,-.2011439E-02,
     $         0.3151638E+00,0.3569715E-07,0.3736588E-02,0.3584786E-04,
     $         0.1627915E+01/
c
      data (c( 4,n),n=1,9)/
     $         -.2050843E-03,0.7717891E+00,-.4862535E-05,-.2003172E-02,
     $         0.3129073E+00,0.3537948E-07,0.3740574E-02,0.3572830E-04,
     $         0.1634156E+01/
c
      data (c( 5,n),n=1,9)/
     $         -.1628465E-03,0.7822322E+00,-.5256112E-05,-.2310488E-02,
     $         0.4441855E+00,0.4386074E-07,0.4209105E-02,0.4284397E-04,
     $         -.3533121E+01/
c
      data (c( 6,n),n=1,9)/
     $         -.1664290E-03,0.7810346E+00,-.5197709E-05,-.2290309E-02,
     $         0.4061066E+00,0.4321431E-07,0.4105291E-02,0.4270665E-04,
     $         -.4451626E+01/
c
      data (c( 7,n),n=1,9)/
     $         -.1446374E-03,0.7851275E+00,-.5443910E-05,-.2465505E-02,
     $         0.1508644E+00,0.4865008E-07,-.2298690E-02,0.4636501E-04,
     $         0.2921848E+02/
c
      data (c( 8,n),n=1,9)/
     $         -.1353437E-03,0.7868303E+00,-.5536851E-05,-.2558586E-02,
     $         0.1452740E+00,0.5092440E-07,-.1494541E-02,0.4538149E-04,
     $         -.2139407E+03/
c
      data (c( 9,n),n=1,9)/
     $         -.1276864E-03,0.7879311E+00,-.5628878E-05,-.2711959E-02,
     $         -.1701061E+01,0.5181664E-07,-.1254796E+00,0.5131700E-04,
     $         -.2181232E+04/
c
      data (c(10,n),n=1,9)/
     $         -.1392459E-03,0.7838731E+00,-.5445710E-05,-.2609743E-02,
     $         -.4988049E+01,0.5096849E-07,0.7100123E-01,0.4921809E-04,
     $         0.4546029E+04/
c
      data (c(11,n),n=1,9)/
     $         -.1529192E-03,0.7808815E+00,-.5195704E-05,-.2513633E-02,
     $         -.7580082E+01,0.4536900E-07,0.1053939E+01,0.1641317E-05,
     $         -.1635490E+05/
c
      data (c(12,n),n=1,9)/
     $         -.1684001E-03,0.7768872E+00,-.4939702E-05,-.2213298E-02,
     $         -.1041420E+02,0.4656355E-07,0.1212965E+01,-.6386872E-04,
     $         -.2994899E+05/
c
      data (c(13,n),n=1,9)/
     $         -.1853807E-03,0.7711285E+00,-.4658209E-05,-.2091224E-02,
     $         -.1515848E+02,0.4140049E-07,0.2341507E+01,0.7015846E-04,
     $         -.3064146E+05/
c
      data (c(14,n),n=1,9)/
     $         -.2033667E-03,0.7655853E+00,-.4382178E-05,-.1989417E-02,
     $         -.2318759E+02,0.3566120E-07,0.3340599E+01,-.1688436E-04,
     $         -.3545847E+05/
c
      data (c(15,n),n=1,9)/
     $         -.2256227E-03,0.7588712E+00,-.3992833E-05,-.1987264E-02,
     $         -.1391063E+02,0.3392166E-07,0.3334040E+01,0.1038726E-04,
     $         -.5790932E+05/
c
c  the above coefficients were calculated using program "eqstat"
c  (employing the UNESCO equation of state)
c  and are valid for the following depths and T and S ranges
c     k      depth        tmin      tmax           smin      smax
c     1      15.00e2     -2.000    29.000        28.5000   37.0000
c     2      53.08e2     -2.000    29.000        28.5000   37.0000
c     3     110.61e2     -2.000    29.000        28.5000   37.0000
c     4     195.04e2     -2.000    29.000        28.5000   37.0000
c     5     315.32e2     -2.000    19.000        33.7000   36.6000
c     6     481.69e2     -2.000    19.000        33.7000   36.6000
c     7     705.13e2     -2.000    14.000        34.0000   35.8000
c     8     996.49e2     -2.000    11.000        34.1000   35.7000
c     9    1365.37e2     -1.000     7.000        34.4000   35.1000
c    10    1818.82e2     -1.000     7.000        34.5000   35.0000
c    11    2360.06e2     -1.000     7.000        34.6000   35.0000
c    12    2987.28e2     -1.000     7.000        34.6000   35.0000
c    13    3693.03e2     -1.000     7.000        34.6000   35.0000
c    14    4464.06e2     -1.000     7.000        34.6000   35.0000
c    15    5281.94e2      0.000     7.000        34.6000   35.0000
c
c  the 3rd order polynomial will return density departures [gm/cm**3] as
c  a function of potential temperature [deg C] & salinity [model units]
c
c       k level reference densities (in sigma units):
c   24.6436 24.8139 25.0711 25.4479 28.7717 29.5230 30.7254 32.2579
c   34.0132 36.0659 38.5291 41.3037 44.3820 47.6937 51.0399
c
#DECK docnam.h
c====================== include file "docnam.h" ========================
c
c    info from docum.F that can be used elsewhere.
c    user specified tracer names are place into "trname" in docum
c
      character*12 trname
c
      common /docnam/ trname(nt)
c
#DECK emode.h
c====================== include file "emode.h" =========================
c
c
c     variables for rigid lid calculation of external mode
c
c     p     = stream function (,,1) is for tau; (,,2) is for tau-1
c     ztd   = time change of vorticity
c     ptd   = time change of stream function
c     h     = depth over "u,v" points
c     hr    = reciprocal depth over "u,v" points
c     zu    = time change of vertically averaged zonal forcing on row j
c     zv    = time change of vertically averaged merid forcing on row j
c
c     cfn   = relaxation coefficient to the north of point (i,j)
c     cfs   = relaxation coefficient to the south of point (i,j)
c     cfe   = relaxation coefficient to the east of point (i,j)
c     cfw   = relaxation coefficient to the west of point (i,j)
c     cpf   = relaxation coefficient for point (i,j)
c     cfne  = relaxation coefficient to the northeast of point (i,j)
c     cfse  = relaxation coefficient to the southeast of point (i,j)
c     cfnw  = relaxation coefficient to the northwest of point (i,j)
c     cfsw  = relaxation coefficient to the southwest of point (i,j)
c     rmsk  = relaxation mask of (0,1) on (land & perimeter, open ocean)
c     res   = relaxation residual
c     cof   = normalizing coefficient for islands
c     cofis = flow around islands
c
      common /emode/
     $ cfn(imt,jmt), cfs(imt,jmt), cfe(imt,jmt), cfw(imt,jmt)
     $,ptd(imt,jmt), res(imt,jmt), cpf(imt,jmt)
     $,p(imt,jmt,2), ztd(imt,jmt), hr (imt,jmt), h(imt,jmt)
     $,zu(imt,jmt),  zv(imt,jmt)
#ifdef hypergrid
     $, rmsk(imt,jmt)
#endif
#if defined congrad5pt || defined congrad9pt
     $,gdir(imt,jmt), hdir(imt,jmt), fdir(imt,jmt), asum(jmt)
#endif
#ifdef congrad9pt
     $,cfne(imt,jmt), cfnw(imt,jmt), cfse(imt,jmt), cfsw(imt,jmt)
#endif
#ifdef islands
     $,cof(imt,jmt), cofis(nisle)
#endif
c
#DECK fdifm.h
c====================== include file "fdifm.h" =========================
c
c     finite difference numerics for momentum
c
c
c     zonal advection of momentum
c
      UUx(i,k) = (aux1(i,k) - aux1(i+1,k))*dxu2r(i)
      UVx(i,k) = (aux2(i,k) - aux2(i+1,k))*dxu2r(i)
c
c     meridional advection of momentum
c
      VUy(i,k) = fvsu(i,k)*(u(i,k,jc,nc) + u(i,k,jm,nc))
     $          -fvn (i,k)*(u(i,k,jp,nc) + u(i,k,jc,nc))
      VVy(i,k) = fvsu(i,k)*(v(i,k,jc,nc) + v(i,k,jm,nc))
     $          -fvn (i,k)*(v(i,k,jp,nc) + v(i,k,jc,nc))
c
c     vertical advection of momentum
c
      WUz(i,k) = (fwb1(i,k) - fwb1(i,k-1))*dzt2r(k)
      WVz(i,k) = (fwb2(i,k) - fwb2(i,k-1))*dzt2r(k)
#ifndef nohilats
c
c     metric advective terms for high latitudes
c
      UVtan(i,k) = u(i,k,jc,nc)*v(i,k,jc,nc)*tanra(j)
      UUtan(i,k) = u(i,k,jc,nc)**2*tanra(j)
#endif
#ifdef biharmonic
c
c     zonal mixing (del**4) of momentum
c
      Uxx(i,k) = bbu(j)*(dxu2r(i)*(aux3(i,k) - aux3(i+1,k)))
      Vxx(i,k) = bbu(j)*(dxu2r(i)*(aux4(i,k) - aux4(i+1,k)))
c
c     meridional mixing (del**4) of momentum
c
      Uyy(i,k) = ccu(j)*(del2(i,k,m1,jpt2) - del2(i,k,m1,jpt3)) +
     $           ddu(j)*(del2(i,k,m1,jpt2) - del2(i,k,m1,jpt1))
      Vyy(i,k) = ccu(j)*(del2(i,k,m2,jpt2) - del2(i,k,m2,jpt3)) +
     $           ddu(j)*(del2(i,k,m2,jpt2) - del2(i,k,m2,jpt1))
c
c     metric term for mixing (del**4) of momentum
c
      Umet(i,k) = - ggu(j)*del2(i,k,m1,jpt2) +
     $            hhu(j)*dxu2r(i)*(del2(i+1,k,m2,jpt2)
     $                           - del2(i-1,k,m2,jpt2))
      Vmet(i,k) = - ggu(j)*del2(i,k,m2,jpt2) -
     $            hhu(j)*dxu2r(i)*(del2(i+1,k,m1,jpt2)
     $                           - del2(i-1,k,m1,jpt2))
# define hmixalreadyset
#endif
#if defined nlhmix && !defined hmixalreadyset
c
c     zonal mixing (nonlinear) of momentum
c
      Uxx(i,k) = ((dpure(i+1,k)*dten(i+1,k)
     $            + dpures(i+1,k)*dtens(i+1,k))
     $           - (dpure(i-1,k)*dten(i-1,k)
     $            + dpures(i-1,k)*dtens(i-1,k)))
     $            *dxu2r(i)*effk(i)*bbu(j)
      Vxx(i,k) = ((dpure(i+1,k)*dshear(i+1,k)
     $            + dpures(i+1,k)*dshers(i+1,k))
     $           - (dpure(i-1,k)*dshear(i-1,k)
     $            + dpures(i-1,k)*dshers(i-1,k)))
     $            *dxu2r(i)*effk(i)*bbu(j)
c
c     meridional mixing (nonlinear)  of momentum
c
      Uyy(i,k) = (dpure(i,k)*dshear(i,k)*cst(j+1)**2
     $           - dpures(i,k)*dshers(i,k)*cst(j)**2)
     $           *ccu(j)
      Vyy(i,k) = -(dpure(i,k)*dten(i,k)*cst(j+1)**2
     $           -dpures(i,k)*dtens(i,k)*cst(j)**2)
     $           *ccu(j)
c
c     metric mixing (nonlinear) of momentum
c
      Umet(i,k) = c0
      Vmet(i,k) = (tng(j)/radius)*(effky(j)*p5
     $            *(dpure(i,k)*dten(i,k)
     $             + dpures(i,k)*dtens(i,k)))
# define hmixalreadyset
#endif
#if defined consthmix && !defined hmixalreadyset
# define hmixalreadyset
c
c     zonal mixing (del**2) of momentum
c
      Uxx(i,k) = bbu(j)*(dxu2r(i)*(aux3(i+1,k) - aux3(i,k)))
      Vxx(i,k) = bbu(j)*(dxu2r(i)*(aux4(i+1,k) - aux4(i,k)))
c
c     meridional mixing (del**2) of momentum
c
      Uyy(i,k) = ccu(j)*(u(i,k,jp,nm) - u(i,k,jc,nm)) +
     $           ddu(j)*(u(i,k,jm,nm) - u(i,k,jc,nm))
      Vyy(i,k) = ccu(j)*(v(i,k,jp,nm) - v(i,k,jc,nm)) +
     $           ddu(j)*(v(i,k,jm,nm) - v(i,k,jc,nm))
c
c     metric term for mixing (del**2) of momentum
c
      Umet(i,k) = ggu(j)*u(i,k,jc,nm) -
     $            hhu(j)*dxu2r(i)*(v(i+1,k,jc,nm) - v(i-1,k,jc,nm))
      Vmet(i,k) = ggu(j)*v(i,k,jc,nm) +
     $            hhu(j)*dxu2r(i)*(u(i+1,k,jc,nm) - u(i-1,k,jc,nm))
#endif
#ifndef hmixalreadyset
      Uxx(i,k)  = c0
      Vxx(i,k)  = c0
      Uyy(i,k)  = c0
      Vyy(i,k)  = c0
      Umet(i,k) = c0
      Vmet(i,k) = C0
#endif
c
c     vertical mixing of momentum
c
      Uzz(i,k) = (vmf(i,k-1,1) - vmf(i,k,1))*dztr(k)
      Vzz(i,k) = (vmf(i,k-1,2) - vmf(i,k,2))*dztr(k)
c
c     coriolis term
c
      fV(i,k) = fcor(j)*v(i,k,jc,lcor)
      fU(i,k) = fcor(j)*u(i,k,jc,lcor)
#undef hmixalreadyset
c
#DECK fdift.h
c====================== include file "fdift.h" =========================
c
c     finite difference numerics for tracers
c
c
c     zonal advection of tracer
c
      UTx(i,k) = (aux1(i,k) - aux1(i+1,k))*dxt4r(i)
c
c     meridional advection of tracer
c
      VTy(i,k) = fvst(i,k)*(t(i,k,jc,nc,m) + t(i,k,jm,nc,m))
     $          -fvn (i,k)*(t(i,k,jp,nc,m) + t(i,k,jc,nc,m))
c
c     vertical advection of tracer
c
      WTz(i,k) = (fwb1(i,k) - fwb1(i,k-1))*dzt2r(k)
#ifndef isopycmix
# ifdef biharmonic
c
c     zonal diffusion (del**4) of tracer
c
      Txx(i,k) = bbt(j)*dxt4r(i)*
     $           (fm(i-1,k,jc)*aux2(i,k) - fm(i+1,k,jc)*aux2(i+1,k))
c
c     meridional diffusion (del**4)  of tracer
c
      Tyy(i,k) = cct(j)*fm(i,k,jp)*(del2(i,k,m,jpt2)-del2(i,k,m,jpt3))
     $        +  ddt(j)*fm(i,k,jm)*(del2(i,k,m,jpt2)-del2(i,k,m,jpt1))
#  define hmixalreadyset
# endif
# if defined nlhmix && !defined hmixalreadyset
c
c     zonal diffusion (nonlinear) of tracer
c
      Txx(i,k) = bbtj(i,k)*dxt4r(i)*
     $           (fm(i+1,k,jc)*aux2(i+1,k) - fm(i-1,k,jc)*aux2(i,k))
c
c     meridional diffusion (nonlinear) of tracer
c
      Tyy(i,k) = cctj(i,k)*fm(i,k,jp)*(t(i,k,jp,nm,m)-t(i,k,jc,nm,m))
     $         + ddtj(i,k)*fm(i,k,jm)*(t(i,k,jm,nm,m)-t(i,k,jc,nm,m))
#  define hmixalreadyset
# endif
# if defined consthmix && !defined hmixalreadyset
c
c     zonal diffusion (del**2) of tracer
c
      Txx(i,k) = bbt(j)*dxt4r(i)*
     $           (fm(i+1,k,jc)*aux2(i+1,k) - fm(i-1,k,jc)*aux2(i,k))
c
c     meridional diffusion (del**2) of tracer
c
      Tyy(i,k) = cct(j)*fm(i,k,jp)*(t(i,k,jp,nm,m)-t(i,k,jc,nm,m))
     $         + ddt(j)*fm(i,k,jm)*(t(i,k,jm,nm,m)-t(i,k,jc,nm,m))
#  define hmixalreadyset
# endif
#endif
#ifdef isopycmix
c
c     zonal diffusion of tracer through E & W side walls
c     (xx & zx terms included ... yx is neglected)
c
      Tisox(i,k) =  (e(i,k,1) - e(i-1,k,1))*dxtr(i)*cstr(j)
c
c     meridional diffusion of tracer through N & S side walls
c     (xy & zy terms included ... xy is neglected)
c
      Tisoy(i,k) =  (e(i,k,2) - esav(i,k,m))*dytr(j)*cstr(j)
c
c     diffusion of tracer oriented thru top & bot along isopycnal slopes
c     (xz & yz terms included ... zz term done implicitly)
c
      Tisoz(i,k) = (e(i,k,3) - e(i,k+1,3))*dztr(k)
# define hmixalreadyset
#endif
#ifndef hmixalreadyset
      Txx(i,k) = c0
      Tyy(i,k) = c0
#endif
c
c     vertical diffusion of tracer
c
      Tzz(i,k) = (vtf(i,k-1) - vtf(i,k))*dztr(k)
#undef hmixalreadyset
c
#DECK grdvar.h
c====================== include file "grdvar.h" ========================
c
c     variables which are functions of the grid defined by "coord.h"
c
c     dxt     = longitudinal width of "t" grid box at the
c               equator (in cm)
c     dxtr    = reciprocal of "dxt"
c     dxt2r   = reciprocal of "2*dxt"
c     dxt4r   = reciprocal of "4*dxt"
c     dxu     = longitudinal width of "u,v" grid box at the
c               equator (in cm)
c     dxur    = reciprocal of "dxu"
c     dxu2r   = reciprocal of "2*dxu"
c     dxu4r   = reciprocal of "4*dxu"
c
c     dyt     = latitudinal height of "t" grid box (in cm)
c     dytr    = reciprocal of "dyt"
c     dyt2r   = reciprocal of "2*dyt"
c     dyt4r   = reciprocal of "4*dyt"
c     dyu     = latitudinal height of "u,v" grid box (in cm)
c     dyur    = reciprocal of "dyu"
c     dyu2r   = reciprocal of "2*dyu"
c     dyu4r   = reciprocal of "4*dyu"
c
c     csu     = cosine of "u,v" grid point latitude
c     csur    = reciprocal of "csu"
c     cst     = cosine of "t" grid point latitude
c     cstr    = reciprocal of "cst"
c     phi     = latitude of "u,v" grid point in radians
c     phit    = latitude of "t" grid point in radians
c     sine    = sine of "u,v" grid point latitude
c     tng     = tan of "u,v" grid point latitude
c     fcor    = 2*omega*sine(j)
c
c     dzt(k)  = level thickness of "t" and "u,v" grid boxes (in cm)
c               (vertical separation between "w" velocity points)
c     c2dzt(k)= "2*dzt"
c     dztr(k) = reciprocal of dzt
c     dzt2r(k)= reciprocal of "2*dzt"
c     dzw(k)  = vertical separation between centers of levels k & k+1
c     dzwr(k) = reciprocal of dzw
c     dzw2r(k)= reciprocal of "2*dzw"
c     dztur(k)= upper diffusion grid factor = 1.0/(dzw(k-1)*dzt(k))
c     dztlr(k)= lower diffusion grid factor = 1.0/(dzw(k)*dzt(k))
c     dzwur(k)= upper diffusion grid factor = 1.0/(dzt(k)*dzw(k))
c     dzwlr(k)= lower diffusion grid factor = 1.0/(dzt(k+1)*dzw(k))
c     tanra(j)= tan(j)/radius on the "u,v" grid
c
      common /grdvar/ dxt(imt),  dxtr(imt),  dxt2r(imt), dxu(imt)
     $,               dxur(imt), dxu2r(imt), dxu4r(imt), dxt4r(imt)
     $,               dyt(jmt),  dytr(jmt),  dyt2r(jmt), dyu(jmt)
     $,               dyur(jmt), dyu2r(jmt), dyu4r(jmt), dyt4r(jmt)
     $,               csu(jmt),  csur(jmt),  cst(jmt),   cstr(jmt)
     $,               phi(jmt),  phit(jmt),  sine(jmt),  tng(jmt)
     $,               fcor(jmt), c2dzt(km),  dzt(km),    dztr(km)
     $,               dzt2r(km), dzw(0:km),  dzwr(0:km), dzw2r(0:km)
#ifdef tcvmix
     $,               dzwur(km), dzwlr(km)
#endif
#if defined implicitvmix || defined isopycmix
     $,               dztur(km), dztlr(km)
#endif
#ifndef nohilats
     $,               tanra(jmt)
#endif
c
#DECK index.h
c====================== include file "index.h" =========================
c
c    various starting & ending indices for controlling where quantities
c    are calculated:
c
c    isz   = starting longitudinal index for stream function calculation
c    iez   = ending longitudinal index for stream function calculation
c    ist   = starting longitudinal index for tracer calculations
c    iet   = ending longitudinal index for tracer calculations
c    isu   = starting longitudinal index for velocity calculations
c    ieu   = ending longitudinal index for velocity calculations
c
c    alonis= longiude of arbitrary point within island.
c    alatis= latitude of arbitrary point within island.
c            coordinate "alonis", "alatis" must point to a land "t"
c            grid box within the island.
c    nippts= number of island perimeter points
c    iperm = "i" coordinate for the island perimeter point
c    jperm = "j" coordinate for the island perimeter point
c    iofs  = offset for indexing into the island perimeter coordinates
c
c    istf  = starting index for filtering "t" grid points
c    ietf  = ending index for filtering "t" grid points
c    isuf  = starting index for filtering "u,v" grid points
c    ieuf  = ending index for filtering "u,v" grid points
c    iszf  = starting index for filtering "vorticity" grid points
c    iezf  = ending index for filtering "vorticity" grid points
c
      common /index0/ ist(jmt,lseg), iet(jmt,lseg)
     $,               isu(jmt,lseg), ieu(jmt,lseg)
#ifdef rigidlid
      common /index1/ isz(jmt,lseg), iez(jmt,lseg)
# ifdef islands
      common /index2/ alonis(nisle), alatis(nisle), nippts(nisle)
     $,               iofs(nisle), iperm(maxipp), jperm(maxipp)
# endif
#endif
#if defined fourfil || defined firfil
c
c    bring in filter parameters
c
#include "pfil.h"
      common /index4/ istf(jmtfil,lsegf,km), ietf(jmtfil,lsegf,km)
     $,               isuf(jmtfil,lsegf,km), ieuf(jmtfil,lsegf,km)
     $,               iszf(jmtfil,lsegf),    iezf(jmtfil,lsegf)
#endif
c
#DECK iounit.h
c====================== include file "iounit.h" ========================
c
c     i/o units & related variables
c
c     ndiskb  = disk pointer (index) used for tau-1 variables
c               = (1,2,3) based on itt
c     ndisk   = disk pointer (index) used for tau   variables
c               = (1,2,3) based on itt
c     ndiska  = disk pointer (index) used for tau+1 variables
c               = (1,2,3) based on itt
c     kontrl  = disk unit used for control block
c     kflds   = disk unit used for two dimensional fields
c     labs    = disk units for slabs (one for each time level)
c     iorest  = unit for history file (restarts)
c     iotavg  = unit for tracer averages
c     iormsk  = unit for regional masks (horizontal & vertical)
c     iotrmb  = unit for tracer & momentum term balances
c     iosnap  = unit for writing instantaneous snapshots of variables
c
      common /iounit/ ndiskb, ndisk, ndiska, kontrl, kflds, labs(3)
     $,               iorest, iotavg, iormsk, iotrmb, iosnap
c
#DECK levind.h
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
#DECK ndcon.h
c====================== include file "ndcon.h" ========================
c
c     various non dimensional quantities:
c
c     radian = degrees per radian
c     pi     = something good to eat
c
      common /ndcon/ radian, pi
c
#DECK param.h
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     imt    = number of grid points in longitudinal direction
c     jmt    = number of grid points in latitudinal direction
c     km     = number of grid points in the vertical direction
c     nt     = number of tracers
c     lseg   = maximum number of longitudinal stream function segments
c     nisle  = number of islands
c     nslabs = number of j rows (slabs) in the memory slab window
c     ntau   = number of time levels in the memory slab window
c     numjpt = number of pointers for internal mode velocities
c              (also used for del**2 fields with biharmonic option)
c     istart = starting longitude for calculations
c              (if "skipland" is set, "istart" is calculated for each
c               longitudinal strip of ocean ... skipping land points)
c     iend   = ending longitude for calculations
c              (if "skipland" is set, "iend" is calculated for each
c               longitudinal strip of ocean ... skipping land points)
c     maxipp = max number of island perimeter points
c     nvar   = number of prognostic variables
c     nvarbh = number of prognostic variables using biharmonic mixing
c     ntlev  = number of time levels on disk
c     nxres  = number of sub domains of either constant or smoothly
c              varying grid box width (see "coord.h")
c     nyres  = number of sub domains of either constant or smoothly
c              varying grid box height (see "coord.h")
c     nhreg = number of regions in the horizontal used for averaging
c             tracers.
c     nvreg = number of regions in the vertical used for term balance
c             calculations. note "nvreg" is not used for tracer averages
c     numreg= total number of regions ( = product of nhreg & nvreg)
c             used for term balance calculations
c
      parameter (imt=92, jmt=60, km=15, nt=2, lseg=5, nisle=2
     $,          ntau=2, nxres=1, nyres=1, maxipp=500
#ifdef biharmonic
     $,          nslabs=4, numjpt=3
#else
     $,          nslabs=3, numjpt=2
#endif
     $,          nhreg = 5, nvreg = 2, numreg = nhreg*nvreg
     $,          nvar=nt+2
#ifdef tcvmix
     $                    +4
# ifdef leq
     $                      +1
# endif
#endif
#ifdef biharmonic
     $,          nvarbh=nt+2
# ifdef tcvmix
     $                    +1
#  ifdef leq
     $                      +1
#  endif
# endif
#endif
#if defined diskless && !defined multitasking
     $,          ntlev=2
#else
     $,          ntlev=3
#endif
#ifdef cyclic
     $,          imu=imt)
#else
     $,          imu=imt-1)
#endif
      parameter  (imtp1=imt+1, imtm1=imt-1, imtm2=imt-2, imum1=imu-1
     $,          imum2=imu-2, jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2
#ifndef skipland
     $,          istart=2, iend=imtm1
#endif
#ifdef symmetry
     $,          jscan=jmtm2+1
#else
     $,          jscan=jmtm2
#endif
     $,          kmp1=km+1, kmp2=km+2, kmm1=km-1
     $,          imtkm=imt*km, nwds=imt*jmt, nkflds=6
     $,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     add parameter constants
c
#include "pconst.h"
c
#DECK pconst.h
c====================== include file "pconst.h" =========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (ie: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (ie: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (ie: p5 for 0.5)
c     use prefix of "r" for reciprocals (ie: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (ie: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c4=4.0, c5=5.0, c8=8.0)
      parameter (c16=16.0, c360=360.0)
      parameter (p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     stdin, stdout, and stderr set the Fortran units for
c     standard input, standard output, and standard error messages
c     (used in read and write statements)
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
#DECK pfil.h
c====================== include file "pfil.h" ==========================
c
c     define latitudinal domain for filtering
c
c     filter t to yield equiv dx at lat rjft0 from lat rjfrst to rjft1
c       and lat rjft2 to yt(jmtm1)
c     filter u to yield equiv dx at lat rjfu0 from lat rjfrst to rjfu1
c       and lat rjfu2 to yt(jmtm2)
c
c     lsegf  = max number of longitudinal strips for filtering
c     jmtfil = max number of latitudes to be filtered
c     numflt = specifies the number of filter applications to use
c              for the tracers when using the finite impulse
c              response filter
c     numflu = specifies the number of filter applications to use
c              for velocities and vorticity when using the finite
c              impulse response filter
c
c
c
      parameter (lsegf=5, jmtfil=20)
c
      common /cfilr/ rjfrst, rjft0, rjft1, rjft2, rjfu0, rjfu1, rjfu2
      common /cfil/   jfrst,  jft0,  jft1,  jft2,  jfu0,  jfu1,  jfu2
     $,               jskpt, jskpu, njtbft, njtbfu
#ifdef firfil
     $,               numflt(jmtfil), numflu(jmtfil)
#endif
c
#DECK scalar.h
c====================== include file "scalar.h" ========================
c
c     various scalar quantities:
c
c     dtts   = time step for density & tracers (in seconds)
c     dtuv   = time step for baroclinic velocity (in seconds)
c     dtsf   = time step for barotropic velocity (in seconds)
c     c2dtts = 2*dtts
c     c2dtuv = 2*dtuv
c     c2dtsf = 2*dtsf
c     area   = surface area of ocean (cm**2)
c     volume = volume of ocean (cm**3)
c     omega  = earth's rotation rate (radians/sec)
c     radius = earth's radius (cm)
c     grav   = earth's gravitational acceleration (cm/sec**2)
c     cdbot  = bottom drag coefficient
c     ncon   = number of  passes through convective code in tracer
c
      common /scalar/ dtts, dtuv, dtsf, c2dtts, c2dtuv, c2dtsf
     $,               area, volume, omega, radius, grav, cdbot
      common /scalri/ ncon
c
c     bring in non dimensional constants
c
#include "ndcon.h"
c
#DECK slabs.h
c====================== include file "slabs.h" =========================
c
c                         slab layout on disk
c
c     on disk, each model latitude is represented by a slab (or latitude
c     row of data). there are three disks and each contains a different
c     time level (one for past "n-1", present "n", & predicted "n+1"
c     data )
c
c                         memory slab window
c
c     the memory slab window is "nslabs" wide and "ntau" time levels
c     deep. in subroutine "step", as row j cycles from 1 through jmt-1,
c     (south to north) slab data is read into the memory slab window
c     from disk "n" & disk "n-1". this data can be referenced in the
c     memory slab window using the following pointers (indices) :
c
c     jm     = points to the row j-1 data
c     jc     = points to the the central row j data
c     jp     = points to the the row j+1 data
c     jpp    = points to the row j+2 data (biharmonic option only)
c
c     jpt1   = cyclic pointer (index) from 1 to numjpt
c              (only for internal mode & biharmonic use)
c              points to data at jrow - 1
c     jpt2   = cyclic pointer (index) from 1 to numjpt
c              (only for internal mode & biharmonic use)
c              points to data at jrow
c     jpt3   = cyclic pointer (index) from 1 to numjpt
c              (only for internal mode & biharmonic use)
c              points to data at jrow + 1
c
c     nm     = points to time level n-1 (in "timelv.h")
c     nc     = points to current time level n (in "timelv.h")
c     np     = points to time level n+1 (in "timelv.h")
c
c     pointers (indices) jm,jc,jp & jpp take on values from 1 to
c     "nslabs"
c     pointers (indices) jpt1,jpt2,jpt3 take on values from 1 to
c     "numjpt"
c     pointers (indices) nm,nc & np take on values from 1 to "ntau"
c
c     lcor   = points to time level for coriolis term(implicit/explicit)
c     m1     = points to location of "u"  within slab (for biharmonic)
c     m2     = points to location of "v"  within slab (for biharmonic)
c
c     the slab data is :
c
c     t = tracer quantites. the 1st is temperature & the 2nd is salinity
c         if nt > 2 then other tracers are allowed.
c     u = zonal component of velocity.
c     v = meridional component of velocity.
c
c         (note: only the baroclinic component of the velocity is stored
c                on the slab disks. in memory, the barotropic component
c                is added on to give the full velocity)
c
c
#ifndef multitasking
# define task
#endif
#include "timelv.h"
#ifdef biharmonic
      task common /slabs/ jm, jc, jp, jpp, jpt1, jpt2, jpt3, lcor
     $,                   m1, m2
#else
      task common /slabs/ jm, jc, jp, jpt1, jpt2, lcor
#endif
     $,                   t(imt,km,nslabs,ntau,nt)
     $,                   u(imt,km,nslabs,ntau)
     $,                   v(imt,km,nslabs,ntau)
c
c     normally, "np" is not used since predicted quantities at level
c     "np" are stored into the buffer slab before being written to disk
c
c     ta = buffer area to hold the updated "n+1" tracer slab data
c     ua = buffer area to hold the updated "n+1" u slab data
c     va = buffer area to hold the updated "n+1" v slab data
c
c     when all prognostic slab variables have been updated, the
c     common /bufout/ area is written to disk
c
      task common /bufout/ ta(imt,km,nt), ua(imt,km), va(imt,km)
c
c     all prognostic slab variables are read from disk using the
c     common /bufin/ area and transferred to the appropriate locations
c     in the memory slab window via "xfer"
c
      task common /bufin/ bufsl(imt,km,nvar)
c
c
c     uclin  = internal mode u (used for advective fluxes & diagnostics)
c              (,,1) is for "jrow"; (,,2) is for "jrow+1"
c     vclin  = internal mode v (used for advective fluxes & diagnostics)
c              (,,1) is for "jrow"; (,,2) is for "jrow+1"
c     rhon   = density at row j+1 on the "t" grid
c     rhos   = density at row j on the "t" grid
c     dpdx   = zonal gradient of pressure on "u,v" grid
c     dpdy   = meridional gradient of pressure on "u,v" grid
c     fuw    = advective coeff for western face of "u,v" grid box
c              in "clinic" & "t" grid box in "tracer"
c     fvn    = advective coeff for northern face of "u,v" grid box
c              in "clinic" & "t" grid box in "tracer"
c     fvst   = advective coeff for southern face of "t" grid box
c     fvsu   = advective coeff for southern face of "u,v" grid box
c     fm     = (0,1) over "t" grid (land,ocean) points
c     gm     = (0,1) over "u,v" grid (land,ocean) points
c     vmf    = array (1) used for vertical differences of u
c     vmf    = array (2) used for vertical differences of v
c     vtf    = array used for vertical tracer flux
c     w      = vertical velocity defined at the bottom of "u,v" boxes
c              in "clinic" and "t" boxes in "tracer"
c     fwb1   = w * (quantity 1) defined at the bottoms of the boxes
c     fwb2   = w * (quantity 2) defined at the bottoms of the boxes
c     restr  = term for restoring surface tracers to prescribed values
c              via newtonain damping
c     rests  = time scale for restoring surface tracers (days)
c
      task common /work/
     $ uclin(imt,km,numjpt),   vclin(imt,km,numjpt)
     $,dpdx(imt,km),      dpdy(imt,km),     fuw(imt,km),   fvn(imt,km)
     $,fvsu (imt,km),     fvst (imt,km),    rhon(imt,km),  rhos(imt,km)
     $,fm(imt,km,nslabs), gm(imt,km,nslabs)
     $,vmf(imt,0:km,2),   vtf(imt,0:km)
     $,w(imt,0:km),       fwb1(imt,0:km),   fwb2(imt,0:km)
#ifdef restorst
     $,restr(imt,nt)
      common /workr/ rests
#endif
c
c     aux = auxiliary arrays for storing intermediate results to
c           prevent redundant calculation
c
      task common /aux/ aux1(imt,km), aux2(imt,km), aux3(imt,km)
     $,            aux4(imt,km)

c
c     sourcu = source term for zonal component of momentum
c     sourcv = source term for meridional component of momentum
c     sourct = source term for tracer
c
      task common /source/ sourcu(imt,km), sourcv(imt,km)
     $,                    sourct(imt,km,nt)
c
c     if momentum & tracer terms are to be kept (as opposed to being
c     statement functions) then they are dimensioned here.
c
#ifdef keepterms
      task common /terms/
     $               UTx(imt,km), VTy(imt,km), WTz(imt,km)
#ifdef isopycmix
     $,              Tisox(imt,km), Tisoy(imt,km), Tisoz(imt,km)
#else
     $,              Txx(imt,km), Tyy(imt,km)
#endif
     $,              Tzz(imt,km)
     $,              UUx(imt,km), UVx(imt,km), VUy(imt,km)
     $,              VVy(imt,km), WUz(imt,km), WVz(imt,km)
#ifndef nohilats
     $,              UVtan(imt,km), UUtan(imt,km)
#endif
     $,              Uxx(imt,km), Uyy(imt,km), Umet(imt,km)
     $,              Vxx(imt,km), Vyy(imt,km), Vmet(imt,km)
     $,              Uzz(imt,km), Vzz(imt,km), fU(imt,km), fV(imt,km)
#endif
c
c     include further extensions to the "slabs.h" here. care must
c     be exercised when adding additional variables to the slab block.
c     increase "nvar" & "nvarbh" appropriately. also be careful to
c     add the variables to "delsq"
c
#ifdef tcvmix
#include "tcslab.h"
#endif
#DECK switch.h
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made in time manager "tmngr.F"
c     and communicated elsewhere in the model via logical switches .
c
c     inputs: (set through namelist)
c
c     dgnstc  = number of days between diagnostic calculations:
c               global energetics & regional momentum & tracer term
c               balances
c     travg   = number of days between regional tracer averages
c               (under horizontal regions)
c
c     tsi     = number of days between printing of time step info
c     days    = number of days to integrate
c     nmix    = number of time steps between time step mixing
c               to damp leap frog time splitting
c     init    = (false,true) to indicate if this run is a
c               (restart, start from initial conditions)
c     restrt  = (false,true) = (don't,do) write a restart at the end
c               of this run
c     snaps   = number of days between taking instantaneous snapshots
c               (saving data) for off line analysis.
c               symbolically ... the data saved is:
c
c                 write (iosnap) itt, dtts, relyr, stamp
c                 write (iosnap) xt, yt, zt
c                 do ... jrow=2,jmtm1
c                   write (iosnap) smf, stf, slab(jrow)
c                 continue
c                 write (iosnap) stream function
c
c
c     acor    = (>0, 0) = (implicit, explicit) treatment of coriolis
c               term
c     eb      = (false,true) implies (forward, euler backward) mixing
c               time step
c
c
c     outputs: (set in tmngr.F)
c
c     the following logical switches are set within "tmngr" every
c     time step based on the above requirements.
c
c     diagts  = (false,true) = (don't do) do diagnostic calculation
c                                          based on "dgnstc"
c     eom     = true on the first time step of the new month
c               otherwise ... false
c     tavgts  = (false,true) = (don't do) do tracer averages
c                                          based on "travg"
c     snapts  = (false,true) = (don't,do) save a snapshot of the data
c                                          based on "snaps"
c     mixts   = (false,true) = (don't do) do mixing time step
c                                          based on "nmix"
c     mxpas2  = (false,true) = (don't do) do 2nd pass of a mixing
c                                          time step (if "eb" = true.)
c                                          (set in ocean.F)
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c
c     prntsi  = (false,true) = (don't,do) print time step info
c                                          based on "ntsi"
c     last    = (false,true) = (don't,do) stop the integration when
c                                          this time step completes
c                                          based on "days"
c     first   = (false,true) =  when it's (not the first, the first)
c                               time step of a run
c
      logical diagts, mixts, mxpas2, prntsi, eb, last, init, first
     $,       restrt, snapts, tavgts, eom, eots
c
      common /switch/ dgnstc, nmix, tsi, days, travg, snaps, acor
c
      common /switch/ diagts, mixts, mxpas2, prntsi, last, tavgts
     $,               init, first, restrt, snapts, eb, eom, eots
c
#DECK tcslab.h
c====================== include file "tcslab.h" ========================
c
c     slab block extensions for turbulent closure
c
#ifndef multitasking
# define task
#endif
      task common /slabs/
     $                   vvc(imt,km,nslabs,ntau)
     $,                  vdc(imt,km,nslabs,ntau)
     $,                  vdqc(imt,km,nslabs,ntau)
     $,                  q2(imt,km,nslabs,ntau)
#  ifdef leq
     $,                  q2l(imt,km,nslabs,ntau)
#  endif
c
c     q2a   = buffer area to hold the updated "n+1" q2 slab data
c     vvca  = buffer area to hold the updated "n+1" km slab data
c     vdca  = buffer area to hold the updated "n+1" kh slab data
c     vdqca = buffer area to hold the updated "n+1" kq slab data
c     q2la  = buffer area to hold the updated "n+1" q2l slab data
c
      task common /bufout/
     $                   vvca(imt,km)
     $,                  vdca(imt,km)
     $,                  vdqca(imt,km)
     $,                  q2a (imt,km)
#ifdef leq
     $,                  q2la(imt,km)
#endif
c
#DECK temp.h
c====================== include file "temp.h" ==========================
c
c     temporary scratch areas for use where needed.
c     zzi  = temporary storage for implicit vertical diffusion
c
#ifndef multitasking
# define task
#endif
      task common /temps/ tempik(imt,km,2)
#if defined implicitvmix || defined isopycmix
     $,                   zzi(imt,km,2)
#endif
c
#DECK thick.h
c====================== include file "thick.h" ========================
c     specifications for box thickness (cm) in the vertical
c
      data dzt /   30.00e2,   46.15e2,   68.93e2,   99.93e2,  140.63e2
     $      ,  192.11e2,  254.76e2,  327.95e2,  409.81e2,  497.11e2
     $      ,  585.36e2,  669.09e2,  742.41e2,  799.65e2,  836.10e2
     $   /
c
c     dzt = model level thicknesses computed as
c     dzt(km+1-k)=exp(-(k/sigma)**2) + offset) for k=1,km
c      km =  15
c      sigma=  8.204686
c      offset= 0.0000000
c      1st level thickness =  30.00000
c      # of levels with this thickness =  1
c      depth at bottom of last level =  5700.000
c
#DECK timelv.h
c====================== include file "timelv.h" ========================
c
c     time level pointers (indices) for the memory slab window
c
c     nm = time level pointer (index) corresponding to "tau-1"
c     nc = time level pointer (index) corresponding to "tau"
c     np = time level pointer (index) corresponding to "tau+1"
c
c
      common /ctlevp/ nm, nc, np
c
#DECK versno.h
c====================== include file "versno.h" ========================
c
      character*80 model
      common /versno/ model
c
#DECK bcest.F
      subroutine bcest (j, bcval)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c     this routine linearly interpolates global, zonal mean values of
c     ocean model surface boundary conditions (SST, salinity, WSX, WSY)
c     having 4.5 deg spacing, to the requested latitdude.
c=======================================================================
#include "param.h"
#include "coord.h"
#include "switch.h"
c
      parameter (nbc = 4, nolat = 40, nolatp = nolat+1)
c
#ifndef multitasking
# define task
#endif
      task common /cbcest/ olatt(nolat), olatv(nolatp), dolat, rdolat
      dimension sstobs(nolat), salobs(nolat)
      dimension wsxobs(nolatp), wsyobs(nolatp)
      dimension bcval(nbc)
c
c     bcval  = estimated boundary condition values (t, s, wsx, wsy)
c       bcval(1) units = degrees C
c       bcval(2) units = parts per thousand
c       bcval(3) and bcval(4) units = dynes per square centimeter
c     nbc    = number of boundary conditions
c     olatt  = latitude points for observed data
c     olatv  = latitude points for observed data
c     dolat  = latitude spacing for observed data
c     ylatt  = latitude where t,s boundary conditions are desired
c     ylatv  = latitude where windstress boundary conditions are desired
c
c     "observed" temperature and salinity data are based on global,
c     annual mean zonally averaged values from the Levitus Atlas (1982).
c     "observed" windstress data are based on global, annual mean,
c     zonally averaged values from Hellerman and Rosenstein (1981).
c     some smoothing was done.
c
c     references:
c       Hellerman, S, and M. Rosenstein, normal monthly wind stress
c     over the world ocean with error estimates, J. Phys, Oceanogr., 13,
c     1093-1104,1983.
c       Levitus, S., Climatological atlas of the world ocean, NOAA
c     Prof. Paper 13, US Gov't printing Office, Washington, DC, 1982.
c
c
      data sstobs / -1.75, -1.75, -1.50, -1.50, -1.28,
     $              -0.55,  0.90,  2.92,  5.45,  8.62,
     $              12.27, 15.49, 18.30, 20.67, 22.64,
     $              24.14, 25.27, 26.37, 26.52, 26.16,
     $              26.85, 27.27, 26.82, 26.42, 25.53,
     $              24.03, 22.07, 19.73, 17.02, 12.77,
     $               8.93,  7.25,  6.22,  4.67,  4.57,
     $               3.03, -0.01, -1.05, -1.75, -1.75/
c
      data salobs / 34.30, 34.30, 34.30, 34.13, 33.98,
     $              33.97, 33.97, 33.98, 34.03, 34.24,
     $              34.61, 35.02, 35.37, 35.61, 35.72,
     $              35.68, 35.51, 35.22, 35.05, 35.12,
     $              34.80, 34.56, 34.71, 34.90, 35.27,
     $              35.67, 35.56, 35.49, 35.23, 34.28,
     $              33.57, 33.57, 33.60, 33.80, 34.04,
     $              34.05, 32.65, 32.30, 32.10, 32.00/
c
      data wsxobs /  0.00,
     $               0.00,  0.00, -0.02,  0.15,  0.31,
     $               0.50,  0.82,  1.08,  1.23,  1.16,
     $               0.84,  0.41,  0.02, -0.35, -0.55,
     $              -0.67, -0.64, -0.46, -0.29, -0.19,
     $              -0.16, -0.33, -0.52, -0.59, -0.55,
     $              -0.32,  0.09,  0.42,  0.56,  0.76,
     $               0.81,  0.65,  0.29,  0.06, -0.10,
     $              -0.05, -0.03,  0.05,  0.10,  0.01/
c
      data wsyobs /  .000,
     $               .000,  .009,  .032,  .005, -.023,
     $              -.075, -.155, -.202, -.230, -.179,
     $              -.049,  .093,  .214,  .294,  .344,
     $               .383,  .364,  .269,  .189,  .178,
     $               .125, -.122, -.213, -.251, -.259,
     $              -.202, -.189, -.179, -.183, -.009,
     $               .023,  .053, -.048, -.185, -.225,
     $              -.097, -.050, -.023, -.006,  .000/
c
c---------------------------------------------------------------------
c     set latitudes of sst and salinity observations
c     and set latitudes of windstress observations
c---------------------------------------------------------------------
c
      dolat = 180.0/nolat
      rdolat = c1/dolat
      do 100 n=1,nolat
        olatt(n) = -90.0 + (n-p5)*dolat
        olatv(n) = -90.0 + (n-1.0)*dolat
100   continue
      olatv(nolatp) = -90.0 + (nolat)*dolat
c
c---------------------------------------------------------------------
c   use linear interpolation to produce the estimated surface boundary
c   condition values for temperature and salinity at t,s row j
c---------------------------------------------------------------------
c
      ylatt = yt(j)
c
      if (ylatt .le. olatt(1)) then
        nn = 1
        d = c0
      elseif (ylatt .ge. olatt(nolat)) then
        nn = nolat-1
        d = dolat
      else
        do 200 i=2,nolat
          if (ylatt .le. olatt(i)) then
            nn = i - 1
            d  = ylatt - olatt(nn)
            goto 201
          endif
200     continue
      endif
c
201   continue
      bcval(1) = (sstobs(nn)*(dolat - d) + sstobs(nn+1)*d)*rdolat
      bcval(2) = (salobs(nn)*(dolat - d) + salobs(nn+1)*d)*rdolat
c
c---------------------------------------------------------------------
c   use linear interpolation to produce the estimated surface boundary
c   condition values for wind stress components at u,v row j
c---------------------------------------------------------------------
c
      ylatv = yu(j)
c
      if (ylatv .le. olatv(1)) then
        nn = 1
        d = c0
      elseif (ylatv .ge. olatv(nolatp)) then
        nn = nolatp - 1
        d = dolat
      else
        do 300 i=2,nolatp
          if (ylatv .le. olatv(i)) then
            nn = i - 1
            d  = ylatv - olatv(nn)
            goto 301
          endif
300     continue
      endif
301   continue
      bcval(3) = (wsxobs(nn)*(dolat - d) + wsxobs(nn+1)*d) *rdolat
      bcval(4) = (wsyobs(nn)*(dolat - d) + wsyobs(nn+1)*d) *rdolat
c
      return
      end
#DECK blkdta.F
      block data blkdta
#include "param.h"
#include "accel.h"
#ifdef testcfl
# include "ccfl.h"
#endif
#include "chmix.h"
#ifdef isopycmix
#include "cisop.h"
#endif
#include "coord.h"
#include "cprnts.h"
#ifdef ppvmix
#include "cppmix.h"
#endif
#ifdef tcvmix
#include "ctcmix.h"
#endif
#include "ctask.h"
#include "ctmngr.h"
#include "cvmix.h"
#include "grdvar.h"
#include "iounit.h"
#if defined firfil || defined fourfil
#include "pfil.h"
#endif
#include "scalar.h"
#ifdef restorst
#include "slabs.h"
#endif
#include "switch.h"
#include "versno.h"
c
c     specify current MOM version info
c
      data model/
     $' GFDL Modular Ocean Model (MOM) version 1.1 ... Aug 16, 1993 '/
c
c     initialize time at initial conditions. see "ctmngr.h"
c
      data year0  /0/
      data month0 /1/
      data day0   /1/
      data hour0  /0/
      data minut0 /0/
      data sec0   /0/
c
c     specify julian calendar
c
      data julian /.true./
c
c     initialize all quantities that define the grid. see "coord.h"
c
      data stlon, stlat / -4.0, -90.0 /
c
c     specifications for "nxres" distinct longitudinal domains (deg)
c
      data xmax /4.0/
      data xmin /4.0/
      data xwid /368.0/
      data idir /1/
c
c     specifications for "nyres" distinct latitudinal domains (deg)
c
      data ymax /3.0/
      data ymin /3.0/
      data ywid /180.0/
      data jdir /1/
c
#include "thick.h"
c
c     initialize some switches. see "switch.h"
c
      data init /.false./, first/.true./, tsi /1.0/, dgnstc/365.25/
      data travg /365.25/, snaps/365.25/
c
c     initialize some vertical mixing coefficients. see "cvmix.h"
c
      data  bvdc, bvvc / 0.00134, 0.0134/
      data fkph, fkpm / 20.0, 1.0/
c
c     initialize some horizontal mixing coefficients. see "chmix.h"
c
      data am, ah /1.e9, 2.e7/
c
c     set bottom drag coefficient. see "scalar.h"
c
      data cdbot /0.0/
#ifdef testcfl
c
c     factor by which the CFL criteria must be exceeded in order to
c     stop MOM
c
      data cflcrt /1.5/
#endif
#if defined implicitvmix || defined isopycmix
c
c     default to fully implicit vertical mixing. zero gives explicit
c
      data aidif /1.0/
#else
      data aidif /0.0/
#endif
#ifdef multitasking
c
c     initialize the number of tasks for cycling slabs. see "ctask.h"
c     "ntasks" should be set to the number of processors. default is
c     for an 8 processor cray ymp.
c
      data ntasks /8/
#else
c
c     uni-tasking case. one task is the default. "ntasks" can be set
c     greater than 1 but this leads to redundant calculations at the
c     interface between tasks.
c
      data ntasks /1/
#endif
c
c     set type of time mixing. see "switch.h"
c
      data eb /.true./
c
c     set number of time steps between time mixing. see "switch.h"
c
      data nmix /17/
c
c     set number of convective passes in "tracer.F". see "scalar.h"
c
      data ncon /1/
c
c     default starting & ending coordinates for matrix prints during
c     diagnostic time steps (lats & lons in degrees, depths in cm)
c     see "cprnts.h"
c
      data prlat /-60.0, 0.0, 27.0, 55.0, 6*100.0/
      data prslon /180.0, 180.0, 180.0, 180.0, 6*0.0/
      data prelon /250.0, 250.0, 250.0, 250.0, 6*0.0/
      data prsdpt /nlatpr*0.0/
      data predpt /nlatpr*6000.e2/
      data slatxy, elatxy, slonxy, elonxy /-90.0, 90.0, 3.0, 357.0/
c
c     default the i/o units. see "iounit.h"
c
c     (note labs units must be sequential for the "diskless" option)
c
      data kontrl /11/, kflds /12/, labs /13, 14, 15/
      data iorest /21/, restrt /.false./
      data iormsk /55/, iotavg /stdout/, iotrmb/stdout/, iosnap/22/
c
c     initialize physical constants. see "scalar.h"
c
      data grav /980.6/, radius /6370.e5/
c
#if defined firfil || defined fourfil
c
c     set latitudes used in filtering of tracer and velocity fields
c     see "pfil.h"
c
      data rjfrst /-81.0/
      data rjft0, rjft1, rjft2 /-51.0, -57.0, 57.0/
      data rjfu0, rjfu1, rjfu2 /-54.0, -60.0, 60.0/
c
#endif
#ifdef firfil
c     "numflt" specifies the number of filter applications to use
c              for the tracers
c     "numflu" specifies the number of filter applications to use
c              for velocities and vorticity
c
      data numflt /jmtfil*1/
      data numflu /jmtfil*1/
c
#endif
c
c     "dtxcel" specifies the depth dependent dtts timestep multipliers
c      see "accel.h"
c
       data dtxcel /km*1.0/
c
#ifdef restorst
c
c      time scale for restoring surface tracers to prescribed values
c      see "setvbc.F"
c
       data rests /50.0/
#endif
#if defined constvmix && defined implicitvmix
      data vvclim, vdclim / 1.0e6, 1.0e6/
#endif
#ifdef ppvmix
c
c     initialize constants for pacanowski & philander vertical mixing
c     see "cppmix.h"
c
      data  wndmix / 10.0/
      data fricmx  / 50.0/
# ifdef implicitvmix
c
c     simulate convective adjustment with large mixing coefficient
c     limits
c
      data vvclim, vdclim  / 1.0e6, 1.0e6/
# else
c
c     in regions of gravitational instability set mixing limits to the
c     maximum consistent with the "cfl" criterion. convective adjustment
c     will also act on the instability.
c
      data vvclim, vdclim / 50.0, 50.0/
# endif
#endif
#ifdef isopycmix
c
c     initialize constants for isopycnal oriented mixing of tracers
c     see "cisop.h"
c
      data slmxr  / 100.0/
      data ahisop / 2.0e7/
#endif
#ifdef tcvmix
c
c     data initialize constants for turbulence closure vertical mixing
c     see "ctcmix.h"
c
      data a1, b1, a2, b2, cc1 /0.92, 16.6, 0.74, 10.1, 0.08/
      data e1, e2, e3 /1.8, 1.33, 1.0/
      data aq /2.0e7/
# ifdef implicitvmix
      data vvclim, vdclim, vdqlim /1.e6, 1.e6, 1.e6/
# else
      data vvclim, vdclim, vdqlim /1.e1, 1.e1, 1.e1/
# endif
      data alpha /.1/
      data vk /0.40/
      data sq /0.2/
      data small /1.e-6/
      data big /1.e15/
      data deps /1.e-10/
      data c100 /100.0/
      data p48 /0.48/, p032 /0.032/, c15/15.0/, p1/0.1/, p4/0.4/
      data p154 /.154/
      data gh /imtkm*0.154/
      data gmp1 /imtkm*0.154/
      data sm /imtkm*0.39/
      data sh /imtkm*0.49/
      data rhoh2o /1.025/
#endif
      end
#DECK cfl.F
      subroutine cfl (j)
#ifdef multitasking
cfpp$ noconcur r
#endif
#ifdef testcfl
#include "param.h"
#include "accel.h"
#include "ccfl.h"
#include "coord.h"
#include "ctmngr.h"
#include "docnam.h"
#include "grdvar.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
c
      cl = cflcrt * p5
      do 100 k=1,km
        dtmax = max(dtuv, dtts*dtxcel(k))
        f1    = dtmax*dyur(j)
        f2    = dtmax*dzwr(k)
        do 90 i=2,imtm1
          cflu = abs(dtmax*dxur(i)*u(i,k,jc,nc))
          cflv = abs(f1*v(i,k,jc,nc))
          cflw = abs(f2*w(i,k))
          if (cflu .ge. cl .or. cflv .ge. cl .or. cflw .ge. cl) then
            write (stdout,'(/,a33,i4,a1,i3,a1,i3,a1,/)')
     $       ' ==> cfl exceeded at coordinate (i,j,k) = (',i
     $,      ',',j,',',k,')'
            umax  = p5*dxu(i)/dtmax
            pcflu = abs(100.0*u(i,k,jc,nc)/umax)
            vmax  = p5*dyu(j)/dtmax
            pcflv = abs(100.0*v(i,k,jc,nc)/vmax)
            wmax  = p5*dzw(k)/dtmax
            pcflw = abs(100.0*w(i,k)/wmax)
            write (stdout,'(a15,f8.2,a21,g15.8,a1)')
     $       ' u reached ', pcflu,' % of the CFL limit (',umax,')'
            write (stdout,'(a15,f8.2,a21,g15.8,a1)')
     $       ' v reached ', pcflv,' % of the CFL limit (',vmax,')'
            write (stdout,'(a15,f8.2,a21,g15.8,a1)')
     $       ' w reached ', pcflw,' % of the CFL limit (',wmax,')'
            is = max(1,i-3)
            ie = min(imt,i+3)
            ks = max(1,k-3)
            ke = min(km,k+3)
            scl = c0
            fx  = 1.0e-2
            write (stdout,9100)'u velocity', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (u(1,1,jc,nc), imt, is, ie, ks, ke, scl)
c
            write (stdout,9100) 'v velocity', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (v(1,1,jc,nc), imt, is, ie, ks, ke, scl)
c
            write (stdout,9100)  'w velocity', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (w, imt, is, ie, ks, ke, scl)
c
            do 80 m=1,nt
              write (stdout,9100) trname(m), itt
     $,        j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
              call matrix (t(1,1,jc,nc,m), imt, is, ie, ks, ke, scl)
80          continue
            stop 'CFL'
          endif
90      continue
100   continue
      if (diagts .and. eots) then
        do 200 k=1,km
          dtmax = max(dtuv, dtts*dtxcel(k))
          vmax  = p5*dyu(j)/dtmax
          wmax  = p5*dzw(k)/dtmax
          do 190 i=2,imtm1
            umax  = p5*dxu(i)/dtmax
            if (abs(100.0*u(i,k,jc,nc)/umax) .gt. cflup) then
              cflup = abs(100.0*u(i,k,jc,nc)/umax)
              cflum  = u(i,k,jc,nc)
              icflu = i
              jcflu = j
              kcflu = k
            endif
            if (abs(100.0*v(i,k,jc,nc)/vmax) .gt. cflvp) then
              cflvp = abs(100.0*v(i,k,jc,nc)/vmax)
              cflvm  = v(i,k,jc,nc)
              icflv = i
              jcflv = j
              kcflv = k
            endif
            if (abs(100.0*w(i,k)/wmax) .gt. cflwp) then
              cflwp = abs(100.0*w(i,k)/wmax)
              cflwm  = w(i,k)
              icflw = i
              jcflw = j
              kcflw = k
            endif
190       continue
200     continue
      endif
9100  format(1x,a12,1x,'ts=',i10,1x,',j=',i3,', lat=',f6.2
     $,', lon:',f6.2,' ==> ',f6.2,', depth(m):',f6.1,' ==> ',f6.1
     $,', scaling=',1pg10.3)
#endif
      return
      end

#DECK checks.F
      subroutine checks
      logical errorc, test
#include "param.h"
#include "accel.h"
#include "chmix.h"
#ifdef isopycmix
# include "cisop.h"
#endif
#include "coord.h"
#ifdef ppvmix
# include "cppmix.h"
#endif
#ifdef tcvmix
# include "ctcmix.h"
#endif
#include "cvmix.h"
#include "ctask.h"
#include "grdvar.h"
#include "levind.h"
#include "scalar.h"
#include "switch.h"
c
c-----------------------------------------------------------------------
c     do consistency checks before allowing MOM to continue
c-----------------------------------------------------------------------
c
      errorc = .false.
      write (stdout,9000) ' Consistency check messages:'
c
c
      if (ntlev .eq. 2 .and. ntasks .ne. 1) then
        write (stdout,9000)
     $  '==> Error: ntasks > 1 is presently incompatible with the     '
     $, '           diskless option. use ntasks=1 or use another I/O  '
     $, '           option.  (or change "ntlev" to 3 but this will    '
     $, '           increase the memory and was not checked  out)     '
        errorc = .true.
      endif
#if !defined diskless && !defined crayio && !defined fio
        write (stdout,9000)
     $  '==> Error: either "diskless", crayio" or "fio"               '
     $, '           option must be turned on.                         '
        errorc = .true.
#endif
#if defined diskless && defined crayio
        write (stdout,9000)
     $  '==> Error:  "diskless" and "crayio" are incompatible         '
     $, '             choose one or the other option.                 '
        errorc = .true.
#endif
#if defined diskless && defined fio
        write (stdout,9000)
     $  '==> Error:  "diskless" and "fio" are incompatible            '
     $, '             choose one or the other option.                 '
        errorc = .true.
#endif
#if defined crayio && defined fio
        write (stdout,9000)
     $  '==> Error:  "crayio" and "fio" are incompatible              '
     $, '             choose one or the other option.                 '
        errorc = .true.
#endif
c
c
#ifdef isopycmix
      if (ntasks .gt. 1) then
         write (stdout,9000)
     $  '==> Error:  isopycmix does not yet work with ntasks > 1      '
     $, '            use ntasks=1                                     '
        errorc = .true.
      endif
      if (aidif .lt. p5) then
         write (stdout,9000)
     $  '==> Error:  isopycmix must use aidif >= 0.5                  '
     $, '            (must be fully implicit)                         '
        errorc = .true.
      endif
# ifdef skipland
        write (stdout,9000)
     $  '==> Error:  isopycmix does not yet work with skipland        '
        errorc = .true.
# endif
# ifdef multitasking
      write (stdout,9000)
     $  '==> Error:  isopycmix does not yet work with multitasking    '
        errorc = .true.
# endif
# if !defined ppvmix && !defined tcvmix && !defined constvmix
        write (stdout,9000)
     $  '==> Error: either  "ppvmix" or "tcvmix"  or "constvmix"      '
     $, '           option must be turned on with isopycmix.          '
        errorc = .true.
# endif
# if !defined consthmix && !defined biharmonic && !defined nlhmix
        write (stdout,9000)
     $  '==> Error: since isopycmix only affects tracer diffusion,    '
     $, '    either "consthmix", "biharmonic" or "nlhmix" must be     '
     $, '    turned on with for use in mixing momentum in clinic      '
     $, '    (only "consthmix" has been checked out)                  '
        errorc = .true.
# endif
# if defined consthmix
        write (stdout,9000)
     $  '==> Note: consthmix will only affect mixing of momentum      '
     $, '    since isopycmix was specified for tracer diffusion       '
# endif
# if defined biharmonic
        write (stdout,9000)
     $  '==> Warning: biharmonic will only affect mixing of momentum  '
     $, '    since isopycmix was specified for tracer diffusion       '
     $, '    (this combination is not fully checked out)              '
# endif
# if defined nlhmix
        write (stdout,9000)
     $  '==> Warning: nlhmix will only affect mixing of momentum      '
     $, '    since isopycmix was specified for tracer diffusion       '
     $, '    (this combination is not fully checked out)              '
# endif
#endif
c
c
#if !defined constvmix && !defined ppvmix && !defined tcvmix
# if !defined isopycmix
        write (stdout,9000)
     $  '==> Error: either "constvmix", ppvmix", "tcvmix"             '
     $, '           or "isopycmix" option must be turned on.          '
        errorc = .true.
# endif
#endif
#ifdef gargettmix
        write (stdout,9000)
     $  '==> Error:  "gargettmix" not implemented yet                 '
        errorc = .true.
#endif
#ifdef windvmix
        write (stdout,9000)
     $  '==> Error:  "windvmix" not implemented yet                   '
        errorc = .true.
#endif
#if defined biharmonic && !defined multitasking
      if (ntasks .gt. 1) then
        write (stdout,9000)
     $  '==> Error: ntasks > 1 is incompatible with the biharmonic    '
     $, '           option. when not multitasking with biharmonic     '
     $, '           mixing use ntasks=1                               '
        errorc = .true.
      endif
#endif
c
c
#if defined freesfc && defined rigidlid
        write (stdout,9000)
     $  '==> Error:  "freesfc" and "rigidlid" are incompatible        '
     $, '             choose one or the other option.                 '
        errorc = .true.
#endif
#ifdef freesfc
        write (stdout,9000)
     $  '==> Error:  "freesfc" not implemented yet                    '
        errorc = .true.
#endif
#ifndef rigidlid
        write (stdout,9000)
     $  '==> Error: "rigidlid" option is required in this version     '
     $, '            option must be turned on.                        '
        errorc = .true.
#endif
#ifdef rigidlid
# if !defined congrad5pt && !defined congrad9pt && !defined oldrelax
#  if !defined hypergrid
        write (stdout,9000)
     $  '==> Error: either "congrad5pt", congrad9pt", "oldrelax", or  '
     $, '           "hypergrid" option must be turned on.             '
        errorc = .true.
#  endif
# endif
# if defined congrad5pt && defined congrad9pt
        write (stdout,9000)
     $  '==> Error:  "congrad5pt" and "congrad9pt" are incompatible   '
     $, '             choose one or the other option.                 '
        errorc = .true.
# endif
# if defined oldrelax && defined hypergrid
        write (stdout,9000)
     $  '==> Error:  "oldrelax" and "hypergrid" are incompatible      '
     $, '             choose one or the other option.                 '
        errorc = .true.
# endif
# if defined oldrelax && defined congrad5pt
        write (stdout,9000)
     $  '==> Error:  "oldrelax" and "congrad5pt" are incompatible     '
     $, '             choose one or the other option.                 '
        errorc = .true.
# endif
# if defined oldrelax && defined congrad9pt
        write (stdout,9000)
     $  '==> Error:  "oldrelax" and "congrad9pt" are incompatible     '
     $, '             choose one or the other option.                 '
        errorc = .true.
# endif
# if defined hypergrid && defined congrad9pt
        write (stdout,9000)
     $  '==> Error:  "hypergrid" and "congrad9pt" are incompatible    '
     $, '             choose one or the other option.                 '
        errorc = .true.
# endif
# if defined hypergrid && defined congrad5pt
        write (stdout,9000)
     $  '==> Error:  "hypergrid" and "congrad5pt" are incompatible    '
     $, '             choose one or the other option.                 '
        errorc = .true.
# endif
#endif
c
c
#if !defined biharmonic && !defined nlhmix  && !defined consthmix
# if !defined isopycmix
        write (stdout,9000)
     $  '==> Error: either "biharmonic", nlhmix", "consthmix"         '
     $, '           or "isopycmix" option must be turned on.          '
        errorc = .true.
# endif
#endif
#if defined biharmonic && defined nlhmix
        write (stdout,9000)
     $  '==> Error: "biharmonic" and "nlhmix" are incompatible.       '
     $, '            choose one or the other option.                  '
        errorc = .true.
#endif
#if defined biharmonic && defined consthmix
        write (stdout,9000)
     $  '==> Error: "biharmonic" and "consthmix" are incompatible.    '
     $, '            choose one or the other option.                  '
        errorc = .true.
#endif
#if defined nlhmix && defined consthmix
        write (stdout,9000)
     $  '==> Error: "nlhmix" and "consthmix" are incompatible.        '
     $, '            choose one or the other option.                  '
        errorc = .true.
#endif
#if defined biharmonic
        if (am .lt. 1.e11 .or. ah .lt. 1.e11) then
          write (stdout,9000)
     $  '==> Error: "am" and/or "ah" are too small for the            '
     $, '             "biharmonic"  mixing option                     '
          errorc = .true.
        endif
        if (am .lt. c0 .or. ah .lt. c0) then
          write (stdout,9000)
     $  '==> Error: use positive "am" and "ah" for "biharmonic"       '
     $, '           option.  The (neg) sign is in the equation.       '
          errorc = .true.
        endif
#endif
#if defined consthmix
        if (am .gt. 1.e11 .or. ah .gt. 1.e11) then
          write (stdout,9000)
     $  '==> Error: "am" and/or "ah" are too big for the              '
     $, '             "consthmix"  mixing option                      '
          errorc = .true.
        endif
#endif
c
c
#if defined skipland && defined tcmix
        write (stdout,9000)
     $  '==> Warning: "skipland" not yet implemented in "tcmix"       '
#endif
#if defined multitasking && defined nlhmix
        write (stdout,9000)
     $  '==> Error: "nlhmix" not yet implemented for "multitasking"   '
        errorc = .true.
#endif
c
c
c
      if ((dtuv .ne. dtsf) .or. (dtuv .ne. dtts)) then
        write (stdout,9000)
     $  '==> Warning: use of unequal time steps implies the transient '
     $, '             response is unimportant and multiple equilibria '
     $, '             do not exist.                                   '
      endif
c
c     check for mixing coefficients larger than stability permits
c
      dymin  = dyt(2)
      dxmin  = dxt(2)
      dzmin  = dzt(1)
      xlmax  = dtxcel(1)
      do 100 j=2,jmtm1
        dymin  = min(dymin,dyt(j))
100   continue
      do 200 i=2,imtm1
        dxmin  = min(dxmin,dxt(i))
200   continue
      do 300 k=2,km
        xlmax  = max(xlmax,dtxcel(k))
        dzmin  = min(dzmin,dzt(k))
300   continue
c
      if (xlmax .gt. c1) then
        write (stdout,9000)
     $  '==> Warning: use of accelerated time steps implies the       '
     $, '             transient response is unimportant and multiple  '
     $, '             equilibria do not exist. stability tests will   '
     $, '             use "dtts" multiplied by the maximum "dtxcel"   '
      endif
c
c
c
#if defined consthmix || defined isopycmix
      dtxl = dtts*xlmax
      do 350 j=2,jmtm1
        dxdymn = c1/(c1/(dxmin*cst(j))**2 + c1/dymin**2)
# ifdef isopycmix
        if ((dtxl*(ah+ahisop))/dxdymn .ge. p25) then
# else
        if ((dtxl*asubh)/dxdymn .ge. p25) then
# endif
          write (stdout,9000)
# ifdef isopycmix
     $  '==> Warning: lateral diffusive criteria exceeded for "ah" +  '
     $, '             "ahisop". use a smaller "dtts", "dtxcel", and/or'
     $, '             "ah" + "ahisop"                                 '
# else
     $  '==> Warning: lateral diffusive criteria exceeded for "ah".   '
     $, '              use a smaller "dtts", "dtxcel", and/or "ah"    '
# endif
          write (stdout,'(a48,f6.2,a5,i3)') ' at latitude ',yt(j)
     $,                                     ',  j=',j
        endif
        if ((dtuv*asubm)/dxdymn .ge. p25) then
          write (stdout,9000)
     $  '==> Warning: lateral diffusive criteria exceeded for "am".   '
     $, '             use a smaller "dtuv" and/or "am"                '
          write (stdout,'(a48,f6.2,a5,i3)') ' at latitude ',yt(j)
     $,                                     ',  j=',j
        endif
350   continue
#endif
#ifdef constvmix
      do 360 k=1,km
        if ((dtts*dtxcel(k)*fkph)/dzt(k)**2 .ge. p25) then
          write (stdout,9000)
     $  '==> Warning: vertical diffusive criteria exceeded for "fkph".'
     $, '             use a smaller "dtts", "dtxcel", and/or "fkph"   '
         write (stdout,'(a48,i3)') ' at level =',k
        endif
360   continue
      if ((dtuv*fkpm)/dzmin**2 .ge. p25) then
        write (stdout,9000)
     $  '==> Warning: vertical diffusive criteria exceeded for "fkpm".'
     $, '           use a smaller "dtuv" and/or "fkpm"                '
      endif
#endif
#ifdef implicitvmix
      write (stdout,9000)
     $  '==> Warning: "implicitvmix" turns convective adjustment off. '
     $, '              It will be handled by the vertical mixing      '
#else
      write (stdout,9000)
     $  '==> Warning: convective adjustment is enabled. Verify that   '
     $, '             "ncon" is set appropriately                     '
#endif
#if defined ppvmix && !defined implicitvmix
      do 370 k=1,km
        if ((dtts*dtxcel(k)*fricmx)/dzt(k)**2 .ge. p25) then
          write (stdout,9000)
     $  '==> Warning: vertical diffusive criteria exceeded for        '
     $, '           "fricmx".  use a smaller "dtts", "dtxcel", and/or '
     $, '           "fricmx"                                          '
          write (stdout,'(a48,i3)') ' at level =',k
        endif
        if ((dtts*dtxcel(k)*vdclim)/dzt(k)**2 .ge. p25) then
          write (stdout,9000)
     $  '==> Warning: vertical diffusive criteria exceeded for        '
     $, '            "vdclim". use a smaller "dtts", "dtxcel", and/or '
     $, '            "vdclim"                                         '
          write (stdout,'(a48,i3)') ' at level =',k
        endif
370   continue
      if ((dtuv*fricmx)/dzmin**2 .ge. p25) then
        write (stdout,9000)
     $  '==> Warning: vertical diffusive criteria exceeded for        '
     $, '            "fricmx". use a smaller "dtuv" and/or "fricmx"   '
      endif
      if ((dtuv*vvclim)/dzmin**2 .ge. p25) then
        write (stdout,9000)
     $  '==> Warning: vertical diffusive criteria exceeded for        '
     $, '           "vvclim".  use a smaller "dtuv" and/or "vvclim"   '
      endif
#endif
#if defined tcvmix && !defined implicitvmix
      do 380 k=1,km
        if ((dtts*dtxcel(k)*vdclim)/dzt(k)**2 .ge. p25) then
          write (stdout,9000)
     $  '==> Warning: vertical diffusive criteria exceeded for        '
     $, '            "vdclim".  use a smaller "dtts", "dtxcel", and/or'
     $, '            "vdclim"                                         '
          write (stdout,'(a48,i3)') ' at level =',k
        endif
380   continue
      if ((dtuv*vvclim)/dzmin**2 .ge. p25) then
        write (stdout,9000)
     $  '==> Warning: vertical diffusive criteria exceeded for        '
     $, '            "vvclim".  use a smaller "dtuv" and/or "vvclim"  '
      endif
#endif
c
      if (cdbot .eq. c0) then
        test = .false.
        do 400 j=2,jmtm1
          do 390 i=2,imtm1
            if (kmt(i,j) .ne. 0 .and. kmt(i,j) .ne. km) test = .true.
390       continue
400     continue
        if (test) then
          write (stdout,9000)
     $  '==> Warning: rough topography may induce checkerboarding     '
     $, '             especially in shelf regions. use of             '
     $, '             "cdbot" > 0.0 may help to supress it.           '
        endif
      endif
c
c     check range of implicit factors
c
#if defined implicitvmix || defined isopycmix
      if (aidif .lt. c0 .or. aidif .gt. c1) then
        write (stdout,9000)
     $  '==> Error: "aidif" must be between 0.0 & 1.0                 '
          errorc = .true.
      endif
#else
      if (aidif .gt. c0) then
        write (stdout,9000)
     $  '==> Warning: "aidif" was set > 0.0  but "implicivmix" is not '
     $, '              defined, so vertical mixing  will be  explicit '
     $, '                                      '
      endif
#endif
c
      if (acor .gt. c0) then
        write (stdout,9000)
     $  '==> Warning: "acor" was set > 0.0  implying that the         '
     $, '              coriolis term will be handled implicitly       '
      endif
      if (acor .lt. c0 .or. acor .gt. c1) then
        write (stdout,9000)
     $  '==> Error: "acor" must be between 0.0 & 1.0                  '
          errorc = .true.
      endif
c
c     check for resolved inertial oscillation
c
      if (acor .eq. c0) then
        fmax = abs(fcor(2))
        do 410 j=3,jmtm2
          fmax = max(fmax,abs(fcor(j)))
410     continue
        if (dtuv .gt. p25*(c2*pi)/fmax) then
          write (stdout,9000)
     $  '==> Warning: the inertial oscillation is not resolved.       '
     $, '             reduce "dtuv" or use "acor" > 0.0               '
        endif
      endif
#ifdef consthmix
c
c-----------------------------------------------------------------------
c     search for topographic instabilities (based  on the  work of
c     Peter Killworth  ...  eqn 11 from ocean modeling nov 1987)
c-----------------------------------------------------------------------
c
      num   = 50
      do 500 j=2,jmtm1
        dysq = dyt(j)**2
        do 490 i=2,imtm1
          if (kmt(i+1,j-1) .ne. 0 .and. kmt(i+1,j) .ne. 0) then
            dxsq = (dxt(i)*cst(j))**2
            clix = am*dtuv/dxsq
            h1   = zw(kmt(i+1,j-1))
            h2   = zw(kmt(i+1,j))
            hx   = (8.0*h1*h2/(h1+h2)**2 + dxsq/dysq)/(4.0 + dxsq/dysq)
            if (clix .ge. hx .and. num .ge. 0) then
              num = num - 1
              write (stdout,'(1x,a56,a31,i4,a1,i4,a1)')
     $        '==>   Warning: Killworth topographic roughness condition'
     $,       ' exceeded at location (i,j) = (',i+1,',',j,')'
              if (num .eq. 0) then
                write (stdout,9000)
     $         '==> Warning: msgs terminated after 50 cases were found '
              endif
            endif
          endif
490     continue
500   continue
#endif
      write (stdout,9000) ' End of consistency check messages:'
     $,                   ' '
      if (errorc) stop '=>checks'
c
c
      return
9000  format (/,(1x,a80))
      end
#DECK clinic.F
      subroutine clinic(j)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c
c     clinic computes internal mode velocity at time level n+1 for jow j
c
c=======================================================================
c
#include "param.h"
#ifdef biharmonic
# include "cbihar.h"
#endif
#include "cdiag.h"
#include "chmix.h"
#ifdef nlhmix
# include "cnlmix.h"
#endif
#include "cregin.h"
#include "ctask.h"
#include "cvbc.h"
#include "cvmix.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "levind.h"
#include "scalar.h"
#include "switch.h"
#include "slabs.h"
#include "temp.h"
c
      dimension ubar(imt), vbar(imt), ueng(imt), veng(imt), twodt(km)
c
#ifndef keepterms
c
c-----------------------------------------------------------------------
c     define operators using statement functions ...
c     otherwise they will be dimensioned in "slabs.h"
c-----------------------------------------------------------------------
c
#include "fdifm.h"
#endif
c
c-----------------------------------------------------------------------
c       calculate external mode velocities
c-----------------------------------------------------------------------
c
        do 100 i=2,imtm1
          ubar(i) = -(p(i,j+1,1)-p(i,j,1))*dyur(j)*
     $                   min(hr(i-1,j),hr(i,j))
          vbar(i) =  (p(i+1,j+1,1)-p(i,j+1,1))*dxur(i)*
     $                   min(hr(i,j+1),hr(i,j))*cstr(j+1)
100     continue
c
      if (j .eq. jsrow) then
c
c-----------------------------------------------------------------------
c       on the first row of a task:
c
c       1) compute advective coefficients at the south face of the
c          "u,v" box for the next row (jsrow+1)
c
c       2) compute density for the next row (jsrow+1) for ocean points
c          on the "t" grid
c
c       3) return
c-----------------------------------------------------------------------
c
#ifdef nlhmix
c
c       initialize deformation fields for nonlinear horizontal mixing
c
        do 180 k=1,km
          do 170 i=1,imt
            dtens(i,k)  = c0
            dshers(i,k) = c0
            dpuret(i,k) = c0
            dpures(i,k) = c0
170       continue
180     continue
#endif
c
c       calculate "fvsu" this way to insure that answers do not change
c       regardless of how "ntasks" is set
c
        fx = dyu2r(j)*csur(j)*cst(j+1)
        do 200 k=1,km
          do 190 i=2,imtm1
            fvsu(i,k)  = ((vclin(i,k,jpt2) + vclin(i,k,jpt1))*p5
     $                   + vbar(i))*fx
190       continue
200     continue
        fxb = csu(j)*dyu(j)*csur(j+1)*dyur(j+1)
        do 260 k=1,km
          do 250 i=2,imtm1
            fvsu(i,k) = fvsu(i,k)*fxb
250       continue
260     continue
c
        call state (t(1,1,jp,nc,1), t(1,1,jp,nc,2), rhos)
c
        return
c
      else
c
c-----------------------------------------------------------------------
c       on all but the first row of a task:
c
c       1) calculate advective coefficients "fuw" at the west face of
c          the "u,v" box & "fvn" at the north face of the "u,v" box
c          by combining external & internal modes with a grid factor
c
c       2) initialize velocities
c-----------------------------------------------------------------------
c
        fx = dyu2r(j)*csur(j)*cst(j+1)
        do 300 k=1,km
          do 270 i=2,imtm1
            fuw(i,k) = ((uclin(i,k,jpt1) + uclin(i-1,k,jpt1))*p5
     $                  + ubar(i))*csur(j)
            fvn(i,k) = ((vclin(i,k,jpt2)+vclin(i,k,jpt1))*p5
     $                  + vbar(i))*fx
270       continue
#ifdef cyclic
          fuw(imt,k) = fuw(2,k)
#else
          fuw(imt,k) = c0
#endif
#ifdef skipland
          do 290 i=1,imt
            ua(i,k) = c0
            va(i,k) = c0
290       continue
#endif
300     continue
      endif
c
#ifdef symmetry
c
c-----------------------------------------------------------------------
c     set symmetry conditions on the last row
c-----------------------------------------------------------------------
c
      if (j .eq. jmtm1) then
        do 600 k=1,km
          do 590 i=1,imt
            fvn(i,k)     = -fvsu(i,k)
            u(i,k,jp,nm) = u(i,k,jm,nm)
            u(i,k,jp,nc) = u(i,k,jm,nc)
590       continue
600     continue
      endif
#endif
c
c-----------------------------------------------------------------------
c     compute density on ocean points of "t" grid row j+1
c-----------------------------------------------------------------------
c
      call state (t(1,1,jp,nc,1), t(1,1,jp,nc,2), rhon)
c
#ifdef nlhmix
c
c-----------------------------------------------------------------------
c     set up diffusion factors for this row
c-----------------------------------------------------------------------
c
      call nlmix(j)
      bbu(j) = p5*csur(j)
      ccu(j) = effky(j)*dyur(j)*csur(j)*csur(j)
#endif
c
c-----------------------------------------------------------------------
c     initialize integral arrays for external mode diagnostics
c-----------------------------------------------------------------------
c
      if (diagts .and. eots) then
        do 700 ll=1,8
          do 690 i=1,imt
            zuneng(i,ll) = c0
            zvneng(i,ll) = c0
690       continue
700     continue
      endif
#ifdef skipland
c
c-----------------------------------------------------------------------
c     solve for velocity on longitudinal strips of ocean points.
c     if skipland is not set them "istart" & "iend" are parameters
c-----------------------------------------------------------------------
c
      do 3500 lstrip=1,lseg
        istart = isu(j,lstrip)
        iend   = ieu(j,lstrip)
        if (istart .ne. 0) then
#endif
c
c-----------------------------------------------------------------------
c         accumulate kinetic energy on row "j" every "ntsi" timesteps
c-----------------------------------------------------------------------
c
          if (prntsi) then
            fx = p25*csu(j)*dyu(j)
#ifdef symmetry
c
c           weight symmetry row by one half
c
            if (j .eq. jmtm1) fx = fx*p5
#endif
            do 800 k=1,km
              do 780 i=istart,iend
                tempik(i,k,1) = (fx*(u(i,k,jc,nc)*u(i,k,jc,nc) +
     $                      v(i,k,jc,nc)*v(i,k,jc,nc)))*c2dzt(k)*dxu(i)
780           continue
              do 790 i=istart,iend
                ektot(k,j) = ektot(k,j) + tempik(i,k,1)
790           continue
800         continue
          endif
c
c-----------------------------------------------------------------------
c         compute vertical velocity at the bottoms of u,v boxes
c-----------------------------------------------------------------------
c
c         compute divergence of mass at each level
c
          do 900 k=1,kmm1
            do 890 i=istart,iend
              w(i,k) = c2dzt(k)*((fuw(i+1,k)-fuw (i,k))*dxu2r(i) +
     $                            fvn(i  ,k)-fvsu(i,k))
890         continue
900       continue
c
c         integrate downward from the surface to define vertical
c         velocity at the bottom of each level
c
          do 1000 k=2,kmm1
            do 990 i=istart,iend
              w(i,k) = w(i,k) + w(i,k-1)
990         continue
1000      continue
c
c         set vertical velocity at the surface to zero (rigid-lid)
c         set vertical velocity at level k=km to zero
c         note: vertical velocity may be non zero at physical bottom
c         (if kmu(i,j) < km & there is a bottom slope).
c
          do 1100 i=istart,iend
            w(i,0)  = c0
            w(i,km) = c0
1100      continue
c
c-----------------------------------------------------------------------
c         compute hydrostatic pressure gradient
c-----------------------------------------------------------------------
c
c         compute it at the first level
c
          fxa = grav*dzw(0)*csur(j)
          fxb = grav*dzw(0)*dyu2r(j)
          do 1200 i=istart-1,iend
            t1        = rhon(i+1,1) - rhos(i  ,1)
            t2        = rhon(i  ,1) - rhos(i+1,1)
            dpdx(i,1) = (t1-t2)*fxa*dxu2r(i)
            dpdy(i,1) = (t1+t2)*fxb
1200      continue
c
c         compute the change in pressure gradient between levels
c
          fxa = grav*csur(j)*p5
          fxb = grav*dyu4r(j)
          do 1300 k=2,km
            do 1280 i=istart-1,iend+1
              tempik(i,k,1) = rhon(i,k-1) + rhon(i,k)
              tempik(i,k,2) = rhos(i,k-1) + rhos(i,k)
1280        continue
            do 1290 i=istart-1,iend
              t1        = tempik(i+1,k,1) - tempik(i  ,k,2)
              t2        = tempik(i  ,k,1) - tempik(i+1,k,2)
              dpdx(i,k) = fxa*(t1-t2)*dzw(k-1)*dxu2r(i)
              dpdy(i,k) = fxb*(t1+t2)*dzw(k-1)
1290        continue
1300      continue
c
c         integrate downward from the first level
c
          do 1400 k=1,kmm1
            do 1390 i=istart-1,iend
              dpdx(i,k+1) = dpdx(i,k) + dpdx(i,k+1)
              dpdy(i,k+1) = dpdy(i,k) + dpdy(i,k+1)
1390        continue
1400      continue
c
#ifdef skipland
          if (lstrip .eq. 1) then
#endif
            do 1500 k=1,km
#ifdef cyclic
              dpdx(imt,k) = dpdx(2,k)
              dpdy(imt,k) = dpdy(2,k)
#else
              dpdx(imt,k) = c0
              dpdy(imt,k) = c0
#endif
1500        continue
#ifdef skipland
          endif
#endif
c
c-----------------------------------------------------------------------
c         calculate quantities for the computation of
c         vertical diffusion and advection of momentum
c-----------------------------------------------------------------------
c
          do 1600 k=1,kmm1
            do 1590 i=istart,iend
#ifdef tcvmix
              vmf(i,k,1) = vvc(i,k,jc,nm)*(u(i,k,jc,nm)
     $                                   - u(i,k+1,jc,nm))*dzwr(k)
              vmf(i,k,2) = vvc(i,k,jc,nm)*(v(i,k,jc,nm)
     $                                   - v(i,k+1,jc,nm))*dzwr(k)
#else
              vmf(i,k,1) = vvc(i,k)*(u(i,k,jc,nm) - u(i,k+1,jc,nm))
     $                     *dzwr(k)
              vmf(i,k,2) = vvc(i,k)*(v(i,k,jc,nm) - v(i,k+1,jc,nm))
     $                     *dzwr(k)
#endif
              fwb1(i,k) = w(i,k)*(u(i,k,jc,nc) + u(i,k+1,jc,nc))
              fwb2(i,k) = w(i,k)*(v(i,k,jc,nc) + v(i,k+1,jc,nc))
1590        continue
1600      continue
c
c         set k=0 elements to reflect wind stress
c         set level "kz" for a no bottom drag condition.
c         set k=0 elements of vertical advection array to the rigid lid
c         condition (w(0) = 0). also assume w(km)=0. If "kz" < "km"
c         and there is a bottom slope, w(kz) may be non zero.
c
          do 1700 i=istart,iend
            vmf(i,0,1) = smf(i,1)
            vmf(i,0,2) = smf(i,2)
            kz         = kmu(i,j)
            vmf(i,kz,1)= bmf(i,1)
            vmf(i,kz,2)= bmf(i,2)
            fwb1(i,0)  = c0
            fwb2(i,0)  = c0
            fwb1(i,km) = c0
            fwb2(i,km) = c0
1700      continue
c
c
c-----------------------------------------------------------------------
c         construct auxiliary arrays for to prevent unnecessary
c         computation.
c-----------------------------------------------------------------------
c
#ifdef biharmonic
c
c         set up the momentum pointers (indices)
c         m1 = u component
c         m2 = v component
c
          m1 = nt + 1
          m2 = nt + 2
#endif
          do 1800 k=1,km
            do 1790 i=istart,iend+1
              aux1(i,k) = fuw(i,k)*(u(i-1,k,jc,nc) + u(i,k,jc,nc))
              aux2(i,k) = fuw(i,k)*(v(i-1,k,jc,nc) + v(i,k,jc,nc))
#ifdef biharmonic
              aux3(i,k) = dxt4r(i)*(del2(i,k,m1,jpt2)
     $                            - del2(i-1,k,m1,jpt2))
              aux4(i,k) = dxt4r(i)*(del2(i,k,m2,jpt2)
     $                            - del2(i-1,k,m2,jpt2))
#endif
#ifdef consthmix
              aux3(i,k) = dxt4r(i)*(u(i,k,jc,nm) - u(i-1,k,jc,nm))
              aux4(i,k) = dxt4r(i)*(v(i,k,jc,nm) - v(i-1,k,jc,nm))
#endif
1790        continue
1800      continue
c
c-----------------------------------------------------------------------
c         set up for the coriolis term:
c         use tau timestep for explicit trtmnt ... or
c         use tau-1 timestep for implicit treatment with remainder of
c         term to be added later
c-----------------------------------------------------------------------
c
          if (acor .eq. c0) then
            lcor = nc
          else
            lcor = nm
          endif
c
c-----------------------------------------------------------------------
c         if momentum terms are defined as arrays, then calculate
c         them here otherwise statement functions will be used
c-----------------------------------------------------------------------
c
#ifdef keepterms
          do 1880 k=1,km
            do 1870 i=istart,iend
#include "fdifm.h"
1870        continue
1880      continue
#endif
c
c-----------------------------------------------------------------------
c         construct the forcing terms for momentum
c-----------------------------------------------------------------------
c
          do 1900 k=1,km
            do 1890 i=istart,iend
              ua(i,k) = (UUx(i,k) + VUy(i,k) + WUz(i,k)
     $                 + Uxx(i,k) + Uyy(i,k) + Umet(i,k)
#ifndef nohilats
     $                 + UVtan(i,k)
#endif
#ifdef implicitvmix
     $                 + Uzz(i,k)*(c1-aidif)
#else
     $                 + Uzz(i,k)
#endif
     $                 + fV(i,k) - dpdx(i,k) + sourcu(i,k))*gm(i,k,jc)
c
              va(i,k) = (UVx(i,k) + VVy(i,k) + WVz(i,k)
     $                 + Vxx(i,k) + Vyy(i,k) + Vmet(i,k)
#ifndef nohilats
     $                 - UUtan(i,k)
#endif
#ifdef implicitvmix
     $                 + Vzz(i,k)*(c1-aidif)
#else
     $                 + Vzz(i,k)
#endif
     $                 - fU(i,k) - dpdy(i,k) + sourcv(i,k))*gm(i,k,jc)
1890        continue
1900      continue
#ifdef implicitvmix
c
c-----------------------------------------------------------------------
c         solve vertical diffusion implicitly
c-----------------------------------------------------------------------
c
c        update the velocity without implicit vertical diffusion
c
          do 1930 k=1,km
            twodt(k) = c2dtuv
            do 1920 i=istart,iend
              ua(i,k) = u(i,k,jc,nm) + c2dtuv*ua(i,k)
              va(i,k) = v(i,k,jc,nm) + c2dtuv*va(i,k)
1920        continue
1930      continue
c
c         store terms to compute implicit vertical diffusion on
c         diagnostic time steps
c
          if (diagts .and. eots) then
            do 1050 k=1,km
              do 1040 i=istart,iend
                zzi(i,k,1) = ua(i,k)
                zzi(i,k,2) = va(i,k)
1040          continue
1050        continue
          endif
c
c         add in the implicit vertical diffusion
c
#ifdef tcvmix
          call invtri (ua, smf(1,1), bmf(1,1), vvca, twodt, kmu
     $,                gm(1,1,jc), istart, iend, j)
          call invtri (va, smf(1,2), bmf(1,2), vvca, twodt, kmu
     $,                gm(1,1,jc), istart, iend, j)
#else
          call invtri (ua, smf(1,1), bmf(1,1), vvc, twodt, kmu
     $,                gm(1,1,jc), istart, iend, j)
          call invtri (va, smf(1,2), bmf(1,2), vvc, twodt, kmu
     $,                gm(1,1,jc), istart, iend, j)
#endif
c
c         compute residual implicit vertical diffusion
c
          r2dtuv = c1/c2dtuv
          if (diagts .and. eots) then
            do 1070 k=1,km
              do 1060 i=istart,iend
                zzi(i,k,1) = r2dtuv*(ua(i,k) - zzi(i,k,1))
                zzi(i,k,2) = r2dtuv*(va(i,k) - zzi(i,k,2))
1060          continue
1070        continue
          endif
c
c         convert back to time change of velocity
c
          do 1990 k=1,km
            do 1980 i=istart,iend
              ua(i,k) = r2dtuv*(ua(i,k) - u(i,k,jc,nm))
              va(i,k) = r2dtuv*(va(i,k) - v(i,k,jc,nm))
1980        continue
1990      continue
#endif
c
c-----------------------------------------------------------------------
c         form time change of vertically averaged forcing
c-----------------------------------------------------------------------
c
c         integrate time change vertically
c
          do 2000 i=istart,iend
            zu(i,j) = c0
            zv(i,j) = c0
2000      continue
          do 2100 k=1,km
            fx = c2dtsf*dzt(k)
            do 2090 i=istart,iend
              zu(i,j) = zu(i,j) + ua(i,k)*fx
              zv(i,j) = zv(i,j) + va(i,k)*fx
2090        continue
2100      continue
#ifdef symmetry
c
c         set symmetry row to zero
c
          if (j .eq. jmtm1) then
            do 2200 i=istart,iend
              zv(i,j) = c0
2200        continue
          endif
#endif
c
c         form vertical average
c
          do 2300 i=istart,iend
            zu(i,j) = zu(i,j)*hr(i,j)
            zv(i,j) = zv(i,j)*hr(i,j)
2300      continue
c
c-----------------------------------------------------------------------
c         do analysis of internal mode forcing on diagnostic timesteps
c         also, form vert ave. for use later in ext. mode analysis
c         along with term balances
c-----------------------------------------------------------------------
c
          if (diagts .and. eots) then
c
            fx = csu(j)*dyu(j)
#ifdef symmetry
c
c           weight symmetry row by one half
c
            if (j .eq. jmtm1) fx = fx*p5
#endif
            do 2400 k=1,km
c
c             compute ke change due to pressure term globally
c             also integrate pressure term over the regional volume
c
              n0 = nhreg*(mskvr(k)-1)
              do 2320 i=istart,iend
                ueng(i)   = -gm(i,k,jc)*dpdx(i,k)
                veng(i)   = -gm(i,k,jc)*dpdy(i,k)
                boxvol      = fx*dxu(i)*dzt(k)
                engint(k,6) = engint(k,6) + (uclin(i,k,jpt1)*ueng(i) +
     $                        vclin(i,k,jpt1)*veng(i))*boxvol
                zuneng(i,6) = zuneng(i,6) + ueng(i)*dzt(k)*hr(i,j)
                zvneng(i,6) = zvneng(i,6) + veng(i)*dzt(k)*hr(i,j)
                n           = n0 + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  termbm(k,2,1,n) = termbm(k,2,1,n) + ueng(i)*boxvol
                  termbm(k,2,2,n) = termbm(k,2,2,n) + veng(i)*boxvol
                endif
2320          continue
c
c             compute ke change due to zonal advection of momentum
c             globally. also integrate zonal advection term over the
c             regional volumes
c
              do 2330 i=istart,iend
                ueng(i)     = gm(i,k,jc)*UUx(i,k)
                veng(i)     = gm(i,k,jc)*UVx(i,k)
                boxvol      = fx*dxu(i)*dzt(k)
                engint(k,2) = engint(k,2) + (uclin(i,k,jpt1)*ueng(i)
     $                        + vclin(i,k,jpt1)*veng(i))*boxvol
                zuneng(i,2) = zuneng(i,2) + ueng(i)*dzt(k)*hr(i,j)
                zvneng(i,2) = zvneng(i,2) + veng(i)*dzt(k)*hr(i,j)
                n           = n0 + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  termbm(k,3,1,n) = termbm(k,3,1,n) + ueng(i)*boxvol
                  termbm(k,3,2,n) = termbm(k,3,2,n) + veng(i)*boxvol
#ifndef nohilats
                  termbm(k,13,1,n) = termbm(k,13,1,n)
     $                             + UVtan(i,k)*boxvol
                  termbm(k,13,2,n) = termbm(k,13,2,n)
     $                             - UUtan(i,k)*boxvol
#endif
                endif
2330          continue
c
c             compute ke change due to meridional advection of momentum
c             globally. also integrate meridional advection term over
c             the regional volumes
c
              do 2340 i=istart,iend
                ueng(i)     = gm(i,k,jc)*VUy(i,k)
                veng(i)     = gm(i,k,jc)*VVy(i,k)
                boxvol      = fx*dxu(i)*dzt(k)
                engint(k,2) = engint(k,2) + (uclin(i,k,jpt1)*ueng(i)
     $                        + vclin(i,k,jpt1)*veng(i))*boxvol
                zuneng(i,2) = zuneng(i,2) + ueng(i)*dzt(k)*hr(i,j)
                zvneng(i,2) = zvneng(i,2) + veng(i)*dzt(k)*hr(i,j)
                n           = n0 + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  termbm(k,4,1,n) = termbm(k,4,1,n) + ueng(i)*boxvol
                  termbm(k,4,2,n) = termbm(k,4,2,n) + veng(i)*boxvol
                endif
2340          continue
c
c             compute ke change due to vertical advection of momentum
c             globally. also integrate vertical advection term over the
c             regional volumes
c
              do 2350 i=istart,iend
                ueng(i)     = gm(i,k,jc)*WUz(i,k)
                veng(i)     = gm(i,k,jc)*WVz(i,k)
                boxvol      = fx*dxu(i)*dzt(k)
                engint(k,3) = engint(k,3) + (uclin(i,k,jpt1)*ueng(i)
     $                        + vclin(i,k,jpt1)*veng(i))*boxvol
                zuneng(i,3) = zuneng(i,3) + ueng(i)*dzt(k)*hr(i,j)
                zvneng(i,3) = zvneng(i,3) + veng(i)*dzt(k)*hr(i,j)
                n           = n0 + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  termbm(k,5,1,n) = termbm(k,5,1,n) + ueng(i)*boxvol
                  termbm(k,5,2,n) = termbm(k,5,2,n) + veng(i)*boxvol
                endif
2350          continue
c
c             compute ke change due to zonal diffusion of momentum
c             globally. also integrate zonal diffusion term over the
c             regional volumes
c
              do 2360 i=istart,iend
                ueng(i)     = gm(i,k,jc)*Uxx(i,k)
                veng(i)     = gm(i,k,jc)*Vxx(i,k)
                boxvol      = fx*dxu(i)*dzt(k)
                engint(k,4) = engint(k,4) + (uclin(i,k,jpt1)*ueng(i)
     $                        + vclin(i,k,jpt1)*veng(i))*boxvol
                zuneng(i,4) = zuneng(i,4) + ueng(i)*dzt(k)*hr(i,j)
                zvneng(i,4) = zvneng(i,4) + veng(i)*dzt(k)*hr(i,j)
                n           = n0 + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  termbm(k,6,1,n) = termbm(k,6,1,n) + ueng(i)*boxvol
                  termbm(k,6,2,n) = termbm(k,6,2,n) + veng(i)*boxvol
                endif
2360          continue
c
c             compute ke change due to meridional diffusion of momentum
c             lobally. also integrate meridional diffusion term over
c             the regional volumes
c
              do 2370 i=istart,iend
                ueng(i)     = gm(i,k,jc)*Uyy(i,k)
                veng(i)     = gm(i,k,jc)*Vyy(i,k)
                boxvol      = fx*dxu(i)*dzt(k)
                engint(k,4) = engint(k,4) + (uclin(i,k,jpt1)*ueng(i)
     $                        + vclin(i,k,jpt1)*veng(i))*boxvol
                zuneng(i,4) = zuneng(i,4) + ueng(i)*dzt(k)*hr(i,j)
                zvneng(i,4) = zvneng(i,4) + veng(i)*dzt(k)*hr(i,j)
                n           = n0 + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  termbm(k,7,1,n) = termbm(k,7,1,n) + ueng(i)*boxvol
                  termbm(k,7,2,n) = termbm(k,7,2,n) + veng(i)*boxvol
                endif
2370          continue
c
c             compute ke change due to vertical diffusion of momentum
c             globally. also integrate vertical diffusion term over the
c             regional volumes
c
              do 2380 i=istart,iend
#ifdef implicitvmix
                ueng(i) = gm(i,k,jc)*(Uzz(i,k)*(c1-aidif) + zzi(i,k,1))
                veng(i) = gm(i,k,jc)*(Vzz(i,k)*(c1-aidif) + zzi(i,k,2))
#else
                ueng(i) = gm(i,k,jc)*Uzz(i,k)
                veng(i) = gm(i,k,jc)*Vzz(i,k)
#endif
                boxvol  = fx*dxu(i)*dzt(k)
                engint(k,5) = engint(k,5) + (uclin(i,k,jpt1)*ueng(i)
     $                        + vclin(i,k,jpt1)*veng(i))*boxvol
                zuneng(i,5) = zuneng(i,5) + ueng(i)*dzt(k)*hr(i,j)
                zvneng(i,5) = zvneng(i,5) + veng(i)*dzt(k)*hr(i,j)
                n           = n0 + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  termbm(k,8,1,n) = termbm(k,8,1,n) + ueng(i)*boxvol
                  termbm(k,8,2,n) = termbm(k,8,2,n) + veng(i)*boxvol
                endif
2380          continue
c
c             compute ke change due to metric term globally
c             also integrate metric term, coriolis term, source term
c             & velocity over the regional volumes
c
              do 2390 i=istart,iend
                ueng(i)     = gm(i,k,jc)*Umet(i,k)
                veng(i)     = gm(i,k,jc)*Vmet(i,k)
                boxvol      = fx*dxu(i)*dzt(k)
                engint(k,4) = engint(k,4) + (uclin(i,k,jpt1)*ueng(i)
     $                        + vclin(i,k,jpt1)*veng(i))*boxvol
                zuneng(i,4) = zuneng(i,4) + ueng(i)*dzt(k)*hr(i,j)
                zvneng(i,4) = zvneng(i,4) + veng(i)*dzt(k)*hr(i,j)
                n           = n0 + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  termbm(k,9,1,n) = termbm(k,9,1,n) + ueng(i)*boxvol
                  termbm(k,9,2,n) = termbm(k,9,2,n) + veng(i)*boxvol
                  termbm(k,10,1,n) = termbm(k,10,1,n) + fV(i,k)*boxvol
                  termbm(k,10,2,n) = termbm(k,10,2,n) - fU(i,k)*boxvol
                  termbm(k,11,1,n) = termbm(k,11,1,n) + sourcu(i,k)
     $                                                *boxvol*gm(i,k,jc)
                  termbm(k,11,2,n) = termbm(k,11,2,n) - sourcv(i,k)
     $                                                *boxvol*gm(i,k,jc)
                  avwv(1,n)        = avwv(1,n) + u(i,k,jc,nc)*boxvol
                  avwv(2,n)        = avwv(2,n) + v(i,k,jc,nc)*boxvol
                  avwv(3,n)        = avwv(3,n) + p5*(w(i,k)+w(i,k-1))
     $                                *boxvol*gm(i,k,jc)
                endif
2390          continue
2400        continue
c
c           compute ke change due to wind stress globally
c
            do 2500 i=istart,iend
              ueng(i)     = gm(i,1,jc)*smf(i,1)
              veng(i)     = gm(i,1,jc)*smf(i,2)
              engint(1,7) = engint(1,7) + (uclin(i,1,jpt1)*ueng(i)
     $                      + vclin(i,1,jpt1)*veng(i))*fx*dxu(i)
              zuneng(i,7) = zuneng(i,7) + ueng(i)*hr(i,j)
              zvneng(i,7) = zvneng(i,7) + veng(i)*hr(i,j)
              dtaux       = fx*dxu(i)*ueng(i)
              dtauy       = fx*dxu(i)*veng(i)
              smflx(1,0) = smflx(1,0) + dtaux
              smflx(2,0) = smflx(2,0) + dtauy
              n         = mskhr(i,j)
              if (n .gt. 0) then
                smflx(1,n) = smflx(1,n) + dtaux
                smflx(2,n) = smflx(2,n) + dtauy
              endif
2500        continue
c
c           compute ke change due to bottom drag globally
c
            do 2600 i=istart,iend
              kz = kmu(i,j)
              if (kz .ne. 0) then
                ueng(i)   = -gm(i,1,jc)*bmf(i,1)
                veng(i)   = -gm(i,1,jc)*bmf(i,2)
                engint(kz,8) = engint(kz,8)+(uclin(i,kz,jpt1)*ueng(i)
     $                     + vclin(i,kz,jpt1)*veng(i))*fx*dxu(i)
                zuneng(i,8)  = zuneng(i,8) + ueng(i)*hr(i,j)
                zvneng(i,8)  = zvneng(i,8) + veng(i)*hr(i,j)
              endif
2600        continue
          endif
c
c-----------------------------------------------------------------------
c         compute new velocities (with incorrect vertical means)
c         also, add in remainder of coriolis term if treated implicitly
c-----------------------------------------------------------------------
c
          if (acor .eq. c0) then
            do 2800 k=1,km
              do 2790 i=istart,iend
                ua(i,k) = u(i,k,jc,nm) + c2dtuv*ua(i,k)
                va(i,k) = v(i,k,jc,nm) + c2dtuv*va(i,k)
2790          continue
2800        continue
          else
            fx    = c2dtuv*acor*c2*omega*sine(j)
            detmr = c1/(c1 + fx*fx)
            do 2900 k=1,km
              do 2890 i=istart,iend
                t1 = (ua(i,k)+fx*va(i,k))*detmr
                t2 = (va(i,k)-fx*ua(i,k))*detmr
                ua(i,k) = u(i,k,jc,nm) + c2dtuv*t1
                va(i,k) = v(i,k,jc,nm) + c2dtuv*t2
2890          continue
2900        continue
          endif
c
c-----------------------------------------------------------------------
c         subtract incorrect vertical means to get internal modes.
c         these means are due to ignoring horizontal gradients of the
c         surface pressure
c-----------------------------------------------------------------------
c
          do 3000 i=istart,iend
            ubar(i) = c0
            vbar(i) = c0
3000      continue
          do 3100 k=1,km
            do 3090 i=istart,iend
              ubar(i) = ubar(i) + ua(i,k)*dzt(k)
              vbar(i) = vbar(i) + va(i,k)*dzt(k)
3090        continue
3100      continue
          do 3200 i=istart,iend
            ubar(i) = ubar(i)*hr(i,j)
            vbar(i) = vbar(i)*hr(i,j)
3200      continue
          do 3300 k=1,km
            do 3290 i=istart,iend
              ua(i,k) = ua(i,k) - gm(i,k,jc)*ubar(i)
              va(i,k) = va(i,k) - gm(i,k,jc)*vbar(i)
3290        continue
3300      continue
c
c-----------------------------------------------------------------------
c         compute total change in k.e. for the internal mode on diag-
c         nostic timesteps. also construct d/dt of momentum and add the
c         implicit part of the coriolis term into the momentum term
c         balance. the external mode parts of both will be added after
c         the calculation for the external mode
c-----------------------------------------------------------------------
c
          if (diagts .and. eots) then
            do 3400 k=1,km
              fx = csu(j)*dyu(j)*dzt(k)/c2dtuv
#ifdef symmetry
              if (j .eq. jmtm1) fx = fx*p5
#endif
              do 3380 i=istart,iend
                tempik(i,k,1) =
     $              (uclin(i,k,jpt1)*(ua(i,k) - u(i,k,jc,nm))
     $             + vclin(i,k,jpt1)*(va(i,k) - v(i,k,jc,nm)))*fx*dxu(i)
3380          continue
              do 3390 i=istart,iend
                engint(k,1) = engint(k,1) + tempik(i,k,1)
3390          continue
3400        continue
c
            fx   = csu(j)*dyu(j)/c2dtuv
            do 3430 k=1,km
              do 3420 i=istart,iend
                n = nhreg*(mskvr(k)-1) + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  boxfac      = gm(i,k,jc)*fx*dxu(i)*dzt(k)
                  termbm(k,1,1,n) = termbm(k,1,1,n) +
     $                            (ua(i,k) - u(i,k,jc,nm))*boxfac
                  termbm(k,1,2,n) = termbm(k,1,2,n) +
     $                            (va(i,k) - v(i,k,jc,nm))*boxfac
                endif
3420          continue
3430        continue
c
            if (acor .ne. c0) then
              fx   = acor*csu(j)*dyu(j)*fcor(j)
              do 3450 k=1,km
                do 3440 i=istart,iend
                  n = nhreg*(mskvr(k)-1) + mskhr(i,j)
                  if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                    boxfac      = gm(i,k,jc)*fx*dxu(i)*dzt(k)
                    termbm(k,10,1,n) = termbm(k,10,1,n) +
     $                               (va(i,k) - v(i,k,jc,nm))*boxfac
                    termbm(k,10,2,n) = termbm(k,10,2,n) -
     $                               (ua(i,k) - u(i,k,jc,nm))*boxfac
                  endif
3440            continue
3450          continue
            endif
          endif
#ifdef skipland
        endif
3500  continue
#endif
c
c-----------------------------------------------------------------------
c     do analysis of external mode forcing on diagnostic timesteps
c-----------------------------------------------------------------------
c
      if (diagts .and. eots) then
#ifdef cyclic
        do 3600 ll=2,8
          zuneng(1,ll) = zuneng(imum1,ll)
          zvneng(1,ll) = zvneng(imum1,ll)
3600    continue
#endif
c
        do 3700 ll=2,8
#ifdef symmetry
          if (j .eq. jmtm1) then
            do 3670 i=1,imt
              zvneng(i,ll) = c0
3670        continue
          endif
#endif
          do 3680 i=2,imtm1
            tempik(i,1,1) =
     $            -p(i,j,1)*(((zvneng(i,ll)-zvneng(i-1,ll))*dyu(j)
     $            +(zvseng(i,ll)-zvseng(i-1,ll))*dyu(j-1))
     $            *dxt2r(i)*dytr(j)
     $           -((zuneng(i,ll)*dxu(i)+zuneng(i-1,ll)*dxu(i-1))*csu(j)
     $           -(zuseng(i,ll)*dxu(i)+zuseng(i-1,ll)*dxu(i-1))*csu(j-1)
     $            )*dyt2r(j)*dxtr(i))*dxt(i)*dyt(j)
3680      continue
          do 3690 i=2,imtm1
            engext(ll) = engext(ll) + tempik(i,1,1)
3690      continue
3700    continue
      endif
c
#if defined fourfil || defined firfil
c-----------------------------------------------------------------------
c     fourier filter u and v at high latitudes
c-----------------------------------------------------------------------
c
#ifdef cyclic
      do 3780 k=1,km
        ua(1,k)   = ua(imum1,k)
        va(1,k)   = va(imum1,k)
        ua(imu,k) = ua(2,k)
        va(imu,k) = va(2,k)
3780  continue
#endif
c
      call filuv (j)
c
#endif
c-----------------------------------------------------------------------
c     transfer quantities computed to the north of the present row
c     to be defined at the south in the computation of the next row
c-----------------------------------------------------------------------
c
      if (j .ne. jerow) then
        fx = csu(j)*dyu(j)*csur(j+1)*dyur(j+1)
        do 3800 k=1,km
          do 3790 i=1,imt
            fvsu(i,k) = fvn(i,k)*fx
3790      continue
3800    continue
      endif
c
      if (diagts .and. eots) then
        do 3900 ll=2,8
          do 3890 i=1,imt
            zuseng(i,ll) = zuneng(i,ll)
            zvseng(i,ll) = zvneng(i,ll)
3890      continue
3900    continue
      endif
c
#ifdef cyclic
c
c     set cyclic boundary conditions
c
      zu(imu,j) = zu(2,j)
      zv(imu,j) = zv(2,j)
      zu(1,j)   = zu(imum1,j)
      zv(1,j)   = zv(imum1,j)
c
      do 4000 k=1,km
        ua(1,k)   = ua(imum1,k)
        va(1,k)   = va(imum1,k)
        ua(imu,k) = ua(2,k)
        va(imu,k) = va(2,k)
4000  continue
c
#endif
#ifdef symmetry
c
c     set meridional component of internal mode to zero on symmetry row
c
      if (j .eq. jmtm1) then
        do 4100 k=1,km
          do 4090 i=1,imt
            va(i,k) = c0
4090      continue
4100    continue
      endif
c
#endif
c
      return
      end
#DECK cnvmix.F
      subroutine cnvmix (j)
#ifdef constvmix
#ifdef multitasking
cfpp$ noconcur r
#endif
c=====================================================================
c
c     set up coefficients for constant vertical diffusion
c
c=====================================================================
c
#include "param.h"
#include "cvmix.h"
#ifdef implicitvmix
# include "levind.h"
# include "index.h"
# include "slabs.h"
# include "temp.h"
#endif
c
      do 100 k=1,km
        do 90 i=1,imt
          vdc(i,k) = fkph
          vvc(i,k) = fkpm
90      continue
100   continue
c
#ifdef implicitvmix
c
c         ks=1: compare lev. 1 to 2; 3 to 4; etc.
c         ks=2: compare lev. 2 to 3; 4 to 5; etc.
c
          do 200 ks=1,2
c
c           find density for entire slab for stability determination
c
            call statec (t(1,1,jc,nm,1), t(1,1,jc,nm,2), tempik(1,1,1)
     $,                 ks)
# ifdef skipland
            do 190 lstrip=1,lseg
              istart = ist(j,lstrip)
              iend   = iet(j,lstrip)
              if (istart .ne. 0) then
# endif
c
c               set "heavy water" in land to insure stability there
c
                dense = 1.e15
                do 150 i=istart,iend
                  k = kmt(i,j) + 1
                  if (k .le. km) then
                    tempik(i,k,1) = dense
                  endif
150            continue
c
c               if unstable, set mixing to the limits
c
                do 180 m=1,nt
                  do 170 k=ks,kmm1,2
                    do 160 i=istart,iend
                      if (tempik(i,k,1) .gt. tempik(i,k+1,1)) then
                        vdc(i,k) = vdclim
                        vvc(i,k) = vvclim
                      endif
160                continue
170              continue
180            continue
# ifdef skipland
              endif
190        continue
# endif
200       continue
#endif
#endif
      return
      end
#DECK congr5.F
      subroutine congr5
#ifdef congrad5pt
c
c=======================================================================
c
c     congr5 solves for the time derivitive of the mass transport
c     stream function using a preconditioned conjugate gradient
c     algorithm with 5 point numerics.
c
c     note: abrupt topographic changes may lead to non convergence. In
c     practice this may only be a problem for coarse resolution
c     model with non smooth topography.
c
c     this algorithm is described in gfdl tech report by j. derber, 1987
c     (see also: gill, p.e., w. murray & m.h. wright, 1981,
c      practical optimizations. academic press)
c
c=======================================================================
c
#include "param.h"
#include "crelax.h"
#include "ctmngr.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "iounit.h"
#include "levind.h"
#include "scalar.h"
#include "switch.h"
#include "temp.h"
c
c=======================================================================
c     begin introductory section to prepare for the relaxation
c=======================================================================
c
c-----------------------------------------------------------------------
c     initiate readin of solution of 2 timesteps before
c     for the purpose of computing an initial guess for the present
c     solution. (input unit alternates on time steps between 4 & 5)
c-----------------------------------------------------------------------
c
      luptdb = 5 - mod(itt,2)
      luptd  = 4 + mod(itt,2)
      call ofind (kflds, nwds, (luptdb-1)*nwds+1)
      call ofind (kflds, nwds, (luptd-1)*nwds+1)
c
      if (first .or. mixts .or. mod(itt,nmix) .eq. 2) then
c
c-----------------------------------------------------------------------
c       initialize the work area on the first entry. also during
c       a mixing time step and the following time step
c-----------------------------------------------------------------------
c
        do 100 j=1,jmt
          do 90 i=1,imt
            cfn(i,j) = c0
            cfs(i,j) = c0
            cfe(i,j) = c0
            cfw(i,j) = c0
            cpf(i,j) = c0
#ifdef islands
            cof(i,j) = c1
#endif
90        continue
100     continue
c
c-----------------------------------------------------------------------
c       generate arrays of coefficients for relaxation
c-----------------------------------------------------------------------
c
c       compute coefficients for the five point del square operator
c       coefficients are zero in land & on perimeter of land masses
c
        do 300 j=3,jmtm1
          do 290 l=1,lseg
            if (isz(j,l) .ne. 0) then
              fxa=c2*cstr(j)*cstr(j)
              fxb=c2*csu(j  )*cstr(j)*dytr(j)*dyur(j  )
              fxc=c2*csu(j-1)*cstr(j)*dytr(j)*dyur(j-1)
              do 260 i=isz(j,l),iez(j,l)
                cfn(i,j)=fxb/(h(i-1,j)+h(i,j))
                cfs(i,j)=fxc/(h(i-1,j-1)+h(i,j-1))
                cfe(i,j)=fxa*dxur(i)*dxtr(i)/(h(i,j)+h(i,j-1))
                cfw(i,j)=fxa*dxur(i-1)*dxtr(i)/(h(i-1,j)+h(i-1,j-1))
                cpf(i,j)=c1/(cfn(i,j)+cfs(i,j)+cfe(i,j)+cfw(i,j))
260           continue
c
c             augment coefficients for implicit coriolis treatment
c
              if (acor .ne. c0) then
                fx = -c2dtsf*acor*cstr(j)*dytr(j)*omega
                do 270 i=isz(j,l),iez(j,l)
                  cfn(i,j) = cfn(i,j)+(hr(i,j  )-hr(i-1,j  ))*sine(j  )
     $                          *fx*dxtr(i)
                  cfs(i,j) = cfs(i,j)-(hr(i,j-1)-hr(i-1,j-1))*sine(j-1)
     $                          *fx*dxtr(i)
                  cfe(i,j) = cfe(i,j)-(hr(i  ,j)*sine(j)-hr(i  ,j-1)
     $                          *sine(j-1))*fx*dxtr(i)
                  cfw(i,j) = cfw(i,j)+(hr(i-1,j)*sine(j)-hr(i-1,j-1)
     $                          *sine(j-1))*fx*dxtr(i)
270             continue
              endif
c
c             normalize coefficients
c
              do 280 i=isz(j,l),iez(j,l)
                cfn(i,j) = cfn(i,j)*cpf(i,j)
                cfs(i,j) = cfs(i,j)*cpf(i,j)
                cfe(i,j) = cfe(i,j)*cpf(i,j)
                cfw(i,j) = cfw(i,j)*cpf(i,j)
280           continue
            endif
290       continue
300     continue
#ifdef islands
c
c       modify coefficients to include island perimeter points
c
        do 400 isle=1,nisle
          cofis(isle) = c0
          do 390 n=1,nippts(isle)
            i = iperm(iofs(isle)+n)
            j = jperm(iofs(isle)+n)
            fxa = c2*cstr(j)*cstr(j)
            fxb = c2*csu(j  )*dyur(j  )*dytr(j)*cstr(j)
            fxc = c2*csu(j-1)*dyur(j-1)*dytr(j)*cstr(j)
            fxd = -c2dtsf*acor*cstr(j)*dytr(j)*omega
            if(hr(i-1,j  ) .ne. c0 .or. hr(i  ,j  ) .ne. c0)
     $        cfn(i,j) = fxb/(h(i-1,j)+h(i,j))
            if(hr(i-1,j-1) .ne. c0 .or. hr(i  ,j-1) .ne. c0)
     $        cfs(i,j) = fxc/(h(i-1,j-1)+h(i,j-1))
            if(hr(i  ,j  ) .ne. c0 .or. hr(i  ,j-1) .ne. c0)
     $        cfe(i,j) = fxa*dxtr(i)*dxur(i)/(h(i,j)+h(i,j-1))
            if(hr(i-1,j  ) .ne. c0 .or. hr(i-1,j-1) .ne. c0)
     $        cfw(i,j) = fxa*dxtr(i)*dxur(i-1)/(h(i-1,j)+h(i-1,j-1))
c
            cpf(i,j) = c1/(cfn(i,j)+cfs(i,j)+cfe(i,j)+cfw(i,j))
c
            if(hr(i-1,j  ) .ne. c0 .or. hr(i  ,j  ) .ne. c0)
     $        cfn(i,j) = cfn(i,j)
     $        +fxd*dxtr(i)*(hr(i,j)-hr(i-1,j))*sine(j)
            if(hr(i-1,j-1) .ne. c0 .or. hr(i  ,j-1) .ne. c0)
     $        cfs(i,j) = cfs(i,j)
     $        -fxd*dxtr(i)*(hr(i,j-1)-hr(i-1,j-1))*sine(j-1)
            if(hr(i  ,j  ) .ne. c0 .or. hr(i  ,j-1) .ne. c0)
     $        cfe(i,j) = cfe(i,j)
     $        -fxd*dxtr(i)*(hr(i,j)*sine(j)-hr(i,j-1)*sine(j-1))
            if(hr(i-1,j  ) .ne. c0 .or. hr(i-1,j-1) .ne. c0)
     $        cfw(i,j) = cfw(i,j)
     $        +fxd*dxtr(i)*(hr(i-1,j)*sine(j)-hr(i-1,j-1)*sine(j-1))
            cfn(i,j) = cfn(i,j)*cpf(i,j)
            cfs(i,j) = cfs(i,j)*cpf(i,j)
            cfe(i,j) = cfe(i,j)*cpf(i,j)
            cfw(i,j) = cfw(i,j)*cpf(i,j)
            cof(i,j) = cst(j)*dxt(i)*dyt(j)/cpf(i,j)
            cofis(isle) = cofis(isle)+cof(i,j)
390       continue
          cofis(isle) = c1/cofis(isle)
400     continue
c
        do 700 isle=1,nisle
          do 690 n=1,nippts(isle)
            i = iperm(iofs(isle)+n)
            j = jperm(iofs(isle)+n)
            cof(i,j) = cof(i,j)*cofis(isle)
690       continue
700     continue
# ifdef cyclic
c
        do 800 j=1,jmt
          cof(1,j)   = c0
          cof(imt,j) = c0
800     continue
# endif
#endif
      endif
c
c-----------------------------------------------------------------------
c     normalize vorticity "ztd"
c-----------------------------------------------------------------------
c
      do 900 j=1,jmt
        do 890 i=1,imt
          ztd(i,j) = ztd(i,j)*cpf(i,j)
890     continue
900   continue
c
c-----------------------------------------------------------------------
c     complete readin of relaxation solution of 2 timesteps prior and
c     of previous timestep.
c-----------------------------------------------------------------------
c
      call oget (kflds, nwds, (luptdb-1)*nwds+1, res)
      call oget (kflds, nwds, (luptd-1)*nwds+1, ptd)
c
c-----------------------------------------------------------------------
c     erstimate a first guess by extrapolating the two
c     previous solutions forward in time.
c-----------------------------------------------------------------------
c
      fxa=c1
      if (mixts .or. mxpas2) fxa=p5
      do 1000 j=1,jmt
        do 990 i=1,imt
          ptd(i,j) = fxa*(c2*ptd(i,j)-res(i,j))
990     continue
1000  continue
#ifdef cyclic
c
c     set cyclic bc
c
      do 1110 j=2,jmtm1
        ptd(1,j)   = ptd(imtm1,j)
        ptd(imt,j) = ptd(2,j)
1110  continue
#endif
c
c-----------------------------------------------------------------------
c     compute convergence criterion & find initial residuals
c-----------------------------------------------------------------------
c
      crtp = crit*fxa
      do 1200 j=1,jmt
        do 1190 i=1,imt
          res(i,j) = c0
1190    continue
1200  continue
c
      do 1300 j=2,jmtm1
        do 1290 i=2,imtm1
          res(i,j) = cfn(i,j)*ptd(i,j+1) +
     $               cfs(i,j)*ptd(i,j-1) +
     $               cfe(i,j)*ptd(i+1,j) +
     $               cfw(i,j)*ptd(i-1,j) -
     $               ptd(i,j) - ztd(i,j)
#ifdef islands
          res(i,j) = res(i,j)*cof(i,j)
#endif
1290    continue
1300  continue
#ifdef islands
c
c     find initial island residual using a line integral.
c      update res(i,j) on perimeter & interior of island
c
      do 1400 isle=1,nisle
        resis = c0
        do 1360 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          resis = resis + res(i,j)
1360    continue
        do 1370 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          res(i,j) = resis
1370    continue
1400  continue
#endif
#ifdef cyclic
c
c     set cyclic bc
c
      do 1500 j=2,jmtm1
        res(1,j)   = res(imtm1,j)
        res(imt,j) = res(2,j)
1500  continue
#endif
#ifdef symmetry
c
c     set symmetry bc
c
      do 1600 i=1,imt
        res(i,jmt) = - res(i,jmtm1)
1600  continue
#endif
c
c     initialize beta & gdir
c
      beta = c0
      do 1700 j=1,jmt
        do 1690 i=1,imt
          gdir(i,j) = c0
1690    continue
1700  continue
c
c-----------------------------------------------------------------------
c     begin iteration loop using conjugate gradient technique
c-----------------------------------------------------------------------
c
      mscan=0
1701  continue
      mscan = mscan + 1
c
c-----------------------------------------------------------------------
c     compute field of residuals
c-----------------------------------------------------------------------
c
      do 1800 j=2,jmtm1
        do 1790 i=2,imtm1
          gdir(i,j) = cfn(i,j)*res(i,j+1) +
     $                cfs(i,j)*res(i,j-1) +
     $                cfe(i,j)*res(i+1,j) +
     $                cfw(i,j)*res(i-1,j) -
     $                res(i,j)
#ifdef islands
          gdir(i,j) = gdir(i,j)*cof(i,j)
#endif
1790    continue
1800  continue
#ifdef islands
c
c     find island residuals using a line integral.
c     update gdir on perimeter & interior of island
c
      do 1900 isle=1,nisle
        resis = c0
        do 1860 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          resis = resis + gdir(i,j)
1860    continue
        do 1870 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          gdir(i,j) = resis
1870    continue
1900  continue
#endif
#ifdef cyclic
c
c     set cyclic condition
c
      do 2000 j=2,jmtm1
        gdir(1,j)   = gdir(imtm1,j)
        gdir(imt,j) = gdir(2,j)
2000  continue
#endif
c
      do 2100 j=2,jmtm1
        asum(j) = c0
        do 2090 i=2,imtm1
          asum(j) = asum(j) + gdir(i,j)*res(i,j)
2090    continue
2100  continue
c
      apr4 = c0
      do 2200 j=2,jmtm1
        apr4 = apr4 + asum(j)
2200  continue
c
      if (mscan .gt. 1) then
        if (oapr .ne. c0) then
          beta = apr4/oapr
        else
          beta = c0
        endif
      endif
c
c-----------------------------------------------------------------------
c     calculate new values for hdir and fdir
c-----------------------------------------------------------------------
c
      do 2300 j=2,jmtm1
        do 2290 i=1,imt
          hdir(i,j)   = res(i,j)  + beta*hdir(i,j)
          fdir(i,j)   = gdir(i,j) + beta*fdir(i,j)
2290    continue
2300  continue
c
      oapr = apr4
      apr2 = c0
      do 2400 j=2,jmtm1
        asum(j) = c0
        do 2390 i=2,imtm1
          asum(j) = asum(j) + fdir(i,j)*fdir(i,j)
2390    continue
2400  continue
c
      do 2500 j=2,jmtm1
        apr2 = apr2 + asum(j)
2500  continue
c
c-----------------------------------------------------------------------
c     calculate stepsize (asor) & make a correction to ptd res
c-----------------------------------------------------------------------
c
      if (apr2 .ne. c0) then
        asor = - apr4/apr2
      else
        asor = c0
      endif
c
      do 2600 j=2,jmtm1
        do 2590 i=1,imt
          ptd(i,j) = ptd(i,j) + asor*hdir(i,j)
          res(i,j) = res(i,j) + asor*fdir(i,j)
2590    continue
2600  continue
#ifdef cyclic
c
c     set cyclic condition
c
      do 2700 j=2,jmtm1
        res(1,j)   = res(imtm1,j)
        res(imt,j) = res(2,j)
2700  continue
#endif
c
c-----------------------------------------------------------------------
c     find the maximum absolute residual to determine convergence
c-----------------------------------------------------------------------
c
      resmax = c0
      do 2800 j=3,jscan
        do 2790 i=2,imtm1
          resmax = max(abs(res(i,j)), resmax)
2790    continue
2800  continue
#ifdef symmetry
c
c     set symmetry on northern wall
c
      do 2900 i=1,imt
        res(i,jmt) = - res(i,jmtm1)
2900  continue
#endif
c
c-----------------------------------------------------------------------
c      take another iteration unless the max residual < crtp or
c      the number of scans reaches mxscan
c-----------------------------------------------------------------------
c
      if (resmax .ge. crtp .and. mscan .lt. mxscan) go to 1701
c
c=======================================================================
c     end of the iteration loop
c=======================================================================
c
#ifdef symmetry
c
c     set symmetry on northern wall
c
      do 3000 i=1,imt
        ptd(i,jmt) = - ptd(i,jmtm1)
3000  continue
#endif
c-----------------------------------------------------------------------
c     update the stream function based upon the relaxation solution
c-----------------------------------------------------------------------
c
      if (.not. mxpas2) then
        do 3100 j=1,jmt
          do 3090 i=1,imt
            res(i,j) = p(i,j,2) + ptd(i,j)
            p(i,j,2)  = p(i,j,1)
            p(i,j,1)  = res(i,j)
3090      continue
3100    continue
      else
        do 3200 j=1,jmt
          do 3190 i=1,imt
            p(i,j,1) = p(i,j,2) + ptd(i,j)
3190      continue
3200    continue
      endif
c
c-----------------------------------------------------------------------
c     save ptd to compute 1st guess for relaxation next timestep
c     (..note.. on 1st pass of euler backward timestep, bypass this
c            save, since it will be done on the 2nd pass)
c     (..note.. on a mixing timestep, alter ptd to be consistent with
c            normal, leap-frog stepping)
c-----------------------------------------------------------------------
c
      if (mixts .and. eb) return
c
      if (mxpas2. or. mixts) then
        do 3300 j=1,jmt
          do 3290 i=1,imt
            ptd(i,j)=c2*ptd(i,j)
3290      continue
3300    continue
      endif
c
      call oput (kflds, nwds, (luptdb-1)*nwds+1, ptd)
c
#endif
      return
      end
#DECK congr9.F
      subroutine congr9
#ifdef congrad9pt
c
c=======================================================================
c
c     congr9 solves for the time derivitive of the mass transport
c     stream function using a preconditioned conjugate gradient
c     algorithm with 9 pt numerics. This allows for a more accurate
c     (compared to the 5 pt scheme) direct reconstruction of the
c     surface pressure gradients.
c
c     note: abrupt topographic changes may lead to non convergence. in
c     practice this may only be a problem for coarse resolution
c     model with non smooth topography.
c
c     this algorithm is described in gfdl tech report by j. derber, 1987
c     (see also: gill, p.e., w. murray & m.h. wright, 1981,
c      practical optimizations. academic press)
c
c=======================================================================
c
#include "param.h"
#include "crelax.h"
#include "ctmngr.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "iounit.h"
#include "levind.h"
#include "scalar.h"
#include "switch.h"
#include "temp.h"
c
c=======================================================================
c     begin introductory section to prepare for the relaxation
c=======================================================================
c
c-----------------------------------------------------------------------
c     initiate readin of solution of 2 timesteps before
c     for the purpose of computing an initial guess for the present
c     solution. (input unit alternates on time steps between 4 & 5)
c-----------------------------------------------------------------------
c
      luptdb = 5 - mod(itt,2)
      luptd  = 4 + mod(itt,2)
      call ofind (kflds, nwds, (luptdb-1)*nwds+1)
      call ofind (kflds, nwds, (luptd-1)*nwds+1)
c
      if (first .or. mixts .or. mod(itt,nmix) .eq. 2) then
c
c-----------------------------------------------------------------------
c       initialize the work area on the first entry. also during
c       a mixing time step and the following time step
c-----------------------------------------------------------------------
c
        do 100 j=1,jmt
          do 90 i=1,imt
            cfne(i,j) = c0
            cfse(i,j) = c0
            cfnw(i,j) = c0
            cfsw(i,j) = c0
            cfn(i,j) = c0
            cfs(i,j) = c0
            cfe(i,j) = c0
            cfw(i,j) = c0
            cpf(i,j) = c0
#ifdef islands
            cof(i,j)    = c1
#endif
90        continue
100     continue
c
c-----------------------------------------------------------------------
c       generate arrays of coefficients for relaxation
c-----------------------------------------------------------------------
c
c       compute coefficients for the nine point del square operator
c       coefficients are zero in land & on perimeter of land masses
c
        do 300 j=3,jmtm1
          do 290 l=1,lseg
            if (isz(j,l) .ne. 0) then
              fxa = p25*cstr(j)*csur(j  )
              fxb = p25*cstr(j)*csur(j-1)
              fxc = p25*cstr(j)*csu(j  )*dytr(j)*dyur(j  )
              fxd = p25*cstr(j)*csu(j-1)*dytr(j)*dyur(j-1)
              do 260 i=isz(j,l),iez(j,l)
                cfn(i,j)  = hr(i  ,j  )*( fxc-fxa*dxtr(i)*dxur(i  ))
     $                     +hr(i-1,j  )*( fxc-fxa*dxtr(i)*dxur(i-1))
                cfs(i,j)  = hr(i  ,j-1)*( fxd-fxb*dxtr(i)*dxur(i  ))
     $                     +hr(i-1,j-1)*( fxd-fxb*dxtr(i)*dxur(i-1))
                cfe(i,j)  = hr(i  ,j  )*(-fxc+fxa*dxtr(i)*dxur(i  ))
     $                     +hr(i  ,j-1)*(-fxd+fxb*dxtr(i)*dxur(i  ))
                cfw(i,j)  = hr(i-1,j  )*(-fxc+fxa*dxtr(i)*dxur(i-1))
     $                     +hr(i-1,j-1)*(-fxd+fxb*dxtr(i)*dxur(i-1))
                cfne(i,j) = hr(i  ,j  )*(fxc+fxa*dxtr(i)*dxur(i  ))
                cfnw(i,j) = hr(i-1,j  )*(fxc+fxa*dxtr(i)*dxur(i-1))
                cfse(i,j) = hr(i  ,j-1)*(fxd+fxb*dxtr(i)*dxur(i  ))
                cfsw(i,j) = hr(i-1,j-1)*(fxd+fxb*dxtr(i)*dxur(i-1))
                cpf(i,j)  = c1/(cfne(i,j)+cfnw(i,j)+cfse(i,j)+cfsw(i,j))
260           continue
c
c             augment coefficients for implicit coriolis treatment
c
              if (acor .ne. c0) then
                fx = -c2dtsf*acor*cstr(j)*dytr(j)*omega
                do 270 i=isz(j,l),iez(j,l)
                  cfn(i,j) = cfn(i,j)+(hr(i,j  )-hr(i-1,j  ))*sine(j  )
     $                          *fx*dxtr(i)
                  cfs(i,j) = cfs(i,j)-(hr(i,j-1)-hr(i-1,j-1))*sine(j-1)
     $                          *fx*dxtr(i)
                  cfe(i,j) = cfe(i,j)-(hr(i  ,j)*sine(j)-hr(i  ,j-1)
     $                          *sine(j-1))*fx*dxtr(i)
                  cfw(i,j) = cfw(i,j)+(hr(i-1,j)*sine(j)-hr(i-1,j-1)
     $                          *sine(j-1))*fx*dxtr(i)
270             continue
              endif
c
c             normalize coefficients
c
              do 280 i=isz(j,l),iez(j,l)
                cfn(i,j)  = cfn(i,j)*cpf(i,j)
                cfs(i,j)  = cfs(i,j)*cpf(i,j)
                cfe(i,j)  = cfe(i,j)*cpf(i,j)
                cfw(i,j)  = cfw(i,j)*cpf(i,j)
                cfne(i,j) = cfne(i,j)*cpf(i,j)
                cfnw(i,j) = cfnw(i,j)*cpf(i,j)
                cfse(i,j) = cfse(i,j)*cpf(i,j)
                cfsw(i,j) = cfsw(i,j)*cpf(i,j)
280           continue
            endif
290       continue
300     continue
#ifdef islands
c
c       modify coefficients to include island perimeter points
c
        do 400 isle=1,nisle
          cofis(isle) = c0
          do 390 n=1,nippts(isle)
            i = iperm(iofs(isle)+n)
            j = jperm(iofs(isle)+n)
            fxa = p25*cstr(j)*csur(j  )
            fxb = p25*cstr(j)*csur(j-1)
            fxc = p25*cstr(j)*csu(j  )*dytr(j)*dyur(j  )
            fxe = p25*cstr(j)*csu(j-1)*dytr(j)*dyur(j-1)
            fxd = -c2dtsf*acor*cstr(j)*dytr(j)*omega
            cfn(i,j)  = hr(i  ,j  )*( fxc-fxa*dxtr(i)*dxur(i  ))
     $                     +hr(i-1,j  )*( fxc-fxa*dxtr(i)*dxur(i-1))
     $                     +fxd*dxtr(i)*(hr(i,j)-hr(i-1,j))*sine(j)
            cfs(i,j)  = hr(i  ,j-1)*( fxe-fxb*dxtr(i)*dxur(i  ))
     $                     +hr(i-1,j-1)*( fxe-fxb*dxtr(i)*dxur(i-1))
     $                    -fxd*dxtr(i)*(hr(i,j-1)-hr(i-1,j-1))
     $                     *sine(j-1)
            cfe(i,j)  = hr(i  ,j  )*(-fxc+fxa*dxtr(i)*dxur(i  ))
     $                     +hr(i  ,j-1)*(-fxe+fxb*dxtr(i)*dxur(i  ))
     $                     -fxd*dxtr(i)*(hr(i,j)*sine(j)-hr(i,j-1)
     $                      *sine(j-1))
            cfw(i,j)  = hr(i-1,j  )*(-fxc+fxa*dxtr(i)*dxur(i-1))
     $                     +hr(i-1,j-1)*(-fxe+fxb*dxtr(i)*dxur(i-1))
     $                     +fxd*dxtr(i)*(hr(i-1,j)*sine(j)-hr(i-1,j-1)
     $                     *sine(j-1))
            cfne(i,j) = hr(i  ,j  )*(fxc+fxa*dxtr(i)*dxur(i  ))
            cfnw(i,j) = hr(i-1,j  )*(fxc+fxa*dxtr(i)*dxur(i-1))
            cfse(i,j) = hr(i  ,j-1)*(fxe+fxb*dxtr(i)*dxur(i  ))
            cfsw(i,j) = hr(i-1,j-1)*(fxe+fxb*dxtr(i)*dxur(i-1))
            cpf(i,j)  = c1/(cfne(i,j)+cfse(i,j)+cfnw(i,j)+cfsw(i,j))
            cfn(i,j)  = cfn(i,j)*cpf(i,j)
            cfs(i,j)  = cfs(i,j)*cpf(i,j)
            cfe(i,j)  = cfe(i,j)*cpf(i,j)
            cfw(i,j)  = cfw(i,j)*cpf(i,j)
            cfne(i,j) = cfne(i,j)*cpf(i,j)
            cfnw(i,j) = cfnw(i,j)*cpf(i,j)
            cfse(i,j) = cfse(i,j)*cpf(i,j)
            cfsw(i,j) = cfsw(i,j)*cpf(i,j)
            cof(i,j)  = cst(j)*dxt(i)*dyt(j)/cpf(i,j)
            cofis(isle) = cofis(isle) + cof(i,j)
390       continue
          cofis(isle) = c1/cofis(isle)
400     continue
c
        do 700 isle=1,nisle
          do 690 n=1,nippts(isle)
            i = iperm(iofs(isle)+n)
            j = jperm(iofs(isle)+n)
            cof(i,j) = cof(i,j)*cofis(isle)
690       continue
700     continue
# ifdef cyclic
c
        do 800 j=1,jmt
          cof(1,j)  = c0
          cof(imt,j) = c0
800     continue
# endif
#endif
c
      endif
c
c-----------------------------------------------------------------------
c     normalize vorticity "ztd"
c-----------------------------------------------------------------------
c
      do 900 j=1,jmt
        do 890 i=1,imt
          ztd(i,j) = ztd(i,j)*cpf(i,j)
890     continue
900   continue
c
c-----------------------------------------------------------------------
c     complete readin of relaxation solution of 2 timesteps prior and
c     of previous timestep.
c-----------------------------------------------------------------------
c
      call oget (kflds, nwds, (luptdb-1)*nwds+1, res)
      call oget (kflds, nwds, (luptd-1)*nwds+1, ptd)
c
c-----------------------------------------------------------------------
c     erstimate a first guess by extrapolating the two
c     previous solutions forward in time.
c-----------------------------------------------------------------------
c
      fxa = c1
      if (mixts .or. mxpas2) fxa = p5
      do 1000 j=1,jmt
        do 990 i=1,imt
          ptd(i,j) = fxa*(c2*ptd(i,j)-res(i,j))
990     continue
1000  continue
#ifdef cyclic
c
c     set cyclic bc
c
      do 1110 j=2,jmtm1
        ptd(1,j)   = ptd(imtm1,j)
        ptd(imt,j) = ptd(2,j)
1110  continue
#endif
c
c-----------------------------------------------------------------------
c     compute convergence criterion & find initial residuals
c-----------------------------------------------------------------------
c
      crtp = crit*fxa
      do 1200 j=1,jmt
        do 1190 i=1,imt
          res(i,j) = c0
1190    continue
1200  continue
c
      do 1300 j=2,jmtm1
        do 1290 i=2,imtm1
          res(i,j) = cfn(i,j)*ptd(i,j+1)
     $             + cfs(i,j)*ptd(i,j-1)
     $             + cfe(i,j)*ptd(i+1,j)
     $             + cfw(i,j)*ptd(i-1,j)
     $             + cfne(i,j)*ptd(i+1,j+1)
     $             + cfnw(i,j)*ptd(i-1,j+1)
     $             + cfse(i,j)*ptd(i+1,j-1)
     $             + cfsw(i,j)*ptd(i-1,j-1)
     $             - ptd(i,j) - ztd(i,j)
#ifdef islands
          res(i,j) = res(i,j)*cof(i,j)
#endif
1290    continue
1300  continue
#ifdef islands
c
c     find initial island residual using a line integral.
c      update res(i,j) on perimeter & interior of island
c
      do 1400 isle=1,nisle
        resis = c0
        do 1360 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          resis = resis + res(i,j)
1360    continue
        do 1370 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          res(i,j) = resis
1370    continue
1400  continue
#endif
#ifdef cyclic
c
c     set cyclic bc
c
      do 1500 j=2,jmtm1
        res(1,j)   = res(imtm1,j)
        res(imt,j) = res(2,j)
1500  continue
#endif
#ifdef symmetry
c
c     set symmetry bc
c
      do 1600 i=1,imt
        res(i,jmt) = - res(i,jmtm1)
1600  continue
#endif
c
c     initialize beta & gdir
c
      beta = c0
      do 1700 j=1,jmt
        do 1690 i=1,imt
          gdir(i,j) = c0
1690    continue
1700  continue
c
c-----------------------------------------------------------------------
c     begin iteration loop using conjugate gradient technique
c-----------------------------------------------------------------------
c
      mscan=0
1701  continue
      mscan = mscan + 1
c
c-----------------------------------------------------------------------
c     compute field of residuals
c-----------------------------------------------------------------------
c
      do 1800 j=2,jmtm1
        do 1790 i=2,imtm1
          gdir(i,j) = cfn(i,j)*res(i,j+1) +
     $                cfs(i,j)*res(i,j-1) +
     $                cfe(i,j)*res(i+1,j) +
     $                cfw(i,j)*res(i-1,j)
     *        +cfne(i,j)*res(i+1,j+1)
     *        +cfnw(i,j)*res(i-1,j+1)
     *        +cfse(i,j)*res(i+1,j-1)
     *        +cfsw(i,j)*res(i-1,j-1)
     $                - res(i,j)
#ifdef islands
          gdir(i,j) = gdir(i,j)*cof(i,j)
#endif
1790    continue
1800  continue
#ifdef islands
c
c     find island residuals using stokes theorem for the
c     line integral. update gdir on perimeter & interior of island
c
      do 1900 isle=1,nisle
        resis = c0
        do 1860 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          resis = resis + gdir(i,j)
1860    continue
        do 1870 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          gdir(i,j) = resis
1870    continue
1900  continue
#endif
#ifdef cyclic
c
c     set cyclic condition
c
      do 2000 j=2,jmtm1
        gdir(1,j)   = gdir(imtm1,j)
        gdir(imt,j) = gdir(2,j)
2000  continue
#endif
c
      do 2100 j=2,jmtm1
        asum(j) = c0
        do 2090 i=2,imtm1
          asum(j) = asum(j) + gdir(i,j)*res(i,j)
2090    continue
2100  continue
c
      apr4 = c0
      do 2200 j=2,jmtm1
        apr4 = apr4 + asum(j)
2200  continue
c
      if (mscan .gt. 1) then
        if (oapr .ne. c0) then
          beta = apr4/oapr
        else
          beta = c0
        endif
      endif
c
c-----------------------------------------------------------------------
c     calculate new values for hdir and fdir
c-----------------------------------------------------------------------
c
      do 2300 j=2,jmtm1
        do 2290 i=1,imt
          hdir(i,j)   = res(i,j)  + beta*hdir(i,j)
          fdir(i,j)   = gdir(i,j) + beta*fdir(i,j)
2290    continue
2300  continue
c
      oapr = apr4
      apr2 = c0
      do 2400 j=2,jmtm1
        asum(j) = c0
        do 2390 i=2,imtm1
          asum(j) = asum(j) + fdir(i,j)*fdir(i,j)
2390    continue
2400  continue
c
      do 2500 j=2,jmtm1
        apr2 = apr2 + asum(j)
2500  continue
c
c-----------------------------------------------------------------------
c     calculate stepsize (asor) & make a correction to ptd res
c-----------------------------------------------------------------------
c
      if (apr2 .ne. c0) then
        asor = - apr4/apr2
      else
        asor = c0
      endif
c
      do 2600 j=2,jmtm1
        do 2590 i=1,imt
          ptd(i,j) = ptd(i,j) + asor*hdir(i,j)
          res(i,j) = res(i,j) + asor*fdir(i,j)
2590    continue
2600  continue
#ifdef cyclic
c
c     set cyclic condition
c
      do 2700 j=2,jmtm1
        res(1,j)   = res(imtm1,j)
        res(imt,j) = res(2,j)
2700  continue
#endif
c
c-----------------------------------------------------------------------
c     find the maximum absolute residual to determine convergence
c-----------------------------------------------------------------------
c
      resmax = c0
      do 2800 j=3,jscan
        do 2790 i=2,imtm1
          resmax = max(abs(res(i,j)), resmax)
2790    continue
2800  continue
#ifdef symmetry
c
c     set symmetry on northern wall
c
      do 2900 i=1,imt
        res(i,jmt) = - res(i,jmtm1)
2900  continue
#endif
c
c-----------------------------------------------------------------------
c      take another iteration unless the max residual < crtp or
c      the number of scans reaches mxscan
c-----------------------------------------------------------------------
c
      if (resmax .ge. crtp .and. mscan .lt. mxscan) go to 1701
c
c=======================================================================
c     end of the iteration loop
c=======================================================================
c
#ifdef symmetry
c
c     set symmetry on northern wall
c
      do 3000 i=1,imt
        ptd(i,jmt) = - ptd(i,jmtm1)
3000  continue
#endif
c-----------------------------------------------------------------------
c     update the stream function based upon the relaxation solution
c-----------------------------------------------------------------------
c
      if (.not. mxpas2) then
        do 3100 j=1,jmt
          do 3090 i=1,imt
            res(i,j) = p(i,j,2) + ptd(i,j)
            p(i,j,2)  = p(i,j,1)
            p(i,j,1)  = res(i,j)
3090      continue
3100    continue
      else
        do 3200 j=1,jmt
          do 3190 i=1,imt
            p(i,j,1) = p(i,j,2) + ptd(i,j)
3190      continue
3200    continue
      endif
c
c-----------------------------------------------------------------------
c     save ptd to compute 1st guess for relaxation next timestep
c     (..note.. on 1st pass of euler backward timestep, bypass this
c            save, since it will be done on the 2nd pass)
c     (..note.. on a mixing timestep, alter ptd to be consistent with
c            normal, leap-frog stepping)
c-----------------------------------------------------------------------
c
      if (mixts .and. eb) return
c
      if (mxpas2. or. mixts) then
        do 3300 j=1,jmt
          do 3290 i=1,imt
            ptd(i,j)=c2*ptd(i,j)
3290      continue
3300    continue
      endif
c
      call oput (kflds, nwds, (luptdb-1)*nwds+1, ptd)
c
#endif
      return
      end
#DECK delsq.F
      subroutine delsqr (j, jjm, jjc, jjp)
#ifdef biharmonic
# ifdef multitasking
cfpp$ noconcur r
# endif
c
c=======================================================================
c
c     compute del**2 for prognostic variables on row "j"
c     pointer (index) "jjm" points to the "j-1" row in memory
c     pointer (index) "jjc" points to the "j"   row in memory
c     pointer (index) "jjp" points to the "j+1" row in memory
c
c=======================================================================
c
#include "param.h"
#include "cbihar.h"
#include "chmix.h"
#include "grdvar.h"
#include "slabs.h"
c
c-----------------------------------------------------------------------
c     del**2 of tracers
c     pointer (index) "jpt3" points to the position within "del2"
c                      corresponding to "jjc"
c-----------------------------------------------------------------------
c
      do 100 m=1,nt
        do 70 k=1,km
          do 60 i=2,imt
            aux2(i,k) = dxu2r(i-1)*(t(i,k,jjc,nm,m)-t(i-1,k,jjc,nm,m))
60        continue
70      continue
c
        do 90 k=1,km
          do 80 i=2,imtm1
            del2(i,k,m,jpt3) = bbt(j)*dxt4r(i)*
     $           (fm(i+1,k,jjc)*aux2(i+1,k) - fm(i-1,k,jjc)*aux2(i,k))
     $         +  cct(j)*fm(i,k,jjp)*(t(i,k,jjp,nm,m)-t(i,k,jjc,nm,m))
     $         +  ddt(j)*fm(i,k,jjm)*(t(i,k,jjm,nm,m)-t(i,k,jjc,nm,m))
80        continue
#ifdef cyclic
          del2(1,k,m,jpt3)   = del2(imtm1,k,m,jpt3)
          del2(imt,k,m,jpt3) = del2(2,k,m,jpt3)
#else
          del2(1,k,m,jpt3)   = c0
          del2(imt,k,m,jpt3) = c0
#endif
90      continue
100   continue
c
c-----------------------------------------------------------------------
c     del**2 of momentum
c     pointer (index) "jpt3" points to the position within "del2"
c                      corresponding to "jjc"
c-----------------------------------------------------------------------
c
      do 200 k=1,km
        do 190 i=2,imt
          aux3(i,k) = dxt4r(i)*(u(i,k,jjc,nm)-u(i-1,k,jjc,nm))
          aux4(i,k) = dxt4r(i)*(v(i,k,jjc,nm)-v(i-1,k,jjc,nm))
190     continue
200   continue
c
c     zonal component
c
      m = nt + 1
      do 300 k=1,km
        do 290 i=2,imtm1
          del2(i,k,m,jpt3) = bbu(j)*(dxu2r(i)*(aux3(i+1,k) - aux3(i,k)))
     $                     + ccu(j)*(u(i,k,jjp,nm) - u(i,k,jjc,nm))
     $                     + ddu(j)*(u(i,k,jjm,nm) - u(i,k,jjc,nm))
     $                     + ggu(j)*u(i,k,jjc,nm) - hhu(j)*
     $                      dxu2r(i)*(v(i+1,k,jjc,nm) - v(i-1,k,jjc,nm))
290     continue
#ifdef cyclic
        del2(1,k,m,jpt3)   = del2(imtm1,k,m,jpt3)
        del2(imt,k,m,jpt3) = del2(2,k,m,jpt3)
#else
        del2(1,k,m,jpt3)   = c0
        del2(imt,k,m,jpt3) = c0
#endif
300   continue
c
c     meridional component
c
      m = nt + 2
      do 400 k=1,km
        do 390 i=2,imtm1
          del2(i,k,m,jpt3) = bbu(j)*(dxu2r(i)*(aux4(i+1,k) - aux4(i,k)))
     $                     + ccu(j)*(v(i,k,jjp,nm) - v(i,k,jjc,nm))
     $                     + ddu(j)*(v(i,k,jjm,nm) - v(i,k,jjc,nm))
     $                     + ggu(j)*v(i,k,jjc,nm) + hhu(j)*
     $                      dxu2r(i)*(u(i+1,k,jjc,nm) - u(i-1,k,jjc,nm))
390     continue
#ifdef cyclic
        del2(1,k,m,jpt3)   = del2(imtm1,k,m,jpt3)
        del2(imt,k,m,jpt3) = del2(2,k,m,jpt3)
#else
        del2(1,k,m,jpt3)   = c0
        del2(imt,k,m,jpt3) = c0
#endif
400   continue
#ifdef tcvmix
c
c-----------------------------------------------------------------------
c     del**2 of turbulent kenetic energy
c     pointer (index) "jpt3" points to the position within "del2"
c                      corresponding to "jjc"
c-----------------------------------------------------------------------
c
c       q2
c
        m = nt + 3
        do 500 k=1,km
          do 490 i=2,imt
            aux2(i,k) = dxu2r(i-1)*(q2(i,k,jjc,nm)-q2(i-1,k,jjc,nm))
490       continue
500     continue
c
        do 600 k=1,km
          do 590 i=2,imtm1
            del2(i,k,m,jpt3) = bbt(j)*dxt4r(i)*
     $           (fm(i+1,k,jjc)*aux2(i+1,k) - fm(i-1,k,jjc)*aux2(i,k))
     $         + cct(j)*fm(i,k,jjp)*(q2(i,k,jjp,nm)-q2(i,k,jjc,nm))
     $         + ddt(j)*fm(i,k,jjm)*(q2(i,k,jjm,nm)-q2(i,k,jjc,nm))
590       continue
# ifdef cyclic
          del2(1,k,m,jpt3)   = del2(imtm1,k,m,jpt3)
          del2(imt,k,m,jpt3) = del2(2,k,m,jpt3)
# else
          del2(1,k,m,jpt3)   = c0
          del2(imt,k,m,jpt3) = c0
# endif
600     continue
# ifdef leq
c
c       q2l
c
        m = nt + 4
        do 700 k=1,km
          do 690 i=2,imt
            aux2(i,k) = dxu2r(i-1)*(q2l(i,k,jjc,nm)-q2l(i-1,k,jjc,nm))
690       continue
700     continue
c
        do 800 k=1,km
          do 790 i=2,imtm1
            del2(i,k,m,jpt3) = bbt(j)*dxt4r(i)*
     $           (fm(i+1,k,jjc)*aux2(i+1,k) - fm(i-1,k,jjc)*aux2(i,k))
     $         + cct(j)*fm(i,k,jjp)*(q2l(i,k,jjp,nm)-q2l(i,k,jjc,nm))
     $         + ddt(j)*fm(i,k,jjm)*(q2l(i,k,jjm,nm)-q2l(i,k,jjc,nm))
790       continue
#  ifdef cyclic
          del2(1,k,m,jpt3)   = del2(imtm1,k,m,jpt3)
          del2(imt,k,m,jpt3) = del2(2,k,m,jpt3)
#  else
          del2(1,k,m,jpt3)   = c0
          del2(imt,k,m,jpt3) = c0
#  endif
800     continue
# endif
#endif
#endif
      return
      end
#DECK denscoef.F
      subroutine eqstat
c      program eqstat
c
c     due to the simple UNIX linker, only one main program may
c     be in the directory at one time. To run this program, wipe out
c     the subroutine call & uncomment the "program eqstat" line. all
c     other main programs must be either removed from the directory or
c     commented out also!
c     note: this is no problem if "makefiles" are used for compiling
c           & linking.
c
c=======================================================================
c     calculate coefficients for "MOM" density computations
c
c       This program calculates the 9 coefficients of a third order
c     polynomial approximation to the equation of state for sea water.
c       The program yields coefficients that will compute density as a
c     function of temperature and salinity, at predetermined depths,
c     as used in the subroutine "state" of the GFDL ocean model.
c     More specifically, the densities calculated from the polynomial
c     formula are in the form of sigma anomalies.  The method is
c     taken from that described by Bryan & Cox (1972).
c       By default, the program uses the equation of state set by the
c     Joint Panel on Oceanographic Tables & Standards (UNESCO, 1981)
c     an described by Gill (1982).  An option exists to use the older
c     Knudsen-Ekman equation of state, as described by Fofonoff (1962),
c     if the user prefers.
c       Subroutine "lsqsl2" performs the iterative least-squares
c     polynomial fitting for the overdetermined system.  The algorithm
c     is outlined by Hanson and Lawson (1969), and the code looks as if
c     it has not be touched since that time.
c
c     references:
c        Bryan, K. & M. Cox, An approximate equation of state
c          for numerical models of ocean circulation, J. Phys.
c          Oceanogr., 2, 510-514, 1972.
c        Fofonoff, N., The Sea: Vol 1, (ed. M. Hill). Interscience,
c          New York, 1962, pp 3-30.
c        Gill, A., Atmosphere-Ocean Dynamics: International Geophysical
c          Series No. 30. Academic Press, London, 1982, pp 599-600.
c        Hanson, R., & C. Lawson, Extensions and applications of the
c          Householder algorithm for solving linear least squares
c          problems. Math. Comput., 23, 787-812, 1969.
c        UNESCO, 10th report of the joint panel on oceanographic tables
c          and standards. UNESCO Tech. Papers in Marine Sci. No. 36,
c          Paris, 1981.
c
c    ifdef options:
c       "knudsen"
c       To over-ride the default of using the UNESCO equation of state
c     and to instead employ the Knudsen-Ekman formula.
c       "insitu"
c       If the user desires the polynomial approximations to calculate
c     density as a function of in situ temperature, salinity, and depth,
c     then the ifdef option "insitu" must be defined.  Otherwise, the
c     default assumption is that potential temperatures will be used (as
c     in the ocean model code).
c       "extras"
c       If the user wishes to have a detailed report of the inputs and
c     results of the curve fitting processes written to the standard
c     output unit (stdout), then the ifdef option "extras" should be
c     defined.  The default is for a rather short summary to be written.
c
c    inputs:
c      The user needs only to specify the number of model levels "km"
c    and the model layer thicknesses [cm] "dzt(1..km)".
c    This information can be entered below via the same "dzt" data
c    statement contained in the "thick.h" file used in the compilation
c    of the GFDL ocean model.  The parameter "km" and constants "c0",
c    "c1", "c2", and ""p5", can be set by including the "param.h" file
c    from the model as well.
c
c-----------------------------------------------------------------------
c
      implicit double precision (a-h,o-z)
c
c-----------------------------------------------------------------------
c
#include "param.h"
c
      dimension dzt(km)
c
      parameter (kx = 5, kxx = 2*kx, kk = kx*kxx )
      parameter (ksdim = kk+72 , krdim = kk+36 )
c
      dimension a(kk,9), sigma(kk), sigman(kk), c(kk,9), x(9),
     $          sb(ksdim), r(krdim)
      dimension tmin(km), smin(km), tmax(km), smax(km),
     $          z(km), dd(km), ss(km), ab(13,km), ts(33,4),
     $          ta(kxx), sa(kxx), tp(kk), sp(kk), th(kk)
c
      real realz
c
      double precision mpercm
      data  mpercm / 1.0d-2 /
c
#include "thick.h"
c
c  enter bounds for polynomial fit: at 33 levels from sfc to 8000 m.
c           ts(k,1)=lower bnd of t at z=(k-1)*250 meters
c           ts(k,2)=upper bnd of t          "
c           ts(k,3)=lower bnd of s          "
c           ts(k,4)=upper bnd of s          "
c  The user should review the appropriateness of the "ts" values set
c  below, and modify them if the intended modelling application could
c  be expected to yield temperature and salinity values outside of the
c  "ts" ranges set by default.
c
      data (ts(k,1),k=1,33) / 4*-2.0, 15*-1.0, 14*0.0 /
      data (ts(k,2),k=1,33) / 29.0, 19.0, 14.0, 11.0, 9.0, 28*7.0 /
      data (ts(k,3),k=1,33) / 28.5, 33.7, 34.0, 34.1, 34.2, 34.4,
     $                        2*34.5, 15*34.6, 10*34.7 /
      data (ts(k,4),k=1,33) / 37.0, 36.6, 35.8, 35.7, 35.3, 2*35.1,
     $                        26*35.0 /
c
c     z       = model levels (midpoint of model layers)
c     tmin, tmax, smin, smax = minimum and maximum in situ temperature
c               and salinity values which define the ranges to be used
c               when computing the polynomials at each model level
c     dd, ds  = increment between temperature and salinity values at
c               each model level to be used in constructing array of
c               temperature, salinity and density for curve fitting
c     ta, sa  = in situ temperature and salinity values available for
c               constructing array of data for curve fitting at each
c               model level
c     tp, sp  = in situ temperature and salinity values constructed from
c               all combinations of ta & sa
c     th      = potential temperature values associated with "tp" at a
c               given level and salinity
c     t1, s1, tot1, th1 = level mean insitu temp., salinity, density,
c               and potential temp. used in polynomial fitting
c     tot     = density (in sigma units) calculate from t1 and s1 at a
c               given model level
c     sigma   = insitu densities (in sigma units) calculated from "tp"
c               and "sp" values
c     sigman  = insitu density anomalies at a given level (formed by
c               subracting "tot" from sigma)
c     tanom, sanom = temperature and salinity anomalies used in loading
c               array "a" for use in lsqsl2 curve fitting
c     x       = the 9 polynomial coefficients
c     r, sb   = used only in lsqsl2
c
c=======================================================================
c
c
c     calculate depths of levels from dzt (converting dzt from cm
c     to meters) - the maximum allowable depth is 8000 meters
c
      z(1)= p5 * dzt(1) * mpercm
      do 100 k=2,km
        z(k) = z(k-1) + p5 * (dzt(k)+dzt(k-1)) * mpercm
100   continue
c
c     set the temperature and salinity ranges to be used for each
c     model level when performing the polynomial fitting
c
      do 200 k=1,km
        realz = z(k)/250.0
        i = ifix (realz) + 1
        tmin(k) = ts(i,1)
        tmax(k) = ts(i,2)
        smin(k) = ts(i,3)
        smax(k) = ts(i,4)
200   continue
c
c  write out model depths and ranges of temperatures & salinities over
c  which the polynomial approximations are computed.
c
      write (stdout,9060)
      write (stdout,9061) (z(i),tmin(i),tmax(i),smin(i),smax(i),i=1,km)
      write (stdout,9062)
c
c  set temperature and salinity increments to be used in creating
c  curve fitting array at each level (twice as many temperature values
c  than salinity values)
c
      fkx = kx
      do 300 k=1,km
        dd(k) = (tmax(k)-tmin(k)) / (c2*fkx-c1)
        ss(k) = (smax(k)-smin(k)) / (fkx-c1)
300   continue
c
c  loop over all model levels
c
      do 400 k=1,km
c
        do 340 i=1,kxx
          fi = i
          ta(i) = tmin(k) + (fi-c1)*dd(k)
          sa(i) = smin(k) + (fi-c1)*ss(k)
340     continue
c
c  load the "kxx" cominations of the 2*"kx" insitu temp. and "kx"
c  salinity values into "tp" and "sp"
c
        do 360 i=1,kxx
          do 350 j=1,kx
            ka = kx*i + j - kx
            tp(ka) = ta(i)
            sp(ka) = sa(j)
350       continue
360     continue
c
        t1  = c0
        s1  = c0
        tot = c0
        th1 = c0
        fkk = kk
c
c  calculate insitu density "sigma" for each t,s combintion at
c  this depth "d"
c
        do 370 ka=1,kk
          d = z(k)
          s = sp(ka)
          t = tp(ka)
c
#ifdef knudsen
c  "knuekm" returns density (in sigma units) from insitu temperature,
c  salinity, & depth (pressure) using the Knudsen-Ekman formula
c
          call knuekm(t,s,d,densit)
c
          sigma(ka) = densit
#else
c  "unesco" returns density (kg per m**3) from insitu temperature,
c  salinity, & depth (pressure) using the UNESCO equation of state
c
          call unesco(t,s,d,densit)
c
          sigma(ka) = densit - 1.0d3 + 2.5d-2
#endif
c
c  "potem" returns potential temp. from from insitu temperature,
c  salinity, & depth (pressure)
c
          call potem(t,s,d,theta)
c
          th(ka) = theta
          t1 = t1 + tp(ka)
          s1 = s1 + sp(ka)
          tot = tot + sigma(ka)
          th1 = th1 + th(ka)
370     continue
c
c  form layer averages "t1", "s1", "th1", and "tot1", and compute
c  reference density "tot" from "t1" and "s1" at this depth "d"
c
        t1 = t1/fkk
        s1 = s1/fkk
        th1 = th1/fkk
        tot1 = tot/fkk
#ifdef knudsen
c
c  "knuekm" returns density from insitu temp., salinity, & depth
c  (pressure) using the Knudsen-Ekman formula
c
        call knuekm (t1, s1, d, densit)
c
        tot = densit
#else
c
c  "unesco" returns density from insitu temp., salinity, & depth
c  (pressure) using the UNESCO equation of state
c
        call unesco (t1, s1, d, densit)
        tot = densit - 1.0d3 + 2.5d-2

#endif
c
#ifdef extras
c
c define "extras" for voluminous printout of calculation info.
c
        write (stdout,'(a49)')
     $  ' insitu temperatures used in polynomial fit & avg'
        write (stdout, 9071) kk, (tp(ka),ka=1,kk)
        write (stdout, 9072) t1, k
        write (stdout,'(a40)')
     $  ' salinities used in polynomial fit & avg'
        write (stdout, 9071) kk, (sp(ka),ka=1,kk)
        write (stdout, 9072) s1, k
        write (stdout,'(a53)')
     $  ' densities (sigma units) used in polynomial fit & avg'
        write (stdout, 9071) kk, (sigma(ka),ka=1,kk)
        write (stdout, 9072) tot1, k
        write (stdout,'(a54)')
     $  ' density calculated from level avg insitu T & salinity'
        write (stdout, 9072) tot, k
        write (stdout,'(a52)')
     $  ' potential temperatures used in polynomial fit & avg'
        write (stdout, 9071) kk, (th(ka),ka=1,kk)
        write (stdout, 9072) th1, k
#ifdef insitu
        write (stdout,'(a47)')
     $  ' >> insitu temps were used in polynomial fit <<'
#else
        write (stdout,'(a50)')
     $  ' >> potential temps were used in polynomial fit <<'
#endif
c
#endif
#ifndef insitu
c
c define insitu if using insitu temperatures (removes this line)
c
        t1 = th1
c
#endif
c
c  begin loading "ab" array with level averages
c
        ab(1,k) = z(k)
        ab(2,k) = tot
        ab(3,k) = t1
        ab(4,k) = s1
c
        do 380 ka=1,kk
#ifndef insitu
c
c define insitu (removes this line) if using insitu temperatures
c
          tp(ka) = th(ka)
#endif
c
c  create anomalies for temperature, salinity & density and
c  load work array "a" with the anomalies and their products
c
          tanom = tp(ka) - t1
          sanom = sp(ka) - s1
          sigman(ka) = sigma(ka) - tot
          a(ka,1) = tanom
          a(ka,2) = sanom
          a(ka,3) = tanom * tanom
          a(ka,4) = tanom * sanom
          a(ka,5) = sanom * sanom
          a(ka,6) = a(ka,3) * tanom
          a(ka,7) = a(ka,5) * tanom
          a(ka,8) = a(ka,3) * sanom
          a(ka,9) = a(ka,5) * sanom
380     continue
c
c     set the arguments used in call to "lsqsl2"
c     ndim = first dimension of array a
c     nrow =number of rows of array a
c     ncol = number of columns of array a
c     in = option number of lsqsl2
c     itmax = number of iterations
c
        ndim = 50
        nrow = kk
        ncol = 9
        in = 1
        itmax = 4
c
        it = 0
        ieq = 2
        irank = 0
        eps = 1.0e-7
        nhdim = 9
c
c   LSQL2 is  a Jet Propulsion Laboratory subroutine that
c   computes the least squares fit in an iterative manner for
c   overdetermined systems.
c
        call lsqsl2 (ndim, a, nrow, ncol, sigman, x, irank, in, itmax,
     $               it, ieq, enorm, eps, nhdim, h, c, r, sb)
c
#ifdef extras
        write (stdout, 9081) k, (x(i),i=1,9)
        write (stdout, 9082) tot
        write (stdout, 9062)
c
#endif
        do 390 i=1,ncol
          ab(i+4,k) = x(i)
390     continue
c
400   continue
c
      nn = ncol + 4
      write (stdout, 9091)
      write (stdout, 9092) ((ab(i,j),i=1,nn),j=1,km)
      write (stdout, 9093)
c
c     write data statements to unit 50 ==> "dncoef.h"
c
      open (50,file='dncoef.h')
c
      write(50,9501)
c
      do 500 k=1,km
        ab(2,k) = 1.e-3 * ab(2,k)
        ab(4,k) = 1.e-3 * ab(4,k) - 0.035
        ab(5,k) = 1.e-3 * ab(5,k)
        ab(7,k) = 1.e-3 * ab(7,k)
        ab(10,k) = 1.e-3 * ab(10,k)
        ab( 9,k) = 1.e+3 * ab( 9,k)
        ab(11,k) = 1.e+3 * ab(11,k)
        ab(13,k) = 1.e+6 * ab(13,k)
500   continue
c
c   write out "to" & "so" data statements
c
      do 600 nx=3,4
        if (nx .eq. 3) write(50,9502)
        if (nx .eq. 4) write(50,9503)
        n = 0
        do 590 ii=1,99
          is = n+1
          ie = n+5
          if (ie .lt. km) then
            write(50,9510) (ab(nx,i),i=is,ie)
            n = ie
          else
            ie = km
            n = ie-is+1
            if (n .eq. 1) write(50,9511) (ab(nx,i),i=is,ie)
            if (n .eq. 2) write(50,9512) (ab(nx,i),i=is,ie)
            if (n .eq. 3) write(50,9513) (ab(nx,i),i=is,ie)
            if (n .eq. 4) write(50,9514) (ab(nx,i),i=is,ie)
            if (n .eq. 5) write(50,9515) (ab(nx,i),i=is,ie)
            goto 600
          endif
590     continue
600   continue
c
      do 700 k=1,km
        write(50,9521) k
        write(50,9522) (ab(i,k),i=5,8)
        write(50,9522) (ab(i,k),i=9,12)
        write(50,9523) ab(13,k)
700   continue
c
      write (50,9531)
      write (50,9532) (i, z(i),tmin(i),tmax(i),smin(i),smax(i),i=1,km)
      write (50,9533)
      do 800 k=1,km
        ab(2,k) = ab(2,k) * 1.e3
800   continue
      write (50,9534) (ab(2,k),k=1,km)
      write (50,9535)
      close (50)
c
c =====================================================================
c
      stop
c
 9060 format(///6x,'level   tmin      tmax      smin      smax',/)
 9061 format(5x,f5.0,4f10.3)
 9062 format(///)
 9091 format(//,
     $' calculating coefficients for "MOM" density computations'/
     $'   z    sig0    t    s       x1          x2         ',
     $'x3          x4          x5          x6          x7          x8',
     $'          x9',/)
 9092 format(//,f5.0,f8.4,f5.1,f6.2,9e12.5)
 9093 format(//,
     $' === a new "dncoef.h" has been created by this program === ')

#ifdef extras
 9071 format(/' kk = # of pts going into interpltn =',i4,/
     $       (1x,5e14.7))
 9072 format(5x,' avg =',e14.7,' for level ',i4,/)
 9081 format(' model level ',i3,': before scaling (x(i),i=1,9)='/
     $        1x,5e14.7,/,1x,4e14.7)
 9082 format(' reference sigma, about which density anomalies are ',
     $       'computed'/1x,e14.7)
#endif
c
 9501 format('c====================== include file "dncoef.h"',
     $  ' =========================='/'c'/'c'/,
     $  'c     normalized temperatures, salinities and',
     $  ' coefficients'/'c     generated by program "eqstat" ',
     $  'which fits 3rd order polynomials'/'c     to the equation ',
     $  'of state for each model level.'/'c')
 9502 format(6x,'data to /',67x,i9)
 9503 format(6x,'data so /',67x,i9)
 9510 format(5x,'$',8x,5(f10.7,','))
 9511 format(5x,'$',8x,f10.7,'/',/'c')
 9512 format(5x,'$',8x,f10.7,',',f10.7,'/',/'c')
 9513 format(5x,'$',8x,2(f10.7,','),f10.7,'/',/'c')
 9514 format(5x,'$',8x,3(f10.7,','),f10.7,'/',/'c')
 9515 format(5x,'$',8x,4(f10.7,','),f10.7,'/',/'c')
 9521 format(6x,'data (c(',i2,',n),n=1,9)/')
 9522 format(5x,'$',9x,4(e13.7,','))
 9523 format(5x,'$',9x,e13.7,'/',/,'c')
 9531 format('c  the above coefficients were calculated using program ',
     $       '"eqstat"',
#ifdef knudsen
     $       /'c  (employing the Knudsen-Ekman equation of state)',
#else
     $       /'c  (employing the UNESCO equation of state)',
#endif
     $       /'c  and are valid for the following depths and',
     $       ' T and S ranges'/'c',t7,'k',t14,'depth',t27,'tmin',t37,
     $       'tmax',t52,'smin',t62,'smax')
 9532 format('c',t5,i3,t12,f7.2,'e2',t25,f7.3,t35,f7.3,t50,f7.4,
     $       t60,f7.4)
 9533 format('c'/'c  the 3rd order polynomial will return density ',
     $       'departures [gm/cm**3] as',/,'c  a function of',
#ifdef insitu
     $       ' insitu ',
#else
     $       ' potential ',
#endif
     $       'temperature [deg C] & salinity [model units]'/'c'
     $       /,'c       k level reference densities (in sigma units):')
 9534 format('c  ',8f8.4)
 9535 format('c')
c
      end
      subroutine knuekm (t, s, d, rho)
c=======================================================================
c     this subroutine calculates the density of seawater using the
c     Knudsen-Ekman equation of state.
c
c     input [units]:
c       in-situ temperature (t): [degrees centigrade]
c       salinity (s): [per mil]
c       depth (d): [meters of depth, to approximate pressure]
c     output [units]:
c       density (rho): sigma units
c
c     reference:
c        Fofonoff, N., The Sea: Vol 1, (ed. M. Hill). Interscience,
c          New York, 1962, pp 3-30.
c
c-----------------------------------------------------------------------
c
      implicit double precision (a-h,o-z)
c
c=======================================================================
c
      t2 = t*t
      t3 = t2*t
      s2 = s*s
      s3 = s2*s
      f1 = -1.0d0 * (t - 3.98d0)**2 * (t + 2.83d2) /
     $     (5.0357d2*(t + 6.726d1))
      f2 = t3*1.0843d-6 - t2*9.8185d-5 + t*4.786d-3
      f3 = t3*1.6670d-8 - t2*8.1640d-7 + t*1.803d-5
      fs = s3*6.76786136d-6 - s2*4.8249614d-4 + s*8.14876577d-1
c
      sigma= f1 + (fs + 3.895414d-2)*
     $      (1.0d0 - f2 + f3*(fs - 2.2584586d-1))
c
      a= d*1.0d-4*(1.055d2 + t*9.50d0 - t2*1.58d-1 - d*t*1.5d-4)  -
     $   (2.27d2 + t*2.833d1 - t2*5.51d-1 + t3*4.0d-3)
      b1 = (fs - 2.81324d1)*1.d-1
      b2 = b1 * b1
      b  = -b1* (1.473d2 - t*2.72d0 + t2*4.0d-2 - d*1.0d-4*
     $     (3.24d1 - 0.87d0*t + 2.0d-2*t2))
      b  = b + b2*(4.5d0 - 1.0d-1*t - d*1.0d-4*(1.8d0 - 6.0d-2*t))
      co = 4.886d3/(1.0d0 + 1.83d-5*d)
c
      alpha = d*1.0d-6*(co + a + b)
c
      rho = (sigma + alpha)/(1.d0 - 1.0d-3*alpha)
c
      return
      end
      subroutine lsqsl2 (ndim,a,d,w,b,x,irank,in,itmax,it,ieq,enorm,eps1
     1,nhdim,h,aa,r,s)
c
c     this routine is a modification of lsqsol. march,1968. r. hanson.
c     linear least squares solution
c
c     this routine finds x such that the euclidean length of
c     (*) ax-b is a minimum.
c
c     here a has k rows and n columns, while b is a column vector with
c     k components.
c
c     an orthogonal matrix q is found so that qa is zero below
c     the main diagonal.
c     suppose that rank (a)=r
c     an orthogonal matrix s is found such that
c     qas=t is an r x n upper triangular matrix whose last n-r columns
c     are zero.
c     the system tz=c (c the first r components of qb) is then
c     solved. with w=sz, the solution may be expressed
c     as x = w + sy, where w is the solution of (*) of minimum euclid-
c     ean length and y is any solution to (qas)y=ty=0.
c
c     iterative improvements are calculated using residuals and
c     the above procedures with b replaced by b-ax, where x is an
c     approximate solution.
c
      implicit double precision (a-h,o-z)
c
      double precision sj,dp,up,bp,aj
      logical erm
      integer d,w
c
c     in=1 for first entry.
c                   a is decomposed and saved. ax-b is solved.
c     in = 2 for subsequent entries with a new vector b.
c     in=3 to restore a from the previous entry.
c     in=4 to continue the iterative improvement for this system.
c     in = 5 to calculate solutions to ax=0, then store in the array h.
c     in  =  6   do not store a  in aa.  obtain  t = qas, where t is
c     min(k,n) x min(k,n) and upper triangular. now return.do not obtain
c     a solution.
c     no scaling or column interchanges are performed.
c     in  =  7   same as with  in = 6  except that soln. of min. length
c                is placed into x. no iterative refinement.  now return.
c     column interchanges are performed. no scaling is performed.
c     in  = 8    set addresses. now return.
c
c     options for computing  a matrix product   y*h  or  h*y are
c     available with the use of the entry points  myh and mhy.
c     use of these options in these entry points allow a great saving in
c     storage required.
c
c
      dimension a(ndim,ndim),b(1),aa(d,w),s(1), x(1),h(nhdim,nhdim),r(1)
c     d = depth of matrix.
c     w = width of matrix.
      k=d
      n=w
      erm=.true.
c
c     if it=0 on entry, the possible error message will be suppressed.
c
      if (it.eq.0) erm=.false.
c
c     ieq = 2      if column scaling by least max. column length is
c     to be performed.
c
c     ieq = 1       if scaling of all components is to be done with
c     the scalar max(abs(aij))/k*n.
c
c     ieq = 3 if column scaling as with in =2 will be retained in
c     rank deficient cases.
c
c     the array s must contain at least max(k,n) + 4n + 4min(k,n) cells
c        the   array r must contain k+4n s.p. cells.
c
      data eps2/1.d-16/
c     the last card controls desired relative accuracy.
c     eps1  controls  (eps) rank.
c
      isw=1
      l=min0(k,n)
      m=max0(k,n)
      j1=m
      j2=n+j1
      j3=j2+n
      j4=j3+l
      j5=j4+l
      j6=j5+l
      j7=j6+l
      j8=j7+n
      j9=j8+n
      lm=l
      if (irank.ge.1.and.irank.le.l) lm=irank
      if (in.eq.6) lm=l
      if (in.eq.8) return
c
c     return after setting addresses when in=8.
c
      go to (10,360,810,390,830,10,10), in
c
c     equilibrate columns of a (1)-(2).
c
c     (1)
c
   10 continue
c
c     save data when in = 1.
c
      if (in.gt.5) go to 30
      do 20 j=1,n
      do 20 i=1,k
   20 aa(i,j)=a(i,j)
   30 continue
      if (ieq.eq.1) go to 60
      do 50 j=1,n
      am=0.e0
      do 40 i=1,k
   40 am= max(am,abs(a(i,j)))
c
c      s(m+n+1)-s(m+2n) contains scaling for output variables.
c
      n2=j2+j
      if (in.eq.6) am=1.d0
      s(n2)=1.d0/am
      do 50 i=1,k
   50 a(i,j)=a(i,j)*s(n2)
      go to 100
   60 am=0.d0
      do 70 j=1,n
      do 70 i=1,k
   70 am= max(am,abs(a(i,j)))
      am=am/float(k*n)
      if (in.eq.6) am=1.d0
      do 80 j=1,n
      n2=j2+j
   80 s(n2)=1.d0/am
      do 90 j=1,n
      n2=j2+j
      do 90 i=1,k
   90 a(i,j)=a(i,j)*s(n2)
c     compute column lengths with d.p. sums finally rounded to s.p.
c
c     (2)
c
  100 do 110 j=1,n
      n7=j7+j
      n2=j2+j
  110 s(n7)=s(n2)
c
c      s(m+1)-s(m+ n) contains variable permutations.
c
c     set permutation to identity.
c
      do 120 j=1,n
      n1=j1+j
  120 s(n1)=j
c
c     begin elimination on the matrix a with orthogonal matrices .
c
c     ip=pivot row
c
      do 250 ip=1,lm
c
c
      dp=0.d0
      km=ip
      do 140 j=ip,n
      sj=0.d0
      do 130 i=ip,k
      sj=sj+a(i,j)**2
  130 continue
      if (dp.gt.sj) go to 140
      dp=sj
      km=j
      if (in.eq.6) go to 160
  140 continue
c
c     maximize (sigma)**2 by column interchange.
c
c      supress column interchanges when in=6.
c
c
c     exchange columns if necessary.
c
      if (km.eq.ip) go to 160
      do 150 i=1,k
      a1=a(i,ip)
      a(i,ip)=a(i,km)
  150 a(i,km)=a1
c
c     record permutation and exchange squares of column lengths.
c
      n1=j1+km
      a1=s(n1)
      n2=j1+ip
      s(n1)=s(n2)
      s(n2)=a1
      n7=j7+km
      n8=j7+ip
      a1=s(n7)
      s(n7)=s(n8)
      s(n8)=a1
  160 if (ip.eq.1) go to 180
      a1=0.d0
      ipm1=ip-1
      do 170 i=1,ipm1
      a1=a1+a(i,ip)**2
  170 continue
      if (a1.gt.0.d0) go to 190
  180 if (dp.gt.0.d0) go to 200
c
c     test for rank deficiency.
c
  190 if (dsqrt(dp/a1).gt.eps1) go to 200
      if (in.eq.6) go to 200
      ii=ip-1
      if (erm) write (6,1140) irank,eps1,ii,ii
      irank=ip-1
      erm=.false.
      go to 260
c
c     (eps1) rank is deficient.
c
  200 sp=dsqrt(dp)
c
c     begin front elimination on column ip.
c
c     sp=sqroot(sigma**2).
c
      bp=1.d0/(dp+sp*abs(a(ip,ip)))
c
c     store beta in s(3n+1)-s(3n+l).
c
      if (ip.eq.k) bp=0.d0
      n3=k+2*n+ip
      r(n3)=bp
      up=dsign(dble(sp)+abs(a(ip,ip)),dble(a(ip,ip)))
      if (ip.ge.k) go to 250
      ipp1=ip+1
      if (ip.ge.n) go to 240
      do 230 j=ipp1,n
      sj=0.d0
      do 210 i=ipp1,k
  210 sj=sj+a(i,j)*a(i,ip)
      sj=sj+up*a(ip,j)
      sj=bp*sj
c
c     sj=yj now
c
      do 220 i=ipp1,k
  220 a(i,j)=a(i,j)-a(i,ip)*sj
  230 a(ip,j)=a(ip,j)-sj*up
  240 a(ip,ip)=-sign(sp,a(ip,ip))
c
      n4=k+3*n+ip
      r(n4)=up
  250 continue
      irank=lm
  260 irp1=irank+1
      irm1=irank-1
      if (irank.eq.0.or.irank.eq.n) go to 360
      if (ieq.eq.3) go to 290
c
c     begin back processing for rank deficiency case
c      if irank is less than n.
c
      do 280 j=1,n
      n2=j2+j
      n7=j7+j
      l=min0(j,irank)
c
c     unscale columns for rank deficient matrices when ieq.ne.3.
c
      do 270 i=1,l
  270 a(i,j)=a(i,j)/s(n7)
      s(n7)=1.d0
  280 s(n2)=1.d0
  290 ip=irank
  300 sj=0.d0
      do 310 j=irp1,n
      sj=sj+a(ip,j)**2
  310 continue
      sj=sj+a(ip,ip)**2
      aj=dsqrt(sj)
      up=dsign(aj+abs(a(ip,ip)),dble(a(ip,ip)))
c
c     ip th element of u vector calculated.
c
      bp=1.d0/(sj+abs(a(ip,ip))*aj)
c
c     bp = 2/length of u squared.
c
      ipm1=ip-1
      if (ipm1.le.0) go to 340
      do 330 i=1,ipm1
      dp=a(i,ip)*up
      do 320 j=irp1,n
      dp=dp+a(i,j)*a(ip,j)
  320 continue
      dp=dp/(sj+abs(a(ip,ip))*aj)
c
c     calc. (aj,u), where aj=jth row of a
c
      a(i,ip)=a(i,ip)-up*dp
c
c     modify array a.
c
      do 330 j=irp1,n
  330 a(i,j)=a(i,j)-a(ip,j)*dp
  340 a(ip,ip)=-dsign(aj,dble(a(ip,ip)))
c
c     calc. modified pivot.
c
c
c     save beta and ip th element of u vector in r array.
c
      n6=k+ip
      n7=k+n+ip
      r(n6)=bp
      r(n7)=up
c
c     test for end of back processing.
c
      if (ip-1) 360,360,350
  350 ip=ip-1
      go to 300
  360 if (in.eq.6) return
      do 370 j=1,k
  370 r(j)=b(j)
      it=0
c
c     set initial x vector to zero.
c
      do 380 j=1,n
  380 x(j)=0.d0
      if (irank.eq.0) go to 690
c
c     apply q to rt. hand side.
c
  390 do 430 ip=1,irank
      n4=k+3*n+ip
      sj=r(n4)*r(ip)
      ipp1=ip+1
      if (ipp1.gt.k) go to 410
      do 400 i=ipp1,k
  400 sj=sj+a(i,ip)*r(i)
  410 n3=k+2*n+ip
      bp=r(n3)
      if (ipp1.gt.k) go to 430
      do 420 i=ipp1,k
  420 r(i)=r(i)-bp*a(i,ip)*sj
  430 r(ip)=r(ip)-bp*r(n4)*sj
      do 440 j=1,irank
  440 s(j)=r(j)
      enorm=0.d0
      if (irp1.gt.k) go to 510
      do 450 j=irp1,k
  450 enorm=enorm+r(j)**2
      enorm=sqrt(enorm)
      go to 510
  460 do 480 j=1,n
      sj=0.d0
      n1=j1+j
      ip=s(n1)
      do 470 i=1,k
  470 sj=sj+r(i)*aa(i,ip)
c
c     apply at to rt. hand side.
c     apply scaling.
c
      n7=j2+ip
      n1=k+n+j
  480 r(n1)=sj*s(n7)
      n1=k+n
      s(1)=r(n1+1)/a(1,1)
      if (n.eq.1) go to 510
      do 500 j=2,n
      n1=j-1
      sj=0.d0
      do 490 i=1,n1
  490 sj=sj+a(i,j)*s(i)
      n2=k+j+n
  500 s(j)=(r(n2)-sj)/a(j,j)
c
c     entry to continue iterating.  solves tz = c = 1st irank
c     components of qb .
c
  510 s(irank)=s(irank)/a(irank,irank)
      if (irm1.eq.0) go to 540
      do 530 j=1,irm1
      n1=irank-j
      n2=n1+1
      sj=0.
      do 520 i=n2,irank
  520 sj=sj+a(n1,i)*s(i)
  530 s(n1)=(s(n1)-sj)/a(n1,n1)
c
c     z calculated.  compute x = sz.
c
  540 if (irank.eq.n) go to 590
      do 550 j=irp1,n
  550 s(j)=0.d0
      do 580 i=1,irank
      n7=k+n+i
      sj=r(n7)*s(i)
      do 560 j=irp1,n
      sj=sj+a(i,j)*s(j)
  560 continue
      n6=k+i
      do 570 j=irp1,n
  570 s(j)=s(j)-a(i,j)*r(n6)*sj
  580 s(i)=s(i)-r(n6)*r(n7)*sj
c
c     increment for x of minimal length calculated.
c
  590 do 600 i=1,n
  600 x(i)=x(i)+s(i)
      if (in.eq.7) go to 750
c
c     calc. sup norm of increment and residuals
c
      top1=0.d0
      do 610 j=1,n
      n2=j7+j
  610 top1= max(top1,abs(s(j))*s(n2))
      do 630 i=1,k
      sj=0.d0
      do 620 j=1,n
      n1=j1+j
      ip=s(n1)
      n7=j2+ip
  620 sj=sj+aa(i,ip)*x(j)*s(n7)
  630 r(i)=b(i)-sj
      if (itmax.le.0) go to 750
c
c     calc. sup norm of x.
c
      top=0.d0
      do 640 j=1,n
      n2=j7+j
  640 top= max(top,abs(x(j))*s(n2))
c
c     compare relative change in x with tolerance eps .
c
      if (top1-top*eps2) 690,650,650
  650 if (it-itmax) 660,680,680
  660 it=it+1
      if (it.eq.1) go to 670
      if (top1.gt..25*top2) go to 690
  670 top2=top1
      go to (390,460), isw
  680 it=0
  690 sj=0.d0
      do 700 j=1,k
      sj=sj+r(j)**2
  700 continue
      enorm=dsqrt(sj)
      if (irank.eq.n.and.isw.eq.1) go to 710
      go to 730
  710 enm1=enorm
c
c     save x array.
c
      do 720 j=1,n
      n1=k+j
  720 r(n1)=x(j)
      isw=2
      it=0
      go to 460
c
c     choose best solution
c
  730 if (irank.lt.n) go to 750
      if (enorm.le.enm1) go to 750
      do 740 j=1,n
      n1=k+j
  740 x(j)=r(n1)
      enorm=enm1
c
c     norm of ax - b located in the cell enorm .
c
c
c     rearrange variables.
c
  750 do 760 j=1,n
      n1=j1+j
  760 s(j)=s(n1)
      do 790 j=1,n
      do 770 i=j,n
      ip=s(i)
      if (j.eq.ip) go to 780
  770 continue
  780 s(i)=s(j)
      s(j)=j
      sj=x(j)
      x(j)=x(i)
  790 x(i)=sj
c
c     scale variables.
c
      do 800 j=1,n
      n2=j2+j
  800 x(j)=x(j)*s(n2)
      return
c
c     restore a.
c
  810 do 820 j=1,n
      n2=j2+j
      do 820 i=1,k
  820 a(i,j)=aa(i,j)
      return
c
c     generate solutions to the homogeneous equation ax = 0.
c
  830 if (irank.eq.n) return
      ns=n-irank
      do 840 i=1,n
      do 840 j=1,ns
  840 h(i,j)=0.d0
      do 850 j=1,ns
      n2=irank+j
  850 h(n2,j)=1.d0
      if (irank.eq.0) return
      do 870 j=1,irank
      do 870 i=1,ns
      n7=k+n+j
      sj=r(n7)*h(j,i)
      do 860 k1=irp1,n
  860 sj=sj+h(k1,i)*a(j,k1)
      n6=k+j
      bp=r(n6)
      dp=bp*r(n7)*sj
      a1=dp
      a2=dp-a1
      h(j,i)=h(j,i)-(a1+2.*a2)
      do 870 k1=irp1,n
      dp=bp*a(j,k1)*sj
      a1=dp
      a2=dp-a1
  870 h(k1,i)=h(k1,i)-(a1+2.*a2)
c
c     rearrange rows of solution matrix.
c
      do 880 j=1,n
      n1=j1+j
  880 s(j)=s(n1)
      do 910 j=1,n
      do 890 i=j,n
      ip=s(i)
      if (j.eq.ip) go to 900
  890 continue
  900 s(i)=s(j)
      s(j)=j
      do 910 k1=1,ns
      a1=h(j,k1)
      h(j,k1)=h(i,k1)
  910 h(i,k1)=a1
      return
c
 1140 format (/'warning. irank has been set to',i4,'  but(',1pe10.3,
     1 ') rank is',i4,'.  irank is now taken as ',i4)
      end
      subroutine potem (t, s, p, theta)
c
c=======================================================================
c     this subroutine calculates potential temperature as a function
c     of in-situ temperature, salinity, and pressure.
c
c     input [units]:
c       in-situ temperature (t): [degrees centigrade]
c       salinity (s): [per mil]
c       pressure (p): [decibars, approx. as meters of depth]
c     output [units]:
c       potential temperature (theta): [degrees centigrade]
c
c     references:
c        based on Fofonoff and Froese (1958) as shown in ...
c        Fofonoff, N., The Sea: Vol 1, (ed. M. Hill). Interscience,
c          New York, 1962, page 17, table iv.
c
c-----------------------------------------------------------------------
c
      implicit double precision (a-h,o-z)
c
c=======================================================================
c
      b1    = -1.60d-5*p
      b2    = 1.014d-5*p*t
      t2    = t*t
      t3    = t2*t
      b3    = -1.27d-7*p*t2
      b4    = 2.7d-9*p*t3
      b5    = 1.322d-6*p*s
      b6    = -2.62d-8*p*s*t
      s2    = s*s
      p2    = p*p
      b7    = 4.1d-9*p*s2
      b8    = 9.14d-9*p2
      b9    = -2.77d-10*p2*t
      b10   = 9.5d-13*p2*t2
      b11   = -1.557d-13*p2*p
      potmp = b1+b2+b3+b4+b5+b6+b7+b8+b9+b10+b11
      theta = t-potmp
c
      return
      end
      subroutine unesco (t, s, pin, rho)
c
c=======================================================================
c     this subroutine calculates the density of seawater using the
c     standard equation of state recommended by unesco(1981).
c
c     input [units]:
c       in-situ temperature (t): [degrees centigrade]
c       salinity (s): [practical salinity units]
c       pressure (pin): [decibars, approx. as meters of depth]
c     output [units]:
c       density(rho): kilograms per cubic meter
c
c     references:
c        Gill, A., Atmosphere-Ocean Dynamics: International Geophysical
c         Series No. 30. Academic Press, London, 1982, pp 599-600.
c        UNESCO, 10th report of the joint panel on oceanographic tables
c          and standards. UNESCO Tech. Papers in Marine Sci. No. 36,
c          Paris, 1981.
c
c-----------------------------------------------------------------------
c
      implicit double precision (a-h,o-z)
c
c=======================================================================
c
      c1p5 = 1.5d0
c
c  convert from depth [m] (decibars) to bars
      p = pin * 1.0d-1
c
      rw =     9.99842594d2 + 6.793952d-2*t - 9.095290d-3*t**2
     $        + 1.001685d-4*t**3 - 1.120083d-6*t**4 + 6.536332d-9*t**5
c
      rsto =   rw + (8.24493d-1 - 4.0899d-3*t + 7.6438d-5*t**2
     $        - 8.2467d-7*t**3 + 5.3875d-9*t**4) * s
     $       + (-5.72466d-3 + 1.0227d-4*t - 1.6546d-6*t**2) * s**c1p5
     $       + 4.8314d-4 * s**2
c
      xkw =    1.965221d4 + 1.484206d2*t - 2.327105d0*t**2 +
     $         1.360477d-2*t**3 - 5.155288d-5*t**4
c
      xksto =  xkw + (5.46746d1 - 6.03459d-1*t + 1.09987d-2*t**2
     $        - 6.1670d-5*t**3) * s
     $       + (7.944d-2 + 1.6483d-2*t - 5.3009d-4*t**2) * s**c1p5
c
      xkstp =  xksto + (3.239908d0 + 1.43713d-3*t + 1.16092d-4*t**2
     $        - 5.77905d-7*t**3) * p
     $       + (2.2838d-3 - 1.0981d-5*t - 1.6078d-6*t**2) * p * s
     $       + 1.91075d-4 * p * s**c1p5
     $       + (8.50935d-5 - 6.12293d-6*t + 5.2787d-8*t**2) * p**2
     $       + (-9.9348d-7 + 2.0816d-8*t + 9.1697d-10*t**2) * p**2 * s
c
      rho =   rsto / (1.0d0 - p/xkstp)
c
      return
      end
#DECK depths.f
      subroutine depths
c      program depths
c
c     due to the simple UNIX linker, only one main program may
c     be in the directory at one time. To run this program, wipe out
c     the subroutine call & uncomment the program line. all other
c     main programs must be either removed from the directory or
c     commented out also!
c     note: this is no problem if "makefiles" are used for compiling
c           & linking.
c
c=======================================================================
c      interactive program to allow generation of model level thickness
c      file "thick.h"
c=======================================================================
c
      parameter (kmax=1000)
      implicit double precision (a-h,o-z)
      character * 1 ch
      character * 67 string
      dimension z(kmax), dzt(kmax), zw(kmax), dzw(0:kmax), thick(kmax)
      double precision fun
      fun (k,sigma,c) = dexp(-(k/sigma)**2) + c
c
      print *,' '
      print *, 'fit model level thickness "dzt(k)" to a gaussian with'
      print *, 'the following form:'
      print *,' '
      print *, 'dzt(km+1-k) = exp(-(k/sigma)**2) + offset'
      print *,' '
      print *, 'for levels k=1..km by shooting for "sigma" using a'
      print *, 'newton or secant method. the distribution can be '
      print *, 'changed by altering "offset" and the initial "sigma".'
      print *, 'for a start, try km=15 with a 30m thick 1st level'
      print *, '(only one surface level with this thickness) and'
      print *, 'a 5700m deep ocean. now try the following:'
      print *, 'offset=0.0  & sigma=5'
      print *, 'offset=0.01 & sigma=8'
      print *, 'offset=0.01 & sigma=3'
      print *,' '
      print *,' '
      print *, 'enter the number of model levels "km" ='
      read *, kmt
      print *,'enter thickness of the first level (meters) ='
      read *, dzt1
      print *,'enter number of levels with this thickness='
      read *, ktop
      km  = kmt - ktop + 1
      top = (ktop-1)*dzt1
      print *,'enter depth at the bottom of the last level (meters) ='
      read *, depth
      depth = depth - top
      print *,'enter "offset" ='
      read *, offset
      print *,'enter initial "sigma" ='
      read *, sigma
      if (depth/km .lt. dzt1) then
        print *,'no solution!  try another configuration.'
        stop
      endif
c
c     shoot for sigma using the newton method
c
      maxl = 200
      c0   = 0.0
      l    = 0
      deps = 1.e-3
c
      do 300 l=1,maxl
c
c       first guess
c
        sum = c0
        do 100 k=1,km
          dzt(km+1-k) = fun(k,sigma,offset)
          sum = sum + dzt(km+1-k)
100     continue
c
        a  = dzt1/dzt(1)
        en = depth - a*sum
c
c       2nd guess
c
        dsigma =  sigma*1.e-10
        sigmap = sigma + dsigma
        sum = c0
        do 200 k=1,km
          dzt(km+1-k) = fun(k,sigmap,offset)
          sum = sum + dzt(km+1-k)
200     continue
c
        a   = dzt1/dzt(1)
        enp = depth - a*sum
        print *,'trial shoot #=',l,' sigma=',sigmap,' error=',enp
c
c       construct new 1st guess (newton or secant method)
c
        sigma = sigmap - enp * dsigma / (enp - en)
c
        if (abs(enp) .le. deps) go to 301
300   continue
      print *,' Either there is no convergence or it is slow.'
      print *,' Try another set of inputs.'
      stop '=>done'
301   continue
c
      do 400 k=1,km
        dzt(k) = a*dzt(k)
400   continue
c
      zw(1)  = top + dzt(1)
      z(1)   = top + 0.5*dzt(1)
      dzw(0) = 0.5*dzt(1)
      do 500 k=2,km
        z(k) = z(k-1) + 0.5*(dzt(k)+dzt(k-1))
        zw(k) = zw(k-1) + dzt(k)
        dzw(k-1) = z(k) - z(k-1)
500   continue
c
      print *,' '
      print *,'gaussian fit for dzt(km+1-k) k=',ktop,'..',kmt
      print *,'dzt(km+1-k) = exp(-(k/',sigmap,')**2)+',offset
      print *,' '
      write (6,'(1x,a3,a10,3a15)') 'k','z(k)','zw(k)','dzt(k)','dzw(k)'
      do 600 k=1,kmt
        if (k .lt. ktop) then
          dzw1 = dzt1
          thick(k) = dzt1
          if (k .eq. 1) dzw1 = 0.5*dzt1
          write (6,'(1x,i3,4(1x,g14.7))') k,
     1      (k-0.5)*dzt1, k*dzt1, dzt1, dzw1
        else
          m = k - ktop + 1
          thick(k) = dzt(m)
          if (m .eq. 1) dzw(m-1) = 2.0*dzw(m-1)
          write (6,'(1x,i3,4(1x,g14.7))') k, z(m), zw(m), dzt(m),
     $    dzw(m-1)
        endif
600   continue
c
      print *,' do you want to produce a "thick.h" file ? (y/n)'
      print *,' (note: this will write over any old "thick.h" file)'
      read (*,'(a1)') ch
      if (ch .eq. 'Y' .or. ch .eq. 'y') then
        open (unit=40, file='thick.h')
c
c       write sample thick.h file "dzt" data statements
c
        ks = 1
        ke = ks + 4
        ke = min(kmt,ke)
        write(40,1958) (thick(k),k=1,ke)
        do 700 ii=1,99
          ks = ks + 5
          if (ks .gt. kmt) goto 701
          ke = ks + 4
          ke = min(kmt,ke)
          write(40,1959) (thick(k),k=ks,ke)
          write(string,1959) (thick(k),k=ks,ke)
700     continue
701     continue
c
c       remove trailing comma from last line if present. note: string
c       is character*67 to match format 1959.
c
        do 800 l=67,7,-1
          if (string(l:l) .ne. ',' .and. string(l:l) .ne. ' ') go to 801
          if (string(l:l) .eq. ',') then
            string(l:l) = ' '
            backspace 40
            write (40,'(a67)') string
          endif
800     continue
801     continue
c
        write(40,1960) km, sigmap, offset, dzt1, ktop, zw(km)
        write(40,1961)
c
1958  format('c====================== include file "thick.h" ',
     $   '========================',/
     $   'c     specifications for box thickness (cm) in the vertical'/
     $   ,'c     produced by program "depths.f"'/
     $   ,'c'/'      data dzt /'f8.2,'e2',4(',',f8.2,'e2'))
1959  format('     $      ',5(',',f8.2,'e2'))
1960  format('     $   /',/,'c'/
     $   'c     dzt = model level thicknesses computed as',/
     $   'c     dzt(km+1-k)=exp(-(k/sigma)**2) + offset) for k=1,km',/,
     $   'c      km =',i4,/
     $   'c      sigma=',g14.7,/
     $   'c      offset=',g14.7,/
     $   'c      1st level thickness =',g14.7,/
     $   'c      # of levels with this thickness =',i3,/
     $   'c      depth at bottom of last level =',g14.7)
1961  format('c'/)
c
        close(40)
      endif
      stop
      end
#DECK diag.F
      subroutine diag (j)
cfpp$ noconcur r
c
c=======================================================================
c
c     initialize, calculate & printout of diagnostics
c
c=======================================================================
c
#include "param.h"
#ifdef biharmonic
# include "cbihar.h"
#endif
#ifdef testcfl
# include "ccfl.h"
#endif
#include "cdiag.h"
#include "chmix.h"
#ifdef isopycmix
# include "cisop.h"
#endif
#include "coord.h"
#ifdef nlhmix
# include "cnlmix.h"
#endif
#include "cprnts.h"
#include "cregin.h"
#include "ctmngr.h"
#include "cvbc.h"
#include "cvmix.h"
#include "docnam.h"
#include "emode.h"
#include "grdvar.h"
#include "iounit.h"
#include "levind.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
c
      if (j .eq. 1) then
c
        write (stdout,9300) ' MOM"s diagnostic calculations for ts ='
     $,  itt, stamp
c
c-----------------------------------------------------------------------
c       initialize various quantities when j = 1
c-----------------------------------------------------------------------
c
#ifdef testcfl
        cflup = c0
        cflvp = c0
        cflwp = c0
#endif
        do 100 n=1,nt
          ustf(n,1) = ' unknown  '
          ustf(n,2) = ' unknown units '
          if (n .eq. 1) then
            ustf(n,1) = ' stf(1)   = '
            ustf(n,2) = ' cal/cm**2/sec '
          endif
          if (n .eq. 2) then
           ustf(n,1) = ' stf(2)   = '
           ustf(n,2) = ' cm**2/sec     '
          endif
100     continue
        do 200 k=0,km
          buoy(k) = c0
200     continue
        do 300 ll=1,8
          do 290 k=0,km
            engint(k,ll) = c0
290       continue
300     continue
        do 400 ll=1,8
          engext(ll) = c0
          do 390 i=1,imt
            zuseng(i,ll) = c0
            zvseng(i,ll) = c0
390       continue
400     continue
c
        do 500 n=0,numreg
          if (n .gt. 0) then
            avwv(1,n) = c0
            avwv(2,n) = c0
            avwv(3,n) = c0
            do 450 ll=1,13
              do 440 k=0,km
                termbm(k,ll,1,n) = c0
                termbm(k,ll,2,n) = c0
440           continue
450         continue
          endif
          do 490 m=1,nt
            atwv(m,n) = c0
            do 460 k=0,km
              tvar(k,m,n) = c0
460         continue
            do 480 ll=1,8
              do 470 k=0,km
                termbt(k,ll,m,n) = c0
470           continue
480         continue
490       continue
500     continue
        do 520 n=0,nhreg
          smflx(1,n) = c0
          smflx(2,n) = c0
          do 510 m=1,nt
            stflx(m,n) = c0
            asst(m,n)  = c0
510       continue
520     continue
c
        do 600 jj=1,jmt
          do 580 m=1,ntmin2
            do 570 ll=1,8
              ttn(ll,jj,m) = c0
570         continue
580       continue
          do 590 k=1,km
            tmt(jj,k)=c0
590       continue
600     continue
c
      elseif (j .lt. jmt) then
c
c-----------------------------------------------------------------------
c       print the solution at specified latitudes
c-----------------------------------------------------------------------
c
        do 700 jlat=1,nlatpr
          jj = indp (prlat(jlat), yt, jmt)
          if (jj .eq. j .and. prlat(jlat) .le. yt(jmt)) then
            if (jlat .eq. 1) write(stdout,9000)
            is = indp (prslon(jlat), xt, imt)
            ie = indp (prelon(jlat), xt, imt)
            ks = indp (prsdpt(jlat), zt, km)
            ke = indp (predpt(jlat), zt, km)
            fx = 1.0e-2
            do 680 m=1,nt
              scl = c1
              if (m .eq. 2) scl=1.e-3
              write (stdout,9100) trname(m), itt
     $,        j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
              call matrix (t(1,1,jc,nc,m), imt, is, ie, ks, ke, scl)
680         continue
#ifdef cyclic
c
c           set cyclic boundary condition on w before printing
c
            do 690 k=0,km
              w(1  ,k) = w(imtm1,k)
              w(imt,k) = w(2    ,k)
690         continue
#endif
            scl = 1.e-3
            write (stdout,9100)  'w velocity', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (w, imt, is, ie, ks, ke, scl)
c
            scl = c1
            write (stdout,9100) 'u velocity', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (u(1,1,jc,nc), imt, is, ie, ks, ke, scl)
c
            scl = c1
            write (stdout,9100) 'v velocity', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (v(1,1,jc,nc), imt, is, ie, ks, ke, scl)
          endif
700     continue
c
c-----------------------------------------------------------------------
c       compute the northward transport of each tracer quantity
c       as well as the zonally integrated meridional mass transport
c-----------------------------------------------------------------------
c
c    the following cfpp$ directive fixes a bug in fpp on the cray
c
cfpp$ novector r
        if(j .lt. jmtm1) then
          do 800 k=1,km
            vbr(k)=c0
            do 790 m=1,nt
              tbrs(k,m)=tbrn(k,m)
              tbrn(k,m)=c0
790         continue
800       continue
          if(j.gt.2) go to 900
          do 890 m=1,nt
            do 880 k=1,km
              tbrs(k,m)=c0
880         continue
890       continue
          do 870 k=1,km
            totdx=c0
            do 860 i=2,imtm1
              totdx=totdx+dxt(i)*fm(i,k,jc)
              do 850 m=1,nt
                tbrs(k,m)=tbrs(k,m)+t(i,k,jc,nc,m)*fm(i,k,jc)*dxt(i)
850           continue
860         continue
            if(totdx.ne.c0) then
              do 840 m=1,nt
                tbrs(k,m)=tbrs(k,m)/totdx
840           continue
            endif
870       continue
900       continue
          ccttj = asubh*dyur(j)
          do 1000 k=1,km
            totdx=c0
            do 990 i=2,imtm1
              totdx=totdx+dxt(i)*fm(i,k,jp)
              vbr(k)=vbr(k)+v(i,k,jc,nc)*dxu(i)*csu(j)
              do 980 m=1,nt
                tbrn(k,m)=tbrn(k,m)+t(i,k,jp,nc,m)*fm(i,k,jp)*dxt(i)
980           continue
990         continue
            if(totdx.ne.c0) then
              do 970 m=1,nt
                tbrn(k,m)=tbrn(k,m)/totdx
970           continue
            endif
            if(k.eq.1) tmt(j,1)=vbr(1)*dzt(1)
            if(k.gt.1) tmt(j,k)=tmt(j,k-1)+vbr(k)*dzt(k)
            do 960 m=1,nt
              ttn(1,j,m)=ttn(1,j,m)+vbr(k)*(tbrn(k,m)+tbrs(k,m))*
     $                   p5*dzt(k)
              do 950 i=2,imtm1
                ttn(6,j,m)=ttn(6,j,m)+
     $                  (v(i,k,jc,nc)*dxu(i)+v(i-1,k,jc,nc)*dxu(i-1))*
     $             (t(i,k,jc,nc,m)+t(i,k,jp,nc,m))*csu(j)*p25*dzt(k)
#ifdef isopycmix
                ttn(7,j,m)=ttn(7,j,m)-
     $              esav(i,k,m)*fm(i,k,jc)*fm(i,k,jp)*dxt(i)*dzt(k)
#else
# ifdef biharmonic
                ttn(7,j,m)=ttn(7,j,m)-ccttj*fm(i,k,jc)*fm(i,k,jp)*
     $             (del2(i,k,m,jpt3)-del2(i,k,m,jpt2))*dxt(i)*csu(j)
     $             *dzt(k)
# endif
# ifdef nlhmix
                ttn(7,j,m)=ttn(7,j,m)-(cctj(i,k)/cct(j))*dyur(j)
     $                     *fm(i,k,jc)*fm(i,k,jp)*
     $             (t(i,k,jp,nc,m)-t(i,k,jc,nc,m))*dxt(i)*csu(j)*dzt(k)
# endif
# ifdef consthmix
                ttn(7,j,m)=ttn(7,j,m)-ccttj*fm(i,k,jc)*fm(i,k,jp)*
     $             (t(i,k,jp,nc,m)-t(i,k,jc,nc,m))*dxt(i)*csu(j)*dzt(k)
# endif
#endif
950           continue
960         continue
1000      continue
          do 1100 m=1,nt
            do 1090 i=2,imtm1
              totdz=c0
              vbrz=c0
              tbrz=c0
              do 1080 k=1,km
                if (kmt(i,j) .ge. k .and. kmt(i,j+1) .ge. k) then
                  vbrz=vbrz+(v(i,k,jc,nc)*dxu(i)+v(i-1,k,jc,nc)*
     $                       dxu(i-1))*dzt(k)
                  tbrz=tbrz+(t(i,k,jc,nc,m)+t(i,k,jp,nc,m))*dzt(k)
                  totdz=totdz+dzt(k)
                endif
1080          continue
              if(totdz.eq.c0) go to 1070
                tbrz=tbrz/totdz
                ttn(3,j,m)=ttn(3,j,m)+vbrz*tbrz*csu(j)*p25
                ttn(5,j,m)=ttn(5,j,m)-(smf(i,1)*dxu(i)+smf(i-1,1)*
     $                    dxu(i-1))*(t(i,1,jc,nc,m)+t(i,1,jp,nc,m)-
     $                    tbrz)*csu(j)/
     $                    (8.0*omega*sine(j))
1070          continue
1090        continue
1100      continue
          do 1200 m=1,nt
            ttn(2,j,m)=ttn(6,j,m)-ttn(1,j,m)
            ttn(4,j,m)=ttn(6,j,m)-ttn(3,j,m)-ttn(5,j,m)
            ttn(8,j,m)=ttn(6,j,m)+ttn(7,j,m)
1200      continue
        endif
      endif
c
      return
9000  format(/' Zonal section printouts at specified latitudes:'/)
9100  format(1x,a12,1x,'ts=',i10,1x,',j=',i3,', lat=',f6.2
     $,', lon:',f6.2,' ==> ',f6.2,', depth(m):',f6.1,' ==> ',f6.1
     $,', scaling=',1pg10.3)
9300  format(//25x,a39,i10,a33//)
      end
#DECK diag2.F
      subroutine diag2
cfpp$ noconcur r
c
c=======================================================================
c
c     calculate & print diagnostics outside parallel region
c
c=======================================================================
c
#include "param.h"
#ifdef testcfl
# include "ccfl.h"
#endif
#include "cdiag.h"
#include "chmix.h"
#include "coord.h"
#include "cprnts.h"
#include "cregin.h"
#include "ctmngr.h"
#include "cvbc.h"
#include "cvmix.h"
#include "docnam.h"
#include "emode.h"
#include "grdvar.h"
#include "iounit.h"
#include "levind.h"
#include "scalar.h"
#include "switch.h"
c
#if defined congrad5pt || defined congrad9pt
c
c     spx   = the x change (longitudinal) in surface pressure
c             spx(i,j) is defined midway between xu(i) & xu(i+1)
c     spy   = the y change (latitudinal) in surface pressure
c             spy(i,j) is defined midway between yu(j) & yu(j+1)
c     sperr = the closed line integral around a "t" grid box
c             it is a measure of the error in reconstructing the
c             surface pressure.
c
c             note: the actual surface pressure is not reconstructed
c                   here. it can be constructed by assuming an
c                   arbitrary value at some "u" point on the grid and
c                   and adding "spx" & "spy" along paths to build
c                   surface pressure values relative to the arbitrary
c                   starting value.
c                   under the congrad5pt option, the error is due to
c                   "crit" & truncation due to the 5 pt operator. under
c                   the congrad9pt, the error is due only to "crit"
c                   and so may be reduced by reducing "crit" & setting
c                   "mxscan" so that convergence is reached.
c
c
      dimension scrx(imt), scry(imt)
      dimension spx(imt,jmt), spy(imt,jmt), sperr(imt,jmt)
      equivalence (spx,res), (spy,fdir), (sperr,gdir)
#endif
c
c-----------------------------------------------------------------------
c     complete and print the integrals, transports & stream function
c-----------------------------------------------------------------------
c
c     add in the external mode part of d/dt for the momentum balance
c     also add in the external mode part of the implicit coriolis term
c     and compute the surface pressure gradients
c
#if defined congrad5pt || defined congrad9pt
c
c       initialize surface pressure gradient fields
c
        do 100 j=1,jmt
          do 90 i=1,imt
            spx(i,j) = c0
            spy(i,j) = c0
90        continue
100     continue
#endif
c
        fxa = c1
c
c       on mixing time steps "ptd" has been multiplied by a factor of 2
c       and the time step has to be adjusted also.
c
        if (mod(itt,nmix) .eq. 1) then
          fxa = p5
        endif
        r2dtuv = c1/c2dtuv
        do 200 j=1,jmt-1
          fddt  = csu(j)*dyu(j)/c2dtuv
          fspr  = csu(j)*dyu(j)
          atosp = acor*c2*omega*sine(j)
          f1    = atosp*csu(j)*dyu(j)
          f2    = atosp*c2dtuv
          f3    = c2dtuv/c2dtsf
          do 190 i=2,imtm1
            kz = kmu(i,j)
            if (kz .ne. 0) then
              diag1 = p(i+1,j+1,1)-p(i  ,j,1)
              diag0 = p(i  ,j+1,1)-p(i+1,j,1)
              uext  = -(diag1+diag0)*dyu2r(j)*hr(i,j)
              vext  =  (diag1-diag0)*dxu2r(i)*hr(i,j)*csur(j)
              diag3 = fxa*(ptd(i+1,j+1)-ptd(i  ,j))
              diag4 = fxa*(ptd(i  ,j+1)-ptd(i+1,j))
              dubdt = (diag3+diag4)*dyu2r(j)*hr(i,j)
              dvbdt = (diag3-diag4)*dxu2r(i)*hr(i,j)*csur(j)
              surfpx   = r2dtuv*( dubdt + f3*zu(i,j) + f2*dvbdt)
              surfpy   = r2dtuv*(-dvbdt + f3*zv(i,j) + f2*dubdt)
#if defined congrad5pt || defined congrad9pt
              spx(i,j)   = surfpx
              spy(i,j)   = surfpy
#endif
              do 180 k=1,kz
                n = nhreg*(mskvr(k)-1) + mskhr(i,j)
                if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                  boxfac = fddt*dxu(i)*dzt(k)
                  boxspr = fspr*dxu(i)*dzt(k)
                  boxacr = f1*dxu(i)*dzt(k)
                  termbm(k,1,1,n)  = termbm(k,1,1,n)  + uext*boxfac
                  termbm(k,1,2,n)  = termbm(k,1,2,n)  + vext*boxfac
                  termbm(k,10,1,n) = termbm(k,10,1,n) + vext*boxacr
                  termbm(k,10,2,n) = termbm(k,10,2,n) - uext*boxacr
                  termbm(k,12,1,n) = termbm(k,12,1,n) - surfpx*boxspr
                  termbm(k,12,2,n) = termbm(k,12,2,n) - surfpy*boxspr
                endif
180           continue
            endif
190       continue
200     continue
#if defined congrad5pt || defined congrad9pt
c
c       construct spatial changes in surface pressure
c
        do 300 j=1,jmt-1
          do 280 i=2,imtm1
            scrx(i)  = p5*(spx(i,j) + spx(i+1,j))*csu(j)*dxt(i+1)
            scry(i)  = p5*(spy(i,j) + spy(i,j+1))*dyt(j+1)
280       continue
#ifdef cyclic
          scrx(1)   = scrx(imtm1)
          scrx(imt) = scrx(2)
          scry(1)   = scry(imtm1)
          scry(imt) = scry(2)
#else
          scrx(1)   = c0
          scrx(imt) = c0
          scry(1)   = c0
          scry(imt) = c0
#endif
          do 290 i=1,imt
            spx(i,j)   = scrx(i)
            sperr(i,j) = scry(i)
290       continue
300     continue
        do 320 j=1,jmt-1
          do 310 i=1,imt
            spy(i,j) = sperr(i,j)
310       continue
320     continue
        do 330 i=1,imt
            spy(i,jmt) = spy(i,jmt-1)
            spx(i,jmt) = spx(i,jmt-1)
330     continue
c
c       do closed line integrals around boxes. since the closed line
c       integral of a gradient should be zero, this is a measure
c       of the error involved in reconstructing the surface pressure
c       from its gradients.
c
        do 350 j=1,jmt-1
          do 340 i=2,imtm1
            sperr(i,j) = spy(i+1,j) - spy(i,j)
     $                - (spx(i,j+1) - spx(i,j))
340       continue
350     continue
c
c-----------------------------------------------------------------------
c       print a sample of the surface pressure components
c-----------------------------------------------------------------------
c
c       show only a subset to keep print file from getting too large
c
        is = indp (140.0, xt, imt)
        ie = indp (160.0, xt, imt)
        js = indp (-85.0, yt, jmt)
        je = indp (-30.0, yt, jmt)
        write (stdout,'(/a50)')
     $     ' Sample longitudinal change in surface pressure '
        scl = 1000.0
        write (stdout,8000) ' spx '
     $,    itt, xt(is), xt(ie), yt(js), yt(je), scl
        call matrix (spx, imt, is, ie, -js, -je, scl)
        write (stdout,'(a50)')
     $     ' Sample latitudinal change in surface pressure '
        scl = 1000.0
        write (stdout,8000) ' spy'
     $,    itt, xt(is), xt(ie), yt(js), yt(je), scl
        call matrix (spy, imt, is, ie, -js, -je, scl)
        write (stdout,'(a60)')
     $     ' Sample closed line integral of surface pressure gradient'
        scl = 0.01
        write (stdout,8000) ' surf press error'
     $,    itt, xt(is), xt(ie), yt(js), yt(je), scl
        call matrix (sperr, imt, is, ie, -js, -je, scl)
#endif
#ifdef testcfl
c
c       monitor velocities by showing which come closest to the
c       CFL condition
c
        write (stdout,'(/60x,a12/)') ' CFL summary'

        write (stdout,'(a21,g10.3,a5,f7.2,a10,/a25,i4,a1,i4,a1,i3,a1
     $,                 3x,a18,f7.2,a1,f7.2,a1,f7.0,a1)')
     $   ' maximum U velocity (',cflum,') is ',cflup,' % the CFL'
     $,  ' at location: (i,j,k) = (',icflu,',',jcflu,',',kcflu,')'
     $,  ' (lon,lat,dpt) = (',xu(icflu),',',yu(jcflu),',',zt(kcflu),')'

        write (stdout,'(a21,g10.3,a5,f7.2,a10,/a25,i4,a1,i4,a1,i3,a1
     $,                 3x,a18,f7.2,a1,f7.2,a1,f7.0,a1)')
     $   ' maximum V velocity (',cflvm,') is ',cflvp,' % the CFL'
     $,  ' at location: (i,j,k) = (',icflv,',',jcflv,',',kcflv,')'
     $,  ' (lon,lat,dpt) = (',xu(icflv),',',yu(jcflv),',',zt(kcflv),')'
        write (stdout,'(a21,g10.3,a5,f7.2,a10,/a25,i4,a1,i4,a1,i3,a1
     $,                 3x,a18,f7.2,a1,f7.2,a1,f7.0,a1)')
     $   ' maximum W velocity (',cflwm,') is ',cflwp,' % the CFL'
     $,  ' at location: (i,j,k) = (',icflw,',',jcflw,',',kcflw,')'
     $,  ' (lon,lat,dpt) = (',xu(icflw),',',yu(jcflw),',',zw(kcflw),')'
        write (stdout,'(/58x,a16/)') ' end CFL summary'
#endif
c
c
c       integrate previously computed integrals vertically
c
        do 1300 k=km,1,-1
          buoy(0) = buoy(0) + buoy(k)
1300    continue
        do 1400 ll=1,8
          do 1390 k=km,1,-1
            engint(0,ll) = engint(0,ll) + engint(k,ll)
1390      continue
1400    continue
        do 1500 n=0,numreg
          if (n .gt. 0) then
            nv = (n-1)/nhreg + 1
            ks = llvreg(nv,1)
            ke = llvreg(nv,2)
            do 1420 ll=1,13
              do 1410 k=ke,ks,-1
                termbm(0,ll,1,n) = termbm(0,ll,1,n) + termbm(k,ll,1,n)
                termbm(0,ll,2,n) = termbm(0,ll,2,n) + termbm(k,ll,2,n)
1410          continue
1420        continue
          else
            ks = 1
            ke = km
          endif
          do 1480 m=1,nt
            do 1440 k=ke,ks,-1
              tvar(0,m,n) = tvar(0,m,n) + tvar(k,m,n)
1440        continue
            do 1470 ll=1,8
              do 1460 k=ke,ks,-1
                termbt(0,ll,m,n) = termbt(0,ll,m,n) + termbt(k,ll,m,n)
1460          continue
1470        continue
1480      continue
1500    continue
c
c       normalize integrals by appropriate volume
c
        buoy(0) = buoy(0)/volume
        do 1600 ll=1,8
          engint(0,ll) = engint(0,ll)/volume
          engext(ll)   = engext(ll)/volume
1600    continue
        do 1700 n=0,numreg
          do 1690 m=1,nt
            tvar(0,m,n) = tvar(0,m,n)/volt(n)
            atwv(m,n)   = atwv(m,n)/volt(n)
            if (n .le. nhreg)  then
              stflx(m,n) = stflx(m,n)/volt(n)
              asst(m,n)  = asst(m,n)/areat(n)
            endif
            do 1680 ll=1,8
              termbt(0,ll,m,n) = termbt(0,ll,m,n)/volt(n)
1680        continue
1690      continue
1700    continue
        do 1800 n=0,numreg
          if (n .le. nhreg) then
            smflx(1,n) = smflx(1,n)/volu(n)
            smflx(2,n) = smflx(2,n)/volu(n)
          endif
          if (n .gt. 0) then
            avwv(1,n) = avwv(1,n)/volu(n)
            avwv(2,n) = avwv(2,n)/volu(n)
            avwv(3,n) = avwv(3,n)/volu(n)
            do 1790 ll=1,13
              termbm(0,ll,1,n) = termbm(0,ll,1,n)/volu(n)
              termbm(0,ll,2,n) = termbm(0,ll,2,n)/volu(n)
1790        continue
          endif
1800    continue
c
c       2nd, compute residual terms
c
        plicin = engint(0,1) - engint(0,2) - engint(0,3) - engint(0,4)
     $         - engint(0,5) - engint(0,6)
        plicex = engext(1) - engext(2) - engext(3) - engext(4)
     $         - engext(5) - engext(6)
c
c       3rd, print the integrals
c
        write (stdout,9100)
     $                   'Globally averaged (entire ocean) Energetics'
     $,                     ' for ts =', itt, stamp, volu(0), areau(0)
        write (stdout,9101) ' time rate of change ',engint(0,1)
     $,                      engint(0,1), engext(1), engext(1)
        write (stdout,9101) ' horizontal advection', engint(0,2)
     $,                      engint(0,2), engext(2), engext(2)
        write (stdout,9101) ' vertical advection  ',engint(0,3)
     $,                      engint(0,3), engext(3), engext(3)
        write (stdout,9101) ' horizontal friction ',engint(0,4)
     $,                      engint(0,4), engext(4), engext(4)
        write (stdout,9101) ' vertical friction   ',engint(0,5)
     $,                      engint(0,5), engext(5), engext(5)
        write (stdout,9101) ' pressure forces     ',engint(0,6)
     $,                      engint(0,6), engext(6), engext(6)
        write (stdout,9101) ' ficticious sources  ',plicin
     $,                       plicin, plicex, plicex
        write (stdout,9101) ' work by wind        ',engint(0,7)
     $,                      engint(0,7), engext(7), engext(7)
        write (stdout,9101) ' bottom drag         ',engint(0,8)
     $,                      engint(0,8), engext(8), engext(8)
        buoerr = buoy(0) - engint(0,6) - engext(6)
        enleak = engint(0,2) + engint(0,3) + engext(2) + engext(3)
        write (stdout,9110) buoy(0), buoy(0), buoerr, buoerr, enleak
     $,                     enleak
c
        if (iotrmb .ne. stdout) then
          write (stdout, '(/a35,i4,a9,i10,a33/)')
     $    ' ==> Term balances written to unit ', iotrmb,' for ts ='
     $,   itt, stamp
        endif
        n = 0
        taux = smflx(1,n)*volu(n)/areau(n)
        tauy = smflx(2,n)*volu(n)/areau(n)
        write (iotrmb,10106)
     $                   'Globally averaged (entire ocean) quantities'
     $,                     ' for ts =', itt, stamp, volt(n), areat(n)
     $,                     volu(0), areau(n)
        write (iotrmb,10104)
        write (iotrmb,10098) n, ' smf(1)   = ', taux,' dynes/cm**2   '
        write (iotrmb,10098) n, ' smf(2)   = ', tauy,' dynes/cm**2   '
        do 1810 m=1,nt
          write (iotrmb,10098) n, ustf(m,1), stflx(m,n)*volt(n)/areat(n)
     $,                        ustf(m,2)
1810    continue
        write (iotrmb,10098) n, ' tot heat = ', (atwv(1,n)*volt(n))
     $,                                        ' deg C * cm**3 '
        write (iotrmb,10098) n, ' sst      = ',asst(1,n)
     $,                                       ' deg C         '
c
        do 1900 n=0,numreg
          if (n .eq. 1) then
            write (iotrmb,10050)
     $  'Regional averaged Momentum & Tracer Term Balances for ts =   '
     $,     itt, stamp
          endif
          iv = 0
          if (n .gt. 0) then
            iv = (n-1)/nhreg + 1
            ih = n - (iv-1)*nhreg
            write (iotrmb,10100) 'Momentum terms averaged over region #'
     $,          n, ': ', hregnm(ih), vregnm(iv), volu(n), areau(n)
            write (iotrmb,10104)
            write (iotrmb,10101) n,' dU/dt   = ', termbm(0,1,1,n)
     $,                            ' dV/dt   = ', termbm(0,1,2,n)
            write (iotrmb,10101) n,' -Px     = ', termbm(0,2,1,n)
     $,                            ' -Py     = ', termbm(0,2,2,n)
            write (iotrmb,10101) n,' -surf Px= ', termbm(0,12,1,n)
     $,                            ' -surf Py= ', termbm(0,12,2,n)
            write (iotrmb,10101) n,' -UUx    = ', termbm(0,3,1,n)
     $,                            ' -UVx    = ', termbm(0,3,2,n)
            write (iotrmb,10101) n,' -VUy    = ', termbm(0,4,1,n)
     $,                            ' -VVy    = ', termbm(0,4,2,n)
            write (iotrmb,10101) n,' -WUz    = ', termbm(0,5,1,n)
     $,                            ' -WVz    = ', termbm(0,5,2,n)
            write (iotrmb,10101) n,'  UVtan  = ', termbm(0,13,1,n)
     $,                            ' -UUtan  = ', termbm(0,13,2,n)
#ifdef biharmonic
            write (iotrmb,10101) n,'  Uxxxx  = ', termbm(0,6,1,n)
     $,                            '  Vxxxx  = ', termbm(0,6,2,n)
            write (iotrmb,10101) n,'  Uyyyy  = ', termbm(0,7,1,n)
     $,                            '  Vyyyy  = ', termbm(0,7,2,n)
#else
            write (iotrmb,10101) n,'  Uxx    = ', termbm(0,6,1,n)
     $,                            '  Vxx    = ', termbm(0,6,2,n)
            write (iotrmb,10101) n,'  Uyy    = ', termbm(0,7,1,n)
     $,                            '  Vyy    = ', termbm(0,7,2,n)
#endif
            write (iotrmb,10101) n,'  Uzz    = ', termbm(0,8,1,n)
     $,                            '  Vzz    = ', termbm(0,8,2,n)
            write (iotrmb,10101) n,'  metric = ', termbm(0,9,1,n)
     $,                            '  metric = ', termbm(0,9,2,n)
            write (iotrmb,10101) n,'  fV     = ', termbm(0,10,1,n)
     $,                            ' -fU     = ', termbm(0,10,2,n)
            write (iotrmb,10101) n,'  source = ', termbm(0,11,1,n)
     $,                            '  source = ', termbm(0,11,2,n)
            erru = c0
            errv = c0
            do 1870 lll=2,13
              erru = erru + termbm(0,lll,1,n)
              errv = errv + termbm(0,lll,2,n)
1870        continue
            write (iotrmb,10101) n,'  error  = ', termbm(0,1,1,n) - erru
     $,                            '  error  = ', termbm(0,1,2,n) - errv
            write (iotrmb,10101) n,'  ubar   = ', avwv(1,n)
     $,                            '  vbar   = ', avwv(2,n)
     $,                            '  wbar   = ', avwv(3,n)
          endif
          if (iv .eq. 1) then
            write (iotrmb,10101) n,'  surf Uz= ', smflx(1,n)
     $,                            '  surf Vz= ', smflx(2,n)
          endif
c
          if (n .eq. 0) then
            write (iotrmb,10051)
     $   'Global averaged (entire ocean) Tracer Term Balances for ts = '
     $,     itt, stamp
          else
            write (iotrmb,10100) 'Tracer terms averaged over region   #'
     $,          n, ': ', hregnm(ih), vregnm(iv), volt(n), areat(n)
          endif
c
          do 1880 m=1,nt
            dchg            = termbt(0,2,m,n) + termbt(0,3,m,n) +
     $                        termbt(0,4,m,n) + termbt(0,5,m,n) +
     $                        termbt(0,6,m,n) + termbt(0,7,m,n) +
     $                        termbt(0,8,m,n)
            tconv(m)        = termbt(0,1,m,n) - dchg
1880      continue
          maxm = (nt-1)/7 + 1
          do 1890 mloop=1,maxm
            ms = (mloop-1)*7 + 1
            me = min(ms + 6,nt)
            write (iotrmb,10103) (trname(m),m=ms,me)
            write (iotrmb,10102) n,' dT/dt   = ', (termbt(0,1,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,' -UTx    = ', (termbt(0,2,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,' -VTy    = ', (termbt(0,3,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,' -WTz    = ', (termbt(0,4,m,n)
     $,                                           m=ms,me)
#if defined biharmonic && !defined isopycmix
            write (iotrmb,10102) n,'  Txxxx  = ', (termbt(0,5,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,'  Tyyyy  = ', (termbt(0,6,m,n)
     $,                                           m=ms,me)
#else
# ifdef isopycmix
            write (iotrmb,10102) n,'  Tisox  = ', (termbt(0,5,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,'  Tisoy  = ', (termbt(0,6,m,n)
     $,                                           m=ms,me)
# else
            write (iotrmb,10102) n,'  Txx    = ', (termbt(0,5,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,'  Tyy    = ', (termbt(0,6,m,n)
     $,                                           m=ms,me)
# endif
#endif
            write (iotrmb,10102) n,'  Tzz    = ', (termbt(0,7,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,'  source = ', (termbt(0,8,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,'  convect= ', (tconv(m)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,'  chg var= ', (tvar(0,m,n)
     $,                                           m=ms,me)
            write (iotrmb,10102) n,'  tbar   = ', (atwv(m,n)
     $,                                           m=ms,me)
            if (iv .eq. 1) then
              write (iotrmb,10102) n,'  surflx = ', (stflx(m,n)
     $,                                           m=ms,me)
              taux = smflx(1,n)*volu(n)/areau(n)
              tauy = smflx(2,n)*volu(n)/areau(n)
              write (iotrmb,10105) ' Regionally averaged quantities:'
              write (iotrmb,'(1x)')
              write (iotrmb,10098) n
     $,          ' smf(1)   = ', taux,' dynes/cm**2   '
              write (iotrmb,10098) n
     $,          ' smf(2)   = ', tauy,' dynes/cm**2   '
              do 1820 m=1,nt
                write (iotrmb,10098) n
     $,          ustf(m,1), stflx(m,n)*volt(n)/areat(n), ustf(m,2)
1820          continue
              if (ms .eq. 1) then
                write (iotrmb,10098) n
     $,          ' tot heat = ', (atwv(1,n)*volt(n)),' deg C * cm**3 '
                write (iotrmb,10098) n
     $,          ' sst      = ', asst(1,n),' deg C         '
              endif
            endif
1890      continue
1900    continue
c
c-----------------------------------------------------------------------
c       print the northward transport of heat and salt
c-----------------------------------------------------------------------
c
        write (stdout,8195)
c
c       convert heat transport to petawatts,
c       salt trnspt to 10**10 cm**3/sec
c
        do 2000 l=1,jmt
          do 1990 ll=1,8
            ttn(ll,l,1)=ttn(ll,l,1)*4.186e-15
            ttn(ll,l,2)=ttn(ll,l,2)*1.e-10
1990      continue
2000    continue
        do 2100 j=2,jmtm2
          l=jmt-j
          write (stdout,8196) l, (ttn(i,l,1),i=1,8), (ttn(i,l,2),i=1,8)
2100    continue
        scl = 1.e12
        write (stdout,8194) scl
        js = indp (slatxy, yt, jmt)
        je = indp (elatxy, yt, jmt)
        call matrix (tmt, jmt, js, je, 1, km, scl)
c
c-----------------------------------------------------------------------
c       print the stream function
c-----------------------------------------------------------------------
c
        scl=1.e12
        is = indp (slonxy, xt, imt)
        ie = indp (elonxy, xt, imt)
        js = indp (slatxy, yt, jmt)
        je = indp (elatxy, yt, jmt)
        write (stdout,8000) ' stream function (sverdrups)'
     $, itt, xt(is), xt(ie), yt(js), yt(je), scl
        call matrix (p(1,1,1), imt, is, ie, -js, -je, scl)
c
      return
8000  format(1x,a27,1x,'ts=',i7
     $,', lon:',f6.2,' ==> ',f6.2,',   lat:',f6.2,' ==> ',f6.2
     $,', scaling=',1pg10.3)
9100  format(///,1x,13('**********')
     $/1x,a43,a9,i10,a33/1x,'ocean volume =',e16.9,' cm**3'
     $, ', ocean surface area =',e16.9,' cm**2'//' work by:',14x
     $,     'internal mode                         external mode'/)
9101  format(a21,2(1pe15.6, ' (',z16,' hex)'))
9110  format(/' work by buoyancy forces =',1pe14.6, ' (',z16,' hex)'/
     $,      ' energy conversion error =',1pe14.6, ' (',z16,' hex)'/
     $,      ' nonlinear exchange error=',1pe14.6, ' (',z16,' hex)'/)
10050 format(///,1x,13('**********'),/1x,a61,i10,a33/)
10051 format(///,1x,a61,i10,a33/)
10098 format(1x,'(',i4,')',a12,(1pe16.8,a15))
10100 format(/1x,a37,i5,a2,a40,a20/1x,'ocean volume =',e16.9,' cm**3'
     $, ', horizontal ocean area =',e16.9,' cm**2'/)
10101 format(1x,'(',i4,')',a11,1pe15.7, 2x, a11,1pe15.7, 2x, a11
     $,      1pe15.7)
10102 format(1x,'(',i4,')',a11,7(1pe15.7))
10103 format(' Region',11x,8a15)
10104 format(' Region')
10105 format(/8x,a32)
10106 format(///,1x,13('**********')
     $/1x,a43,a9,i10,a33/1x,'ocean "t" volume =',e16.9,' cm**3 '
     $, ', ocean "t" surface area =',e16.9,' cm**2 '
     $/ 1x,'ocean "u" volume =',e16.9,' cm**3, '
     $, ' ocean "u" surface area =',e16.9,' cm**2'/)
8195  format(/,6x,'northward transport of heat (x10**15 watts)'
     $       ,22x,'northward transport of salt (x10**10 cm**3/sec)',/,
     $       3x,2(3x,'x mean  x eddy  z mean  z eddy   ekman tot adv  ',
     $       'diffus   total'))
8196  format(i4,8f8.3,1x,8f8.3)
8194  format(/,' meridional mass transport: scaling=',g10.3)
      end
#DECK docmnt.F
            subroutine docmnt (nunit, wrdoc, wrc0, wrc1, wrc2)
c
c=======================================================================
c
c     This code arranges data to be written out as a form of
c     documentation summarizing the model characteristics that
c     uniquely define this run.
c     In order to reap the full benefits of this feature, the user will
c     need to review this routine when configuring a model run or adding
c     new options to the code.
c     We envision this feature as being beneficial to those setting up
c     new model runs, comparing different model runs, and for analysis
c     purposes (much of the information used in setting up mapping
c     procedures and other analysis products are contained in the
c     data written by this routine).
c
c     Five namelist writes are available.  Which ones are written
c     is determined from the 4 logical variables passed into the
c     subroutine (wrdoc, wrc0, wrc1, & wrc2).  The unit to which
c     they are written is set by "nunit".
c
c     If "wrdoc" is true, then the "ndocs" & "docums" namelists
c     are written...
c       The 1st, "ndocs" simply contains one variable (ndoc); the
c     dimension of "docum(ndoc)" found in the 2nd namelist write.
c       The 2nd, "docums" consists of a series of 60 character-long
c     lines of information the user should use to list the variables
c     in the subsequent namelist writes, and to describe the model
c     run in general.
c
c     If "wrc0" is true, then the "cntrl0" namelist is written...
c       Namelist "cntrl0" contains the 2 variables needed to restart
c     the model (itt, years).
c
c       The "cntrl1" and "cntrl2" namelists contain information
c     describing the model's configuration and specifications.
c
c     If "wrc1" is true, then the "cntrl1" namelist is written...
c       "cntrl1" contains variables (non-dimensioned) that will be
c     common to most, if not all, incarnations of the model code.
c
c     If "wrc2" is true, then the "cntrl2" namelist is written...
c       "cntrl2" is intended to contain the larger (dimensioned)
c     data that will help identify the model specifics to users
c     and analysis programs alike.
c
c=======================================================================
c
#include "param.h"
#include "accel.h"
#include "chmix.h"
#ifdef isopycmix
#include "cisop.h"
#endif
#include "coord.h"
#include "cregin.h"
#include "ctmngr.h"
#include "cvmix.h"
#include "docnam.h"
#include "index.h"
#include "scalar.h"
#ifdef restorst
#include "slabs.h"
#endif
#include "switch.h"
#include "versno.h"
c
c   "ndocum" is the number of 60 character lines of documentation in
c      docum(ndocum)" describing the model written by namelist.
c   "ifdmax" is the maximum number of 12 character ifdef options (in
c      (dimension of "cifdef") that may be listed as being set in the
c       control block (both ifdmax & the 12-character length can be
c       user specified)
c   "nifdef" is the actual number of ifdef options that are set.
c
      parameter (ndocum = 16)
      parameter (ifdmax = 50)
c
      character * 60 docum(ndocum)
      character * 60 expnam
      character * 12 cifdef(ifdmax), blnk12
c
c   the logical variables "wrdoc, wrc0, wrc1, &  wrc2" let the user
c   set which namelists are to be written to unit "nunit".
c
      logical wrdoc, wrc0, wrc1, wrc2
c
      namelist /ndocs / ndoc
c
      namelist /docums/ docum
c
      namelist /cntrl0/
     $     itt, years
c
      namelist /cntrl1/
     $      expnam, tyear, tmonth, tday, thour, tmin, tsec, relyr
     $     ,time0, julian, yrnorm, yrleap, nleap
     $     ,dtts, dtuv, dtsf, init, nmix, eb, acor, am, ah, fkph, fkpm
#ifdef isopycmix
     $     ,ahisop, slmxr
#endif
     $     ,id, jd, kd, ntrace, lsegs, nisl, area, volume
     $     ,nhorr, nverr, ntreg, ifdmx, nifdef
#ifdef fourfil
     $     ,lsegsf, jfrst, jft0, jft1, jft2, jfu0, jfu1, jfu2
#endif
#ifdef firfil
     $     ,numflt, numflu, jfrst, jft0, jft1, jft2, jfu0, jfu1, jfu2
#endif
#ifdef restorst
     $     ,rests
#endif
c
      namelist /cntrl2/
     $     xt, yt, xu, yu, zt
     $     ,trname, cifdef, hregnm, mskhr, vregnm, mskvr
#ifdef islands
     $     ,alonis, alatis
#endif
     $     ,dtxcel
#ifdef firfil
     $     ,numflt, numflu
#endif
c
      save nifdef, cifdef
c
      data (docum(n),n=1,ndocum)
     1   /'namelist  cntrl0 = itt, years                               '
     2   ,'namelist  cntrl1 =                                          '
     3   ,' expnam, tyear, tmonth, tday, thour, tmin, tsec, relyr      '
     4   ,',time0, julian, yrnorm, yrleap, nleap                       '
     5   ,',dtts, dtuv, dtsf, init, nmix, eb, acor, am, ah fkph, fkpm  '
#ifdef isopycmix
     6   ,',ahisop, slmxr                                              '
#else
     6   ,'==> isopycmix not set <===                                  '
#endif
     7   ,',id, jd, kd, ntrace, lsegs, nisl, area, volume              '
     8   ,',nhorr, nverr, ntreg, ifdmx, nifdef                         '
#ifdef fourfil
     9   ,',lsegsf, jfrst, jft0, jft1, jft2, jfu0, jfu1, jfu2          '
#endif
#ifdef firfil
     9   ,',numflt, numflu, jfrst, jft0, jft1, jft2, jfu0, jfu1, jfu2  '
#endif
#ifndef firfil
#  ifndef fourfil
     9   ,' ==> no filtering set <===                                  '
#  endif
#endif
#ifdef restorst
     $   ,',rests                                                      '
#else
     $   ,'==> restorst not set <===                                   '
#endif
     1   ,'namelist  cntrl2 =                                          '
     2   ,'xt(id), yt(jd), xu(id), yu(jd), zt(kd)                      '
     3   ,'trname, cifdef, hregnm, mskhr, vregnm, mskvr                '
#ifdef islands
     4   ,',alonis(nisl), alatis(nisl)                                 '
#else
     4   ,' ==> islands ifdef not set <==                              '
#endif
     5   ,',dtxcel(km)                                                 '
#ifdef firfil
     6   ,',numflt(jmtfil), numflu(jmtfil)                             '
#else
     6   ,' ==> firfil not set  <===                                   '
#endif
     $    /
      data blnk12 /'            '/
c
c     The experiment name is defaulted to the MOM version info here
c
      expnam = model
c
c     User specified tracer names are placed into "trname" here.
c
      do 100 m=1,nt
        trname(m) = '**unknown***'
100   continue
      trname(1) = 'potentl temp'
      trname(2) = 'salinity    '
c
c-----------------------------------------------------------------------
c     list options that are in effect on first timestep
c-----------------------------------------------------------------------
c
      if (first) then
c
        write (stdout,9001)
        write (stdout,9002)
        write (stdout,9003)
        write (stdout,9004)
        write (stdout,9005)
        write (stdout,9006)
c
c     set ifdef list for control block info.
c     (maximum count set in parameter "ifdmax")
c
        blnk12 = '            '
        do 200 n=1,ifdmax
          cifdef(n) = blnk12
200     continue
c
        nifdef = 0
        cifdef(1) = '0 ifdefs set'
c
        write (stdout,'(/,a45)')
     $   ' The following "ifdef" options are in effect:'
#ifdef multitasking
        nifdef = nifdef + 1
        cifdef(nifdef) = 'multitasking'
#endif
#ifdef timing
        nifdef = nifdef + 1
        cifdef(nifdef) = 'timing      '
#endif
#ifdef cyclic
        nifdef = nifdef + 1
        cifdef(nifdef) = 'cyclic      '
#endif
#ifdef skipland
        nifdef = nifdef + 1
        cifdef(nifdef) = 'skipland    '
#endif
#ifdef symmetry
        nifdef = nifdef + 1
        cifdef(nifdef) = 'symmetry    '
#endif
#ifdef firfil
        nifdef = nifdef + 1
        cifdef(nifdef) = 'firfil      '
        write (stdout,*) ' note ==> firfil not fully checked out yet'
#endif
#ifdef fourfil
        nifdef = nifdef + 1
        cifdef(nifdef) = 'fourfil     '
#endif
#ifdef freesfc
        nifdef = nifdef + 1
        cifdef(nifdef) = 'freesfc     '
        write (stdout,*) ' stop ==> free surface not implemented yet'
        if (nifdef .lt. 10000) stop '2 docum'
#endif
#ifdef rigidlid
        nifdef = nifdef + 1
        cifdef(nifdef) = 'rigidlid    '
#  ifdef islands
        nifdef = nifdef + 1
        cifdef(nifdef) = 'islands     '
#  endif
#  ifdef congrad5pt
        nifdef = nifdef + 1
        cifdef(nifdef) = 'congrad5pt  '
#  endif
#  ifdef congrad9pt
        nifdef = nifdef + 1
        cifdef(nifdef) = 'congrad9pt  '
#  endif
#  ifdef oldrelax
        nifdef = nifdef + 1
        cifdef(nifdef) = 'oldrelax    '
#  endif
#  ifdef hypergrid
        nifdef = nifdef + 1
        cifdef(nifdef) = 'hypergrid   '
#  endif
#endif
#ifdef implicitvmix
        nifdef = nifdef + 1
        cifdef(nifdef) = 'implicitvmix'
#endif
#ifdef nohilats
        nifdef = nifdef + 1
        cifdef(nifdef) = 'nohilats    '
#endif
#ifdef testcfl
        nifdef = nifdef + 1
        cifdef(nifdef) = 'testcfl     '
#endif
#ifdef isopycmix
        nifdef = nifdef + 1
        cifdef(nifdef) = 'isopycmix   '
        write (stdout,*) ' warning ==> isopycmix not fully checked'
#endif
#ifdef consthmix
        nifdef = nifdef + 1
        cifdef(nifdef) = 'consthmix   '
#endif
#ifdef biharmonic
        nifdef = nifdef + 1
        cifdef(nifdef) = 'biharmonic  '
        write (stdout,*) ' warning ==> biharmonic not fully checked'
#endif
#ifdef nlhmix
        nifdef = nifdef + 1
        cifdef(nifdef) = 'nlhmix  '
        write (stdout,*) ' warning ==> nlhmix not fully checked'
#endif
#ifdef ppvmix
        nifdef = nifdef + 1
        cifdef(nifdef) = 'ppvmix      '
        write (stdout,*) ' warning ==> ppvmix not fully checked out yet'
#endif
#ifdef tcvmix
        nifdef = nifdef + 1
        cifdef(nifdef) = 'tcvmix      '
        write (stdout,*) ' warning ==> tcvmix not fully checked out yet'
#endif
#ifdef leq
        nifdef = nifdef + 1
        cifdef(nifdef) = 'leq         '
        write (stdout,*) ' warning ==> leq not fully checked out yet'
#endif
#ifdef lalg
        nifdef = nifdef + 1
        cifdef(nifdef) = 'lalg        '
        write (stdout,*) ' warning ==> lalg not fully checked out yet'
#endif
#ifdef readrmsk
        nifdef = nifdef + 1
        cifdef(nifdef) = 'readrmsk  '
#endif
#ifdef restorst
        nifdef = nifdef + 1
        cifdef(nifdef) = 'restorst    '
#endif
#ifdef keepterms
        nifdef = nifdef + 1
        cifdef(nifdef) = 'keepterms   '
#endif
#ifdef constvmix
        nifdef = nifdef + 1
        cifdef(nifdef) = 'constvmix   '
#endif
#ifdef diskless
        nifdef = nifdef + 1
        cifdef(nifdef) = 'diskless    '
#endif
#ifdef  crayio
        nifdef = nifdef + 1
        cifdef(nifdef) = 'crayio      '
#endif
#ifdef fio
        nifdef = nifdef + 1
        cifdef(nifdef) = 'fio         '
#endif
        nn = (nifdef+4)/5
        do 300 i=1,nn
          ns = 1+(5*(i-1))
          ne = ns + 4
          if (ne .gt. nifdef) ne = nifdef
          write (stdout,9101) (cifdef(n),n=ns,ne)
300     continue
        write (stdout,'(a21,/)') ' end of options list.'
      endif
c
c-----------------------------------------------------------------------
c     Values set in parameter statements will be stored in local
c     variable names, to allow them to be written out as namelist.
c-----------------------------------------------------------------------
c
      if (wrdoc) then
        ndoc = ndocum
        write (nunit,ndocs)
        write (nunit,docums)
      endif
c
      if (wrc0) then
        write (nunit,cntrl0)
      endif
c
      if (wrc1) then
        id = imt
        jd = jmt
        kd = km
        ntrace = nt
        lsegs = lseg
        nisl = nisle
        ifdmx = ifdmax
        nhorr = nhreg
        nverr = nvreg
        ntreg = numreg
#ifdef fourfil
        lsegsf = lsegf
#endif
        write (nunit,cntrl1)
      endif
c
      if (wrc2) then
        write (nunit,cntrl2)
      endif
c
      return
c
9001  format(/' The following "ifdef" options are available:'
     $  /' =========================================================='
     $ //'     >> optimization options <<'
     $ //' multitasking=allows parallelism at the latitude row level'
     $  /'               (for cray only ...not fully optimized yet!)'
     $  /'               (answers check but no ssread/sswrite yet)'
     $  /' skipland   = do calculations only over ocean segments'
     $  /'              (otherwise ... do from 2 ..imt-1)'
     $  /' timing     = gives cp & wall clock for calls to step'
     $  /'               (for cray only)'
     $ //'     >> grid options <<'
     $ //' cyclic     = east-west cyclic conditions are set'
     $  /'              (otherwise assume solid walls in east & west)'
     $  /' symmetry   = symmetry conditions set at northern boundary'
     $  /'              (otherwise assume a solid wall)'
     $ //'     >> filtering options <<'
     $ //' firfil     = use finite impulse response filter at high lats'
     $  /' fourfil    = perform Fourier filtering at high latitudes'
     $   )
9002  format(/'     >> external mode velocity options <<'
     $ //' freesfc    = free surface model (no relaxation needed)'
     $  /'               (not implemented yet!)'
     $  /' rigidlid   = use relaxation method for barotropic mode'
     $  /'  islands   = include islands in relaxation topography'
     $  /'  congrad5pt= preconditioned conjugate gradient scheme'
     $  /'                (recommended over oldrelax & hypergrid)'
     $  /'  congrad9pt= preconditioned conjugate gradient scheme'
     $  /'                (the most accurate poisson solver.)'
     $  /'                (uses a 9pt laplacian. Allows for a more)'
     $  /'                (accurate surface pressure reconstruction)'
     $  /'  oldrelax  = original sequential relaxation'
     $  /'  hypergrid = successive over-relaxation on diagonals'
     $   )
9003  format(/'     >> vertical mixing scheme options <<'
     $ //' implicitvmix= implicit treatment of vertical mixing'
     $  /'               (otherwise assume explicit treatment)'
     $  /' constvmix  = constant vertical mixing'
     $  /' ppvmix     = Pacanowski-Philander vertical mixing'
     $  /'               (not fully checked out yet. user beware !)'
     $  /' gargettmix = Gargett vertical mixing'
     $  /'               (not implemented yet!)'
     $  /' tcvmix     = turbulence closure vertical mixing'
     $  /'               (not fully checked out yet. user beware !)'
     $  /'   leq        = macro length scale from differential eqn'
     $  /'               (not fully checked out yet. user beware !)'
     $  /'   lalg       = macro length scale from algebraic relation'
     $  /'               (not fully checked out yet. user beware !)'
     $  /' windvmix   = modified Krauss-Turner wind-forced mixing'
     $  /'               (not implemented yet!)'
     $   )
9004  format(/'     >> horizontal mixing scheme options <<'
     $  //' consthmix  = constant horizontal mixing del**2'
     $  /' isopycmix  = orient tracer diffusion along isopycnals'
     $  /'               (not fully checked out yet. user beware !)'
     $  /' biharmonic = bi-harmonic horizontal mixing del**4'
     $  /'               (not fully checked out yet. user beware !)'
     $  /' nlhmix     = non-linear horizontal mixing'
     $  /'               (not fully checked out yet. user beware !)'
     $   )
9005  format(/'     >> i/o options <<'
     $ //' diskless   = simulate disk storage using memory array'
     $  /' crayio     = getwa & putwa i/o for now'
     $  /' fio        = fortran direct access i/o'
     $   )
9006  format(/'     >> miscellaneous options <<'
     $ //' readrmsk   = read in region info from file "regionmasks"'
     $  /' restorst   = restore surface tracers to prescribed values'
     $  /'              via newtonain damping'
     $  /' testcfl    = monitors velocities & checks for cfl violations'
     $  /' keepterms  = use arrays (instead of statement functions) to'
     $  /'              retain terms in momentum and tracer equations'
     $  /' nohilats   = no advective metric terms in the momentum'
     $  /'              equations.(ie: tropical model domains)'
     $  /' =========================================================='
     $   )
9101  format(5(3x,a12))
c
      end
#DECK filfir.F
      subroutine filfir (t, f, s, kl, kind, num)
#ifdef firfil
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c     simple finite impulse response filter with [.25, .5, .25] weights
c     (shapiro) modified for assymetric and symmetric boundaries
c
c     inputs:
c             t    = (imt,kl) array of quantity to be filtered along
c                    the first dimension.
c                    note: t(i,k) must be zero where f(i,k) = zero
c                    for this filter to work.
c             f    = (imt,kl) mask of zeroes & ones to indicate land
c                    and ocean. zero indicates a land point
c             s    = (imt,kl) scratch array
c             kl   = number of vertical levels to filter
c             kind = (0,1) = (symmetric, asymmetric) boundary condition
c                    symmetric is appropriate for tracers & vorticity
c                    asymmetric is appropriate for velocities
c             num  = number of times to apply this filter
c
c     outputs:
c             t    = (imt,km) array of filtered quantities
c-----------------------------------------------------------------------
c
#include "param.h"
c
      dimension t(imt,kl), f(imt,kl), s(imt,kl)
c
c=======================================================================
c
      if (kind .eq. 0) then
c
c-----------------------------------------------------------------------
c       apply the filter "num" times using a symmetric (no flux)
c       boundary condition
c-----------------------------------------------------------------------
c
#ifdef cyclic
        do 100 k=1,kl
          t(1,k)   = t(imtm1,k)
          t(imt,k) = t(2,k)
100     continue
#endif
        do 200 n=1,num
c
c         each filtering consists of a double pass
c
          do 190 k=1,kl
            do 170 i=2,imtm1
              s(i,k) = f(i,k)*(p25*(t(i-1,k) + t(i+1,k)) +
     $                 t(i,k)*(c1 - p25*(f(i-1,k) + f(i+1,k))))
170         continue
#ifdef cyclic
            s(1,k)   = s(imtm1,k)
            s(imt,k) = s(2,k)
#endif
            do 180 i=2,imtm1
              t(i,k) = f(i,k)*(p25*(s(i-1,k) + s(i+1,k)) +
     $                 s(i,k)*(c1 - p25*(f(i-1,k) + f(i+1,k))))
180         continue
#ifdef cyclic
            t(1,k)   = t(imtm1,k)
            t(imt,k) = t(2,k)
#endif
190       continue
200     continue
      elseif (kind .eq. 1) then
c
c----------------------------------------------------------------------
c       apply the filter "num" times using an asymmetric (flux)
c       boundary condition
c----------------------------------------------------------------------
c
#ifdef cyclic
        do 300 k=1,kl
          t(1,k)   = t(imtm1,k)
          t(imt,k) = t(2,k)
300     continue
#endif
        do 400 n=1,num
c
c         each filtering consists of a double pass
c
          do 390 k=1,kl
            do 370 i=2,imtm1
              s(i,k) = f(i,k)*(p25*t(i-1,k) + p5*t(i,k) + p25*t(i+1,k))
370         continue
#ifdef cyclic
            s(1,k)   = s(imtm1,k)
            s(imt,k) = s(2,k)
#endif
            do 380 i=2,imtm1
              t(i,k) = f(i,k)*(p25*s(i-1,k) + p5*s(i,k) +p25*s(i+1,k))
380         continue
#ifdef cyclic
            t(1,k)   = t(imtm1,k)
            t(imt,k) = t(2,k)
#endif
390       continue
400     continue
      else
        write (stderr,99) kind
        stop ' filfir '
      endif
c
99    format(/' error => kind =',i10, ' in filfir')
c
#endif
      return
      end
#DECK filt.F
      subroutine filt (j)
#if defined fourfil || defined firfil
#  ifdef multitasking
cfpp$ noconcur r
#  endif
c
c=======================================================================
c     subroutine filt sets up input needed for fourier filtering
c     (when the "fourfil" ifdef is defined) -or- symmetric finite
c     impulse response filtering (when the "firfil" ifdef is defined)
c     of tracers at the specifiied high latitude row "j".
c=======================================================================
c
#include "param.h"
#include "grdvar.h"
#include "index.h"
#include "levind.h"
#include "slabs.h"
#include "temp.h"
c
#  ifdef fourfil
c
c---------------------------------------------------------------------
c     fourier filter tracers at high latitudes
c---------------------------------------------------------------------
c
      if((j.gt.jft1.and.j.lt.jft2) .or. j.lt.jfrst) goto 101
      jj=j-jfrst+1
      if (j.ge.jft2) jj=jj-jskpt+1
c
c    if previous strips were of same length, do not recompute
c    fourier coeffs
c
      isave=0
      ieave=0
      do 100 l=1,lsegf
        do 90 k=1,km
          if(istf(jj,l,k).eq.0) go to 90
          is=istf(jj,l,k)
          ie=ietf(jj,l,k)
          iredo=0
          if(is.ne.isave .or. ie.ne.ieave) then
            iredo=-1
            isave=is
            ieave=ie
            im=ie-is+1
#    ifdef cyclic
            if(im.ne.imtm2.or.kmt(1,j).lt.k) then
              m=1
              n=nint(im*cst(j)*cstr(jft0))
            else
              m=3
              n=nint(im*cst(j)*cstr(jft0)*0.5)
            endif
#    else
            m=1
            n=nint(im*cst(j)*cstr(jft0))
#    endif
          endif
          do 80 mm=1,nt
            idx=iredo+mm
            ism1=is-1
            iea=ie
            if(ie.ge.imt) iea=imtm1
            do 40 i=is,iea
              tempik(i-ism1,k,1)=ta(i,k,mm)
40          continue
            if(ie.ge.imt) then
              ieb=ie-imtm2
              ii=imtm1-is
              do 50 i=2,ieb
                tempik(i+ii,k,1)=ta(i,k,mm)
50            continue
            endif
c
            call filtr (tempik(1,k,1),im,m,n,idx)
c
            do 60 i=is,iea
              ta(i,k,mm)=tempik(i-ism1,k,1)
60          continue
            if(ie.ge.imt) then
              do 70 i=2,ieb
                ta(i,k,mm)=tempik(i+ii,k,1)
70            continue
            endif
80       continue
90      continue
100   continue
101   continue
#  endif
#  ifdef firfil
c
c-----------------------------------------------------------------------
c     filter tracers at high latitudes with symmetric finite impulse
c     response filter "fir"
c-----------------------------------------------------------------------
c
      if ((j .le. jft1 .or. j .ge. jft2) .and. j .ge. jfrst) then
        jj = j - jfrst + 1
        if (j .ge. jft2) jj = jj - jskpt + 1
        numfil = numflt(jj)
        do 200 mm=1,nt
          call filfir (ta(1,1,mm), fm(1,1,jc), tempik(1,1,1), km, 0,
     $                 numfil)
200     continue
      endif
#  endif
c
#endif
      return
      end
#DECK filtr.F
      subroutine filtr (s, im, mm, n, iss)
#ifdef fourfil
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c                                                                    ===
c  filter fourier analyses the arrays of various                     ===
c         physical quantities, then truncates the series and         ===
c         resynthesizes the filtered quantities where:               ===
c             s  =the string to be filtered                          ===
c             im =the length of s                                    ===
c             mm =1 (cosine series, deriv at bndry pts=0)            ===
c                =2 (  sine series,          bndry pts=0)            ===
c                =3 (full series, cyclic)                            ===
c             n  =number of waves to keep                            ===
c             iss=0 (cant use fourier coefs from previous call)      ===
c             iss>0 (can  use fourier coefs from previous call)      ===
c                                                                    ===
c=======================================================================
c
c---------------------------------------------------------------------
c     define global data
c---------------------------------------------------------------------
c
#include "param.h"
#include "switch.h"
c
c---------------------------------------------------------------------
c     define local data and dimension argument arrays
c---------------------------------------------------------------------
c
      parameter (imtx2=imt*2,ni=imt)
      parameter (imtd2=imt/2,lqmsum=imtd2*(imt-imtd2),lhsum=imt*imtp1/2)
      parameter (imtx4=imt*4,imtx8=imt*8,imtimt=imt*imt)
      parameter (imp1x2=imtp1*2)
c
c     cossav must remain full precision if most of filter is made half-p
      real cossav
c
      dimension icbase(imtp1),idbase(imtp1),ind(imtx8),temp(imtx4)
      dimension cossav(lqmsum),denmsv(lhsum),cosnpi(imt)
      dimension circle(4)
      dimension indx(imtx8),cof(imtx8)
      dimension cosine(imtx8),ftarr(imtimt)
      dimension denom(imtx4)
      dimension s(imt),sprime(imt)
#ifndef multitasking
#define task
#endif
      task common /cfiltr/ ind,  denmsv, idbase, cossav, icbase, cosnpi
     $,     imsave, ftarr, jbase, ibase
      common/cfilt1/  circle, pi
c
c
c
      data pi/3.141592653589793/, circle/0.,-1.,0.,1./
c
c---------------------------------------------------------------------
c  begin executable code
c---------------------------------------------------------------------
c
      if (im.lt.1 .or. mm.lt.1 .or. mm.gt.3 .or. n.lt.0 .or. iss.lt.0)
     $  then
        write (stdout,99) im, mm, n, iss
        write (stderr,99) im, mm, n, iss
        stop ' filtr 1'
      endif
c
      if (first) then
c
c       this section sets up tables for filter; it must be called once
c       per execution of ocean
c
c       note: lqmsum is the sum of (im-1)/2 for im=1,imtp1
c             lhsum is the sum of im-1 for im=1,imtp1
c
        imsave = im
c
c       assemble index array
c
        do 100 i=1,imtx8
          ind(i) = i
100     continue
c
c       calculate and save all cosines which will be needed
c
        ibase = 0
        jbase = 0
c
        do 200 im=1,imtp1
          fimr = c1/float(im)
          imm1 = im-1
          if (imm1.eq.0) goto 181
          do 180 i=1,imm1
            denmsv(ibase+i) = c1/(c1-cos(pi*float(i)*fimr))
180       continue
181       continue
          idbase(im) = ibase
          ibase = ibase + imm1
          imqc = (im-1)/2
          if (imqc .eq. 0) goto 191
          do 190 i=1,imqc
            cossav(jbase+i) = cos(pi*float(i)*fimr)
190       continue
191       continue
          icbase(im) = jbase
          jbase = jbase + imqc
200     continue
c
c       calculate adjustments for general fourier case if im=2*n
c
        do 300 im=1,imt
          cosnpi(im) = circle(mod(im-1,4)+1)
300     continue
c
        im = imsave
      endif
c
c     calculate some useful constants
c
      if(mm.eq.2 .and. n.eq.0) then
c
        do 400 i=1,im
          s(i) = c0
400     continue
c
        goto 3201
      endif
c
      if (mm .eq. 1) then
        nmax = n - 1
      else
        nmax = n
      endif
c
      nmaxp1 = nmax + 1
      cc1 = p5*float(nmax) + p25
      cc2 = float(nmax) + p5
c
      if (mm .eq. 2) then
        lcy   = 2*(im + 1)
        fnorm = c2/float(im + 1)
      else
        lcy   = 2*im
        fnorm = c2/float(im)
      endif
c
      lh    = lcy/2
      lhm1  = lh - 1
      lqm   = (lh - 1)/2
      l2cy  = 2*lcy
      lcym1 = lcy - 1
      lcyp1 = lcy + 1
      imx2  = im*2
      imx4  = im*4
      imx8  = im*8
c
c     average incoming array
c
      ssum = c0
c
      do 500 i=1,im
        ssum = ssum + s(i)
500   continue
c
c     mm = 1  derivative must be zero at boundaries (cosine)
c     mm = 2  value must be zero at boundaries (sine)
c     mm = 3  cyclic boundary conditions (general fourier series)
c
      fim   = float(im)
      fimr  = c1/fim
      stemp = ssum*fimr
c
      if (n.gt.1 .or. mm.ne.1) goto 601
c
      do 600 i=1,im
        s(i)=stemp
600   continue
c
      go to 3201
601   continue
c
      if (mm .ne. 2) then
c
        do 700 i=1,im
          s(i) = s(i) - stemp
700     continue
c
      endif
c
      if (iss .gt. 0) goto 2501
c
c     assemble appropriate 1-cycle (2*pi) cosine array
c
c     use stored 1/4 cycle to calculate first 1/2 cycle
c
      jbase = icbase(lh)
c
      do 800 i=1,lqm
        cosine(i) = cossav(jbase+i)
800   continue
c
      do 900 i=1,lqm
        cosine(lh-i) = -cossav(jbase+i)
900   continue
c
c     fill in cos(pi/2) if lh is even
c
      if (2*(lqm+1) .eq. lh) cosine(lqm+1) = c0
c
c     fill in cos(pi) in any case
c
      cosine(lh) = -c1
c
c     fill in rest of cycle
c
      do 1000 i=1,lh
        cosine(lh+i) = -cosine(i)
1000  continue
c
c     assemble denominator array
c
      ibase = idbase(lh)
c
      do 1100 i=1,lhm1
        denom(i) = p25*denmsv(ibase+i)
1100  continue
c
      denom(lh) = 0.125
c
      do 1200 i=1,lhm1
        temp(i) = denom(lh-i)
1200  continue
c
      do 1300 i=1,lhm1
        denom(lh+i) = temp(i)
1300  continue
c
      nprint = 0
      denom(lcy) = c0
c
      do 1400 i=lcyp1,imx4
        denom(i) = denom(i-lcy)
1400  continue
c
c     assemble appropriate subscript arrays
c
c     calculate needed indices
c
      if (mm.eq.3) then
        fact1 = 2*nmax
        fact2 = 2*nmaxp1
      else
        fact1 = nmax
        fact2 = nmaxp1
      endif
c
      do 1500 i=1,imx4
        indx(i) = ind(i)*fact1
1500  continue
c
      do 1600 i=1,imx4
        indx(imx4+i) = ind(i)*fact2
1600  continue
c
c     calculate parameters for reducing indices
c
      maxind = imx4*fact2
      ncyc   = (maxind-1)/lcy + 1
      maxndx = lcy
      if (maxndx .ge. maxind) goto 1801
c
      do 1700 npwr=1,ncyc+2
        maxndx = 2*maxndx
        if (maxndx .ge. maxind) goto 1701
1700  continue
c
      write (stdout,999)
      write (stderr,999)
      stop ' filtr 2'
c
1701  continue
c
      do 1800 np=1,npwr
        maxndx = maxndx/2
        do 1790 i=1,imx8
          if (indx(i) .gt. maxndx) indx(i) = indx(i) - maxndx
1790    continue
1800  continue
c
1801  continue
c
c     gather coefficients
c
      do 1900 j=1,imx8
        cof(j) = cosine(indx(j))
1900  continue
c
c     assemble transformation array which will filter s
c
      if(mm.eq.1) then
c
c       cosine transform
c
        ioff1 = lcy
        ioff2 = lcy + imx4
c
        do 2000 j=1,im
          joff = (j-1)*imt
          do 1990 i=1,im
            ftarr(joff+i) =
     $         (cof(i-j+ioff1) - cof(i-j+ioff2)) *denom(i-j+ioff1) +
     $         (cof(i + j - 1) - cof(imx4+i+j-1))*denom(i+j-1) - p5
1990      continue
2000    continue
c
        do 2100 j=1,im
          ftarr(j*imtp1-imt) = ftarr(j*imtp1-imt) + cc1
2100    continue
c
      elseif (mm .eq. 2) then
c
c       sine transform
c
        ioff1 = lcy
        ioff2 = lcy + imx4
c
        do 2200 j=1,im
          joff = (j-1)*imt
          do 2190 i=1,im
            ftarr(joff+i) =
     $         (cof(i-j+ioff1) - cof(i-j+ioff2))*denom(i-j+ioff1) -
     $         (cof(i + j)     - cof(imx4+i+j)) *denom(i+j)
2190      continue
2200    continue
c
        do 2300 j=1,im
          ftarr(j*imtp1-imt) = ftarr(j*imtp1-imt) + cc1
2300   continue
c
      else if(mm.eq.3) then
c
c       general fourier transform
c
        if (2*n .eq. im) then
          genadj = p5
        else
          genadj = c0
        endif
c
        ioff1 = lcy
        ioff2 = lcy + imx4
c
        do 2400 j=1,im
          joff = (j-1)*imt
          do 2390 i=1,im
            ftarr(joff+i) = (c2*(cof(i-j+ioff1) - cof(i-j+ioff2)))
     $          *denom(2*i-2*j+ioff1) - p5 - genadj*cosnpi(i)*cosnpi(j)
2390      continue
2400    continue
c
        do 2500 j=1,im
          ftarr(j*imtp1-imt) = ftarr(j*imtp1-imt) + cc2
2500    continue
c
      endif
c
c     filter s
c
2501  continue
c
      do 2600 i=1,im
        sprime(i) = c0
2600  continue
c
c     note that ftarr(j,i)=ftarr(i,j), so following is legal
c
      do 2700 i=1,im
        ioff = (i-1)*imt
        do 2690 j=1,im
          sprime(j) = sprime(j) + s(i)*ftarr(ioff+j)
2690    continue
2700  continue
c
      do 2800 i=1,im
        sprime(i) = fnorm*sprime(i)
2800  continue
c
      if(mm.eq.2) then
c
        do 2900 i=1,im
          s(i) = sprime(i)
2900    continue
c
        goto 3201
      endif
c
3000  continue
      ssm = c0
c
      do 3100 i=1,im
        ssm = ssm + sprime(i)
3100  continue
c
      ssm = (ssum-ssm)*fimr
c
      do 3200 i=1,im
        s(i) = ssm+sprime(i)
3200  continue
c
3201  continue
c
   99 format (/' error => bad argument(s) in call to filtr'
     $       /' im,mm,n,iss = ',4i10)
  999 format (/' error => can not calculate parameters for reducing',
     $        ' indices in filtr')
#endif
      return
      end
#DECK filuv.F
      subroutine filuv (j)
#if defined fourfil || defined firfil
c
c=====================================================================
c     filuv sets up input needed for fourier filtering
c     (when the "fourfil" ifdef is defined) -or- symmetric finite
c     impulse response filtering (when the "firfil" ifdef is defined)
c     of baroclinic velocities at the specifiied high latitude row "j".
c=====================================================================
c
#  ifdef multitasking
cfpp$ noconcur r
#  endif
#include "param.h"
#include "cpolar.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
#include "temp.h"
c
#ifdef firfil
      dimension  ubar(imt), vbar(imt)
#endif
c
c=====================================================================
c
#  ifdef fourfil
c
c---------------------------------------------------------------------
c     fourier filter u and v at high latitudes
c---------------------------------------------------------------------
c
      if((j.gt.jfu1 .and. j.lt.jfu2) .or. j.lt.jfrst) goto 701
      jj = j - jfrst + 1
      if (j.ge.jfu2) jj = jj - jskpu + 1
      fx = -c1
      if (phi(j).gt.0.) fx = c1
      isave = 0
      ieave = 0
c
      do 200 l=1,lsegf
        do 190 k=1,km
          if (isuf(jj,l,k) .eq. 0) goto 190
          is = isuf(jj,l,k)
          ie = ieuf(jj,l,k)
          iredo = 1
          if (is.ne.isave .or. ie.ne.ieave) then
            iredo = 0
            im = ie - is + 1
            isave = is
            ieave = ie
#    ifdef cyclic
            if (im .ne. imtm2) then
              m = 2
              n = nint(im*csu(j)*csur(jfu0))
            else
              m = 3
              n = nint(im*csu(j)*csur(jfu0)*p5)
            endif
#    else
           m = 2
           n = nint(im*csu(j)*csur(jfu0))
#    endif
          endif
          ism1 = is - 1
          iea = ie
          if(ie .ge. imu) iea = imum1
          do 150 i=is,iea
            tempik(i-ism1,k,1) = -fx*ua(i,k)*spsin(i) - va(i,k)*spcos(i)
            tempik(i-ism1,k,2) =  fx*ua(i,k)*spcos(i) - va(i,k)*spsin(i)
150       continue
          if (ie .ge. imu) then
            ieb = ie - imum2
            ii  = imum1 - is
            do 160 i=2,ieb
              tempik(i+ii,k,1) = -fx*ua(i,k)*spsin(i) - va(i,k)*spcos(i)
              tempik(i+ii,k,2) =  fx*ua(i,k)*spcos(i) - va(i,k)*spsin(i)
160        continue
          endif
c
          call filtr (tempik(1,k,1), im, m, n, iredo)
c
          call filtr (tempik(1,k,2), im, m, n, 1)
c
          do 170 i=is,iea
            ua(i,k) = fx*(-tempik(i-ism1,k,1)*spsin(i)
     $                   + tempik(i-ism1,k,2)*spcos(i))
            va(i,k) = -tempik(i-ism1,k,1)*spcos(i)
     $                   - tempik(i-ism1,k,2)*spsin(i)
170       continue
          if (ie .ge. imt) then
            do 180 i=2,ieb
              ua(i,k) = fx*(-tempik(i+ii,k,1)*spsin(i)
     $                     + tempik(i+ii,k,2)*spcos(i))
              va(i,k) = -tempik(i+ii,k,1)*spcos(i)
     $                     - tempik(i+ii,k,2)*spsin(i)
180         continue
          endif
190     continue
200   continue
c
      do 300 i=1,imt
        tempik(i,1,1) = c0
        tempik(i,1,2) = c0
300   continue
c
      do 400 k=1,km
        do 390 i=1,imt
          tempik(i,1,1) = tempik(i,1,1) + ua(i,k)*dzt(k)
          tempik(i,1,2) = tempik(i,1,2) + va(i,k)*dzt(k)
390     continue
400   continue
c
      do 500 i=1,imt
        tempik(i,1,1) = tempik(i,1,1)*hr(i,j)
        tempik(i,1,2) = tempik(i,1,2)*hr(i,j)
500   continue
c
      do 600 k=1,km
        do 590 i=1,imt
          ua(i,k) = ua(i,k) - tempik(i,1,1)
          va(i,k) = va(i,k) - tempik(i,1,2)
590     continue
600   continue
c
      do 700 k=1,km
        do 690 i=1,imt
          ua(i,k) = ua(i,k)*gm(i,k,jc)
          va(i,k) = va(i,k)*gm(i,k,jc)
690     continue
700   continue
c
701   continue
#  endif
#  ifdef firfil
c-----------------------------------------------------------------------
c     filter u and v at high latitudes with a finite impulse
c     response filter "fir"
c-----------------------------------------------------------------------
c
      if ((j .le. jfu1 .or. j .ge. jfu2) .and. j .ge. jfrst) then
        jj = j - jfrst + 1
        if (j .ge. jfu2) jj = jj - jskpu + 1
        numfil = numflu(jj)
c
        fx = -c1
        if (phi(j) .gt. c0) fx = c1
c
        do 720 k=1,km
          do 710 i=1,imt
            tempik(i,k,1) = -fx*ua(i,k)*spsin(i) - va(i,k)*spcos(i)
            tempik(i,k,2) =  fx*ua(i,k)*spcos(i) - va(i,k)*spsin(i)
710       continue
720     continue
c
        call filfir (tempik(1,1,1), gm(1,1,jc), ua, km, 1, numfil)
        call filfir (tempik(1,1,2), gm(1,1,jc), va, km, 1, numfil)
c
        do 740 k=1,km
          do 730 i=1,imt
            ua(i,k) = fx*(-tempik(i,k,1)*spsin(i)
     $                   + tempik(i,k,2)*spcos(i))
            va(i,k) = -tempik(i,k,1)*spcos(i)
     $                   - tempik(i,k,2)*spsin(i)
730       continue
740     continue
c
c       extract fictitious vertical mean
c
        do 800 i=2,imtm1
          ubar(i) = c0
          vbar(i) = c0
800     continue
c
        do 900 k=1,km
          do 890 i=2,imtm1
            ubar(i) = ubar(i) + ua(i,k)*dzt(k)
            vbar(i) = vbar(i) + va(i,k)*dzt(k)
890       continue
900     continue
c
        do 1000 i=2,imtm1
          ubar(i) = ubar(i)*hr(i,j)
          vbar(i) = vbar(i)*hr(i,j)
1000    continue
c
        do 1100 k=1,km
          do 1090 i=2,imtm1
            ua(i,k) = ua(i,k) - gm(i,k,jc)*ubar(i)
            va(i,k) = va(i,k) - gm(i,k,jc)*vbar(i)
1090      continue
1100    continue
c
      endif
#  endif
c
#endif
      return
      end
#DECK filz.F
      subroutine filz (j)
#if defined fourfil || defined firfil
c
c=======================================================================
c
c     filter vorticity at high latitudes
c
c=======================================================================
c
#include "param.h"
#include "cdiag.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "levind.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
#ifdef multitasking
      dimension tempik(imt,km,1)
#else
#include "temp.h"
#endif
c
#ifdef firfil
      dimension ubar(imt), vbar(imt)
c
#endif
c=======================================================================
c
#  ifdef fourfil
        if ((j .le. jfu1 .or. j .ge. jfu2) .and. j .ge. jfrst) then
c
c---------------------------------------------------------------------
c         fourier filter ztd at high latitudes
c---------------------------------------------------------------------
c
          if (j .eq. jfu2) go to 101
c
            jj = j - jfrst + 1
            if (j .ge. jfu2) jj = jj - jskpu + 1
c
            do 100 l=1,lsegf
              is=iszf(jj,l)
              if(is.eq.0) go to 100
              ie=iezf(jj,l)
              do 80 ii=is,ie
                i=mod(ii-2,imtm2)+2
                tempik(ii+1-is,1,1)=ztd(i,j)
80            continue
              im=ie-is+1
#    ifdef cyclic
              if(im.ne.imtm2) then
                 m=1
                 n=nint(im*cst(j)*csur(jfu0))
              else
                 m=3
                 n=nint(im*cst(j)*csur(jfu0)*p5)
              endif
#    else
              m=1
              n=nint(im*cst(j)*csur(jfu0))
#    endif
c
              call filtr(tempik(1,1,1),im,m,n,0)
c
              do 90 ii=is,ie
                i=mod(ii-2,imtm2)+2
                ztd(i,j)=tempik(ii+1-is,1,1)
90            continue
100         continue
101       continue
        endif
#  endif
#  ifdef firfil
c---------------------------------------------------------------------
c       filter vorticity at high latitudes with a finite impulse
c       response filter "fir"
c---------------------------------------------------------------------
c
        if ((j .le. jfu1 .or. j .ge. jfu2) .and. j .ge. jfrst) then
c
          if (j .ne. jfu2) then
            jj = j - jfrst + 1
            if (j .ge. jfu2) jj = jj - jskpu + 1
            numfil = numflu(jj)
c
c           construct appropriate land/sea mask
c
            do 200 i=2,imtm1
              ubar(i) = c0
200         continue
c
            do 300 l=1,lseg
              isv = isz(j,l)
              if (isv .ne. 0) then
                iev = iez(j,l)
                do 290 i=isv,iev
                  ubar(i) = c1
290             continue
              endif
300         continue
c
#    ifdef cyclic
            ubar(1)   = ubar(imtm1)
            ubar(imt) = ubar(2)
#    else
            ubar(1)   = c0
            ubar(imt) = c0
#    endif
#    ifdef islands
c
c           ensure that ztd is zero next to islands
c
            do 400 i=1,imt
              tempik(i,1,1) = ztd(i,j)*ubar(i)
400         continue
c
            call filfir (tempik(1,1,1), ubar, vbar, 1, 0, numfil)
c
            do 500 i=1,imt
              if (ubar(i) .gt. c0) ztd(i,j) = tempik(i,1,1)
500         continue
#    else
            call filfir (ztd(1,j), ubar, vbar, 1, 0, numfil)
c
#    endif
          endif
        endif
#  endif
c
#endif
      return
      end
#DECK findex.F
      subroutine findex(kxx, jjmax, kmax, jf1, jf2, imax, isf, ief)
#ifdef fourfil
c
c=======================================================================
c
c  findex finds and prints starting and ending indices
c         for filtering, where:
c             kxx  = field of maximum levels for the quantity
c                    being filtered
c             jjmax = number of rows to be filtered
c             kmax  = maximum number of levels to be filtered
c             jf1   = last row in the south to be filtered
c             jf2   = first row in the north to be filtered
c             imax  = maximum i index to be filtered
c             isf   = returned values of starting indices
c             ief   = returned values of ending indices
c
c=======================================================================
c
#include "param.h"
#include "pfil.h"
c
      dimension kxx(imt,jmt)
     $        ,isf(jjmax,lsegf,kmax),ief(jjmax,lsegf,kmax)
     $        ,iis(lsegf+1),iie(lsegf+1)
c
c=======================================================================
c     begin executable code to find start and end indices
c=======================================================================
c
      jj = 0
      do 100 j = jfrst,jmtm1
        if (j.gt.jf1 .and. j.lt.jf2) goto 100
        jj = jj+1
        do 90 k = 1,kmax
           do 60 l = 1,lsegf+1
              iis(l) = 0
              iie(l) = 0
60         continue
           l = 1
           if (kxx(2,j).ge.k) then
              iis(1) = 2
           endif
           do 70 i = 2,imax-1
              if (kxx(i-1,j).lt.k .and. kxx(i,j).ge.k) then
                 iis(l) = i
              endif
              if (kxx(i,j).ge.k .and. kxx(i+1,j).lt.k) then
                 if (i.ne.iis(l) .or. (i.eq.2 .and. kxx(1,j).ge.k))then
                    iie(l) = i
                    l = l+1
                 else
                    iis(l) = 0
                 endif
              endif
70         continue
           if (kxx(imax-1,j).ge.k .and. kxx(imax,j).ge.k) then
              iie(l) = imax-1
              l = l+1
           endif
           lm = l-1
#ifdef cyclic
           if (lm.gt.1) then
              if (iis(1).eq.2 .and. iie(lm).eq.imax-1
     $                        .and. kxx(1,j).ge.k) then
                 iis(1) = iis(lm)
                 iie(1) = iie(1) + imax-2
                 iis(lm) = 0
                 iie(lm) = 0
                 lm = lm-1
              endif
           endif
#endif
           if (lm .gt. lsegf) then
              write (stdout,99) j, k
              write (stderr,99) j, k
              stop ' findex '
           endif
           do 80 l = 1,lsegf
              isf(jj,l,k) = iis(l)
              ief(jj,l,k) = iie(l)
80         continue
90      continue
100   continue
c
c     print them
c
      llast=lsegf
      if (llast .gt. 11) llast=11
      jj=jj+1
      do 200 j=jmtm1,jfrst,-1
        if (j.gt.jf1 .and. j.lt.jf2) go to 200
        jj = jj-1
        if (kmax .gt. 1) then
          write (stdout,9001) j
          do 190 k=1,kmax
            write (stdout,9002) k,(isf(jj,l,k),ief(jj,l,k),l=1,llast)
190       continue
        else
          write (stdout,9002) j,(isf(jj,l,1),ief(jj,l,1),l=1,llast)
        endif
200   continue
c
99    format (/' error => lsegf not large enough.  j=',i4,'    k=',i3)
9001  format (/' indices for row ',i3,':')
9002  format (1x,i9,3x,11(i5,i4))
#endif
      return
      end
#DECK hyper.F
      subroutine hyper
#ifdef hypergrid
c
c=======================================================================
c
c     hyper is similar to relax except it solves the equation along
c     diagonals to allow for complete vectorization & parallelization
c
c=======================================================================
c
c---------------------------------------------------------------------
c  define global data
c---------------------------------------------------------------------
c
#include "param.h"
#include "crelax.h"
#include "ctmngr.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "iounit.h"
#include "scalar.h"
#include "switch.h"
#include "temp.h"
c
      dimension ptdb(imt,jmt), resmi(jmt)
      equivalence (res,ptdb)
c
c=======================================================================
c     begin introductory section to prepare for the relaxation
c=======================================================================
c
c-----------------------------------------------------------------------
c    initiate readin of relaxation solution of 2 timesteps back
c    for the purpose of computing an initial guess for the present pass
c    (input unit alternates on tsteps between 4 & 5)
c-----------------------------------------------------------------------
c
      luptdb = 5 - mod(itt,2)
      luptd  = 4 + mod(itt,2)
      call ofind (kflds, nwds, (luptdb-1)*nwds+1)
      call ofind (kflds, nwds, (luptd-1)*nwds+1)
c
c
      if (first .or. mixts .or. mod(itt,nmix) .eq. 2) then
c
c-----------------------------------------------------------------------
c       initialize the work area
c-----------------------------------------------------------------------
c
        do 100 j=1,jmt
          do 90 i=1,imt
            cfn(i,j)  = c0
            cfs(i,j)  = c0
            cfe(i,j)  = c0
            cfw(i,j)  = c0
            rmsk(i,j) = c0
#ifdef islands
            cof(i,j)  = c1
#endif
90        continue
100     continue
c
c-----------------------------------------------------------------------
c       generate arrays of coefficients for relaxation
c-----------------------------------------------------------------------
c
c       1st, compute coefficients of the laplacian star
c       (hold non-interior points to zero using start and end indices)
c
        do 600 j=3,jmtm1
          do 590 l=1,lseg
            if (isz(j,l) .ne. 0) then
              ie = iez(j,l)
              fxa = c2*cstr(j)*cstr(j)
              fxb = c2*csu(j  )*cstr(j)*dytr(j)*dyur(j  )
              fxc = c2*csu(j-1)*cstr(j)*dytr(j)*dyur(j-1)
              do 560 i=isz(j,l),iez(j,l)
                rmsk(i,j) = c1
                cfn(i,j)  = fxb/(h(i-1,j)+h(i,j))
                cfs(i,j)  = fxc/(h(i-1,j-1)+h(i,j-1))
                cfe(i,j)  = fxa*dxur(i)*dxtr(i)/(h(i,j)+h(i,j-1))
                cfw(i,j)  = fxa*dxur(i-1)*dxtr(i)/(h(i-1,j)+h(i-1,j-1))
                cpf(i,j) = c1/(cfn(i,j)+cfs(i,j)+cfe(i,j)+cfw(i,j))
560          continue
c
c             augment coeffs for implicit treatment of coriolis term
c
              if (acor .ne. c0) then
                fx = -c2dtsf*acor*cstr(j)*dytr(j)*omega
                do 570 i=isz(j,l),iez(j,l)
                  cfn(i,j) = cfn(i,j)+(hr(i,j  )-hr(i-1,j  ))*sine(j  )
     $                        *fx*dxtr(i)
                  cfs(i,j) = cfs(i,j)-(hr(i,j-1)-hr(i-1,j-1))*sine(j-1)
     $                        *fx*dxtr(i)
                  cfe(i,j) = cfe(i,j)-(hr(i  ,j)*sine(j)-hr(i  ,j-1)*
     $                        sine(j-1))*fx*dxtr(i)
                  cfw(i,j) = cfw(i,j)+(hr(i-1,j)*sine(j)-hr(i-1,j-1)*
     $                        sine(j-1))*fx*dxtr(i)
570            continue
              endif
c
c             normalize coefficients
c
              do 580 i=isz(j,l),iez(j,l)
                cfn(i,j) = cfn(i,j)*cpf(i,j)
                cfs(i,j) = cfs(i,j)*cpf(i,j)
                cfe(i,j) = cfe(i,j)*cpf(i,j)
                cfw(i,j) = cfw(i,j)*cpf(i,j)
580           continue
            endif
590       continue
600     continue
#ifdef islands
c
c       modify coefficients to include island perimeter points
c
        do 700 isle=1,nisle
          cofis(isle) = c0
          do 690 n=1,nippts(isle)
            i = iperm(iofs(isle)+n)
            j = jperm(iofs(isle)+n)
            fxa = c2*cstr(j)*cstr(j)
            fxb = c2*csu(j  )*dyur(j  )*dytr(j)*cstr(j)
            fxc = c2*csu(j-1)*dyur(j-1)*dytr(j)*cstr(j)
            fxd = -c2dtsf*acor*cstr(j)*dytr(j)*omega
            if(hr(i-1,j  ) .ne. c0 .or. hr(i  ,j  ) .ne. c0)
     $        cfn(i,j) = fxb/(h(i-1,j)+h(i,j))
            if(hr(i-1,j-1) .ne. c0 .or. hr(i  ,j-1) .ne. c0)
     $        cfs(i,j) = fxc/(h(i-1,j-1)+h(i,j-1))
            if(hr(i  ,j  ) .ne. c0 .or. hr(i  ,j-1) .ne. c0)
     $        cfe(i,j) = fxa*dxtr(i)*dxur(i)/(h(i,j)+h(i,j-1))
            if(hr(i-1,j  ) .ne. c0 .or. hr(i-1,j-1) .ne. c0)
     $        cfw(i,j) = fxa*dxtr(i)*dxur(i-1)/(h(i-1,j)+h(i-1,j-1))
c
            cpf(i,j) = c1/(cfn(i,j)+cfs(i,j)+cfe(i,j)+cfw(i,j))
c
            if(hr(i-1,j  ) .ne. c0 .or. hr(i  ,j  ) .ne. c0)
     $        cfn(i,j) = cfn(i,j)
     $        +fxd*dxtr(i)*(hr(i,j)-hr(i-1,j))*sine(j)
            if(hr(i-1,j-1) .ne. c0 .or. hr(i  ,j-1) .ne. c0)
     $        cfs(i,j) = cfs(i,j)
     $        -fxd*dxtr(i)*(hr(i,j-1)-hr(i-1,j-1))*sine(j-1)
            if(hr(i  ,j  ) .ne. c0 .or. hr(i  ,j-1) .ne. c0)
     $        cfe(i,j) = cfe(i,j)
     $        -fxd*dxtr(i)*(hr(i,j)*sine(j)-hr(i,j-1)*sine(j-1))
            if(hr(i-1,j  ) .ne. c0 .or. hr(i-1,j-1) .ne. c0)
     $        cfw(i,j) = cfw(i,j)
     $        +fxd*dxtr(i)*(hr(i-1,j)*sine(j)-hr(i-1,j-1)*sine(j-1))
            cfn(i,j) = cfn(i,j)*cpf(i,j)
            cfs(i,j) = cfs(i,j)*cpf(i,j)
            cfe(i,j) = cfe(i,j)*cpf(i,j)
            cfw(i,j) = cfw(i,j)*cpf(i,j)
            cof(i,j) = cst(j)*dxt(i)*dyt(j)/cpf(i,j)
            cofis(isle) = cofis(isle)+cof(i,j)
690       continue
          cofis(isle) = c1/cofis(isle)
700     continue
#endif
      endif
c
c-----------------------------------------------------------------------
c     normalize vorticity "ztd"
c-----------------------------------------------------------------------
c
      do 800 j=1,jmt
        do 790 i=1,imt
          ztd(i,j) = ztd(i,j)*cpf(i,j)
790     continue
800   continue
c
c-----------------------------------------------------------------------
c     complete readin of relaxation solution of 2 timesteps prior and
c     of previous timestep.
c-----------------------------------------------------------------------
c
      call oget (kflds, nwds, (luptdb-1)*nwds+1, ptdb)
      call oget (kflds, nwds, (luptd-1)*nwds+1, ptd)
c
c-----------------------------------------------------------------------
c     erstimate a first guess by extrapolating the two
c     previous solutions forward in time.
c-----------------------------------------------------------------------
c
      fxa=c1
      if (mixts .or. mxpas2) fxa=p5
      do 900 j=1,jmt
        do 890 i=1,imt
          ptd(i,j) = fxa*(c2*ptd(i,j)-ptdb(i,j))
890    continue
900   continue
c
c     compute criterion for convergence and set residuals to zero
c
      crtp = crit*fxa
      do 1000 j=1,jmt
        do 990 i=1,imt
          res(i,j) = c0
990     continue
1000  continue
c
c=======================================================================
c     begin section to do the relaxation
c=======================================================================
c
      nwcnt = 0
      nwmax = 300
      mscan = 0
1001  continue
      mscan = mscan + 1
c
c-----------------------------------------------------------------------
c     consider the arrays as being defined on the squares of an
c     "imt by jmt" checkerboard. take two passes: first solve the
c     equation on the black squares, then on the red squares.
c-----------------------------------------------------------------------
c
      do 1200 icolor=1,2
        do 1190 j=3,jscan
          resmi(j) = c0
          ishypr   = 1 + mod(icolor+j,2)
          if (ishypr .eq. 1) ishypr = 3
          do 1160 i=ishypr,imtm1,2
            res(i,j) = rmsk(i,j)*(cfn(i,j)*ptd(i,j+1)
     $                 +cfs(i,j)*ptd(i,j-1)
     $                 +cfe(i,j)*ptd(i+1,j)
     $                 +cfw(i,j)*ptd(i-1,j)
     $                 -ptd(i,j)-ztd(i,j))
1160      continue
          if (ishypr .eq. 3) ishypr = 1
#ifdef cyclic
          res(1,j)   = res(imum1,j)
          res(imt,j) = res(2,j)
#else
          res(1,j)   = c0
          res(imt,j) = c0
#endif
c
c-----------------------------------------------------------------------
c         make a correction to ptd based on the residuals
c-----------------------------------------------------------------------
c
          do 1170 i=ishypr,imt,2
            ptd(i,j) = ptd(i,j) + sor*res(i,j)
1170      continue
c
c-----------------------------------------------------------------------
c         find the maximum absolute residual to determine convergence
c-----------------------------------------------------------------------
c
          do 1180 i=ishypr,imt,2
c          do 1180 i=2,imtm1
            resmi(j) = max(abs(res(i,j)),resmi(j))
1180      continue
1190    continue
1200  continue
c
      resmax = c0
      do 1300 j=3,jscan
        resmax = max(resmi(j),resmax)
1300  continue
#ifdef islands
c
c-----------------------------------------------------------------------
c     do hole relaxation for each island
c-----------------------------------------------------------------------
c
      do 1400 isle=1,nisle
        resis = c0
        do 1360 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          resis = resis + (cfn(i,j)*ptd(i,j+1)
     $                  +  cfs(i,j)*ptd(i,j-1)
     $                  +  cfe(i,j)*ptd(i+1,j)
     $                  +  cfw(i,j)*ptd(i-1,j)
     $                  -  ptd(i,j) - ztd(i,j))*cof(i,j)
1360    continue
c
c       normalize the island residual and update the maximum
c       absolute residual of the relaxation if necessary
c
        resis  = resis*cofis(isle)
        resmax = max(abs(resis),resmax)
        resis  = resis*sor
c
c       make a correction to ptd over the island and its perimeter
c
        do 1370 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          ptd(i,j) = ptd(i,j) + resis
1370    continue
1400  continue
#endif
#ifdef symmetry
c
c-----------------------------------------------------------------------
c  set symmetry boundary condition
c-----------------------------------------------------------------------
c
      do 1500 i=1,imt
        ptd(i,jmt) = -ptd(i,jmtm1)
1500  continue
#endif
#ifdef cyclic
c
c-----------------------------------------------------------------------
c  set cyclic boundary condition
c-----------------------------------------------------------------------
c
      do 1600 j=1,jmt
        ptd(1,j)   = ptd(imum1,j)
        ptd(imu,j) = ptd(2,j)
1600  continue
#endif
c
c-----------------------------------------------------------------------
c     test maximum residual for convergence of the relaxation.
c     if not converged, proceed with another scan.
c     (if the number of scans reaches mxscan, leave the loop)
c-----------------------------------------------------------------------
c
      if (resmax.ge.crtp .and. mscan.lt.mxscan) go to 1001
c
c=======================================================================
c  end of the relaxation
c=======================================================================
c
c-----------------------------------------------------------------------
c  update the stream function based on the relaxation solution
c-----------------------------------------------------------------------
c
      if (.not. mxpas2) then
        do 1700 j=1,jmt
          do 1690 i=1,imt
            ptdb(i,j) = p(i,j,2) + ptd(i,j)
            p(i,j,2)  = p(i,j,1)
            p(i,j,1)  = ptdb(i,j)
1690      continue
1700    continue
      else
        do 1800 j=1,jmt
          do 1790 i=1,imt
            p(i,j,1) = p(i,j,2) + ptd(i,j)
1790      continue
1800    continue
      endif
c
c-----------------------------------------------------------------------
c  save ptd to compute 1st guess for relaxation next timestep
c  (..note.. on 1st pass of euler backward timestep, bypass this
c            save, since it will be done on the 2nd pass)
c  (..note.. on a mixing timestep, alter ptd to be consistent with
c            normal, leap-frog stepping)
c-----------------------------------------------------------------------
c
      if (mixts .and. eb) return
c
      if (mxpas2 .or. mixts) then
        do 1900 j=1,jmt
          do 1890 i=1,imt
            ptd(i,j) = c2*ptd(i,j)
1890      continue
1900    continue
      endif
c
      call oput (kflds, nwds, (luptdb-1)*nwds+1, ptd)
#endif
      return
      end
#DECK implq.F
      subroutine implq (q2, q1, tdt, q2bct, j)
#if defined tcvmix && defined implicitvmix
c
c======================================================================
c      solve the vertical diffusion equation of tke implicitly
c      using the method of inverting a tridiagonal matrix
c      as described in richtmyer and morton.
c      dissipation is included implicitly
c
c      inputs:
c
c      q1      = right hand side terms
c      tdt     = 2 * timestep
c      q2bct   = top boundary condition
c      j       = row j
c
c      outputs:
c
c      q2      = returned solution
c
#include "param.h"
#include "ctcmix.h"
#include "cvmix.h"
#include "levind.h"
      common /invt/ a, b, c, d, e, f, g
      dimension a(imt,km), b(imt,km), c(imt,km), d(imt,km)
      dimension e(imt,0:kmp1), f(imt,0:kmp1), g(imt)
      dimension q1(imt,km), q2(imt,km)
      dimension q2bct(imt)
c
c======================================================================
c
      do 100 k=1,kmm1
        do 90 i=1,imt
          a(i,k) = eeq(i,k)*tdt
          c(i,k) = ffq(i,k)*tdt
          e(i,k) = tdt*dissp(i,k)
90      continue
100    continue
c
      do 200 k=1,kmm1
        do 190 i=1,imt
          b(i,k) = c1 + a(i,k) + c(i,k) + e(i,k)
          d(i,k) = q1(i,k)
190     continue
200   continue
c
      do 300 i = 1,imt
        e(i,kmm1) = c0
        f(i,kmm1) = c0
300   continue
c
c     b.c. at bottom (q2=q2l=0)
c
      do 400 i=1,imt
        kz = kmt(i,j)
        if (kz .eq. 0) goto 400
        a(i,kz) = c0
        d(i,kz) = c0
400   continue
c
      do 500 kk=2,km
        k = km + 1 - kk
          do 490 i=1,imt
            g(i) = c1/(b(i,k)-c(i,k)*e(i,k))
            f(i,k-1) = (d(i,k)+c(i,k)*f(i,k))*g(i)
            e(i,k-1) = a(i,k)*g(i)
490       continue
500   continue
c
      do 600 i=1,imt
        q2(i,1) = e(i,0)*q2bct(i) + f(i,0)
600   continue
c
      do 700 k=2,km
        do 690 i=1,imt
          q2(i,k) = e(i,k-1)*q2(i,k-1) + f(i,k-1)
690     continue
700   continue
c
#endif
      return
      end
#DECK invtri.F
      subroutine invtri (z, topbc, botbc, vmc, tdt, kmz, mask, is, ie
     $,                  j)
#if defined implicitvmix || defined isopycmix
c
c=======================================================================
c     solve the vertical diffusion equation implicitly using the
c     method of inverting a tridiagonal matrix as described in
c     richtmyer and morton.
c     this routine assums that the variables are defined at grid points
c     and the top and bottom b.c. are flux conditions.
c
c     inputs:
c     z         = right hand side terms
c     topbc     = top boundary condition
c     botbc     = bottom boundary condition
c     vmc       = vertical mixing coeff
c     tdt       = 2 * timestep
c     kmz       = level indicator
c     mask      = land - sea mask
c     is        = index of starting longitude
c     ie        = index of ending longitude
c     j         = latitude row
c
c     outputs:
c     z         = returned solution
c
c=======================================================================
c
#include "param.h"
#include "cvmix.h"
#include "grdvar.h"
      dimension z(imt,km)
      dimension topbc(imt), botbc(imt)
      dimension vmc(imt,km)
      dimension kmz(imt,jmt), tdt(km)
      real mask(imt,km)
c
      dimension a(imt,km), b(imt,km), c(imt,km), d(imt,km)
      dimension e(imt,0:km), f(imt,0:km), g(imt)
c
      do 100 k=2,km
        do 90 i=is,ie
          a(i,k)   = vmc(i,k-1)*dztur(k)*tdt(k)*aidif
          c(i,k)   = vmc(i,k)*dztlr(k)*tdt(k)*aidif
          b(i,k)   = c1 + a(i,k) + c(i,k)
          d(i,k)   = z(i,k)
          e(i,k-1) = c0
          f(i,k-1) = c0
90      continue
100   continue
c
c     b. c. at top
c
      k = 1
      do 300 i=is,ie
        a(i,k)   = dztr(k)*tdt(k)*aidif
        c(i,k)   = vmc(i,k)*dztlr(k)*tdt(k)*aidif
        b(i,k)   = c1 + c(i,k)
        d(i,k)   = z(i,k)
        e(i,k-1) = c0
        f(i,k-1) = c0
300   continue
c
c     b. c. at bottom
c
      do 400 i=is,ie
        kz = kmz(i,j)
        if (kz .ne. 0) then
          b(i,kz) = c1 + a(i,kz)
          c(i,kz) = dztr(kz)*tdt(kz)*aidif
          e(i,kz) = c0
          f(i,kz) = -botbc(i)
        endif
400   continue
c
c-----------------------------------------------------------------------
c     now invert
c-----------------------------------------------------------------------
c
      do 500 k=km,1,-1
        do 490 i=is,ie
          if (k .le. kmz(i,j)) then
            g(i)     = c1/(b(i,k)-c(i,k)*e(i,k))
            e(i,k-1) = a(i,k)*g(i)
            f(i,k-1) = (d(i,k)+c(i,k)*f(i,k))*g(i)
          endif
490     continue
500   continue
c
c     b.c. at surface
c
      do 600 i=is,ie
        z(i,1) = (e(i,0)*topbc(i) + f(i,0))*mask(i,1)
600   continue
c
      do 700 k=2,km
        do 690 i=is,ie
          z(i,k) = (e(i,k-1)*z(i,k-1) + f(i,k-1))*mask(i,k)
690     continue
700   continue
#endif
      return
      end
#DECK iperim.F
      subroutine iperim (kmz)
#ifdef islands
c
c=======================================================================
c
c     find island perimeter coordinates & analyze for errors in land
c     mass distribution
c
c     inputs:
c
c     kmz   = scratch area
c     kmt   = number of levels on the "t" grid
c     kmu   = number of levels on the "u" grid
c
c     output:
c
c     all island variables in "index.h"
c
c=======================================================================
c
      character*1 dir, blank
      logical prblm, fatal
#include "param.h"
#include "coord.h"
#include "index.h"
#include "levind.h"
      dimension kmz(imt,jmt)
      dimension ncol(imt)
c
      data blank /' '/
c
c-----------------------------------------------------------------------
c     statement functions
c-----------------------------------------------------------------------
c
      iwest(i) = mod(i-2+imt,imt) + 1
      ieast(i) = mod(i,imt) + 1
c
c-----------------------------------------------------------------------
c     save the original "kmt" field (to be restored later)
c     and initialize "chisl" field
c-----------------------------------------------------------------------
c
      do 100 j=1,jmt
        do 90 i=1,imt
          kmz(i,j) = kmt(i,j)
90      continue
100   continue
c
c-----------------------------------------------------------------------
c     search for & knockout isolated bays ... "t" grid boxes at the
c     surface which can't be influenced by advection
c-----------------------------------------------------------------------
c
      do 400 j=2,jmtm1
        do 390 i=2,imtm1
          if (kmt(i,j) .ne. 0) then
            if (kmu(i,j) .eq. 0 .and. kmu(i-1,j) .eq. 0 .and.
     $        kmu(i,j-1) .eq. 0 .and. kmu(i-1,j-1) .eq. 0) then
              kmt(i,j) = 0
            endif
          endif
390     continue
400   continue
c
c-----------------------------------------------------------------------
c     find the coordinates of the perimeter of each island
c-----------------------------------------------------------------------
c
      fatal = .false.
      do 600 n=1,nisle
c
c-----------------------------------------------------------------------
c       convert island latitude & longitude "seed" values to nearest
c       model points incices.
c-----------------------------------------------------------------------
c
        i = indp (alonis(n), xt, imt)
        j = indp (alatis(n), yt, jmt)
        if (kmt(i,j) .ne. 0) then
          write (stdout,'(a17,i2,a18,5x,a5,f8.2,a6,f8.2)')
     $    ' => island seed #',n,' is an ocean point'
     $,   ' lon=',alonis(n),', lat=',alatis(n)
          stop '=>iperim'
        endif
c
c-----------------------------------------------------------------------
c       determine a first perimeter point
c-----------------------------------------------------------------------
c
        if (j .le. jmt/2) then
          jend = jmt
          jd   = 1
        else
          jend = 1
          jd   = -1
        endif
        do 500 jj=j,jend,jd
          if (kmt(i,jj) .ne. 0) then
            j = jj
            go to 510
          endif
500     continue
510     continue
        i0  = i
        j0  = j
        dir = blank
c
c-----------------------------------------------------------------------
c       scan for the rest of the perimeter
c-----------------------------------------------------------------------
c
        if (n .eq. 1) then
          iofs(n)  = 0
        else
          iofs(n)  = nippts(n-1) + iofs(n-1)
        endif
        lenp       = iofs(n) + 1
        iperm(lenp) = i
        jperm(lenp) = j
c
        do 580 m=1,maxipp
          iw  = iwest(i)
          ie  = ieast(i)
          js  = max(1,j-1)
          jn  = min(jmt,j+1)
          if (iw .eq. 1) then
            iw  = imt-1
          endif
          if (ie .eq. imt) then
            ie  = 2
          endif
c
c-----------------------------------------------------------------------
c         analyze the geometry to verify that the island and any other
c         land mass are separated by at least 2 ocean "t" grid boxes
c-----------------------------------------------------------------------
c
          prblm = .false.
c
          if ((kmt(ie,jn) .eq. 0 .and. kmt(iw,js) .eq. 0) .or.
     $        (kmt(ie,js) .eq. 0 .and. kmt(iw,jn) .eq. 0)) then
            if (kmt(iw,j) .ne. 0 .and. kmt(ie,j) .ne. 0 .and.
     $          kmt(i,jn) .ne. 0 .and. kmt(i,js) .ne. 0 ) prblm = .true.
            if (kmt(iw,j) .ne. 0 .and. kmu(iw,j) .eq. 0 .and.
     $          kmu(iw,js) .eq. 0) prblm = .true.
            if (kmt(ie,j) .ne. 0 .and. kmu(i,j) .eq. 0 .and.
     $          kmu(i,js) .eq. 0) prblm = .true.
            if (kmt(i,jn) .ne. 0 .and. kmu(i,j) .eq. 0 .and.
     $          kmu(iw,j) .eq. 0) prblm = .true.
            if (kmt(i,js) .ne. 0 .and. kmu(i,js) .eq. 0 .and.
     $          kmu(iw,js) .eq. 0) prblm = .true.
          endif
          if (prblm) then
            write (stdout,9200) n, i, j, xt(i), yt(j)
            fatal = .true.
          endif
c
c-----------------------------------------------------------------------
c         look west (only if not comming from west)
c-----------------------------------------------------------------------
c
          k2 = kmt(iw,jn)  * kmt(iw,js)
          k3 = kmt(i,jn)   * kmt(i,js)
          if (k2 .eq. 0 .or. k3 .eq. 0) then
            k = 0
          else
            k = 1
          endif
          if (kmt(iw,j) .ne. 0 .and. k .eq. 0 .and. dir .ne. 'e') then
            if (lenp .lt. maxipp) then
              if (iw .ne. i0 .or. j .ne. j0) then
                dir          = 'w'
                lenp         = lenp + 1
                i            = iw
                iperm(lenp)  = iw
                jperm(lenp)  = j
                go to 580
              else
                go to 590
              endif
            else
              write (stdout,'(a23)') '=> maxipp limit reached'
              stop '=>west'
            endif
          endif
c
c-----------------------------------------------------------------------
c         look north (only if not comming from north)
c-----------------------------------------------------------------------
c
          k2 = kmt(ie,jn)  * kmt(iw,jn)
          k3 = kmt(ie,j)   * kmt(iw,j)
          if (k2 .eq. 0 .or. k3 .eq. 0) then
            k = 0
          else
            k = 1
          endif
          if (kmt(i,jn) .ne. 0 .and. k .eq. 0 .and. jn .ne. j
     $        .and. dir .ne. 's') then
            if (lenp .lt. maxipp) then
              if (i .ne. i0 .or. jn .ne. j0) then
                dir          = 'n'
                lenp         = lenp + 1
                j            = jn
                iperm(lenp)  = i
                jperm(lenp)  = jn
                go to 580
              else
                go to 590
              endif
            else
              write (stdout,'(a23)') '=> maxipp limit reached'
              stop '=>north'
            endif
          endif
c
c-----------------------------------------------------------------------
c         look east (only if not comming from east)
c-----------------------------------------------------------------------
c
          k2 = kmt(ie,jn)  * kmt(ie,js)
          k3 = kmt(i,jn)   * kmt(i,js)
          if (k2 .eq. 0 .or. k3 .eq. 0) then
            k = 0
          else
            k = 1
          endif
          if (kmt(ie,j) .ne. 0 .and. k .eq. 0 .and. dir .ne. 'w') then
            if (lenp .lt. maxipp) then
              if (ie .ne. i0 .or. j .ne. j0) then
                dir          = 'e'
                lenp         = lenp + 1
                i            = ie
                iperm(lenp)  = ie
                jperm(lenp)  = j
                go to 580
              else
                go to 590
              endif
            else
              write (stdout,'(a23)') '=> maxipp limit reached'
              stop '=>east'
            endif
          endif
c
c-----------------------------------------------------------------------
c         look south (only if not comming from south)
c-----------------------------------------------------------------------
c
          k2 = kmt(ie,js)  * kmt(iw,js)
          k3 = kmt(ie,j)   * kmt(iw,j)
          if (k2 .eq. 0 .or. k3 .eq. 0) then
            k = 0
          else
            k = 1
          endif
          if (kmt(i,js) .ne. 0 .and. k .eq. 0 .and. js .ne. j
     $        .and. dir .ne. 'n') then
            if (lenp .lt. maxipp) then
              if (i .ne. i0 .or. js .ne. j0) then
                dir          = 's'
                lenp         = lenp + 1
                j            = js
                iperm(lenp)  = i
                jperm(lenp)  = js
                go to 580
              else
                go to 590
              endif
            else
              write (stdout,'(a23)') '=> maxipp limit reached'
              stop '=>south'
            endif
          endif
580     continue
590     continue
        nippts(n) = lenp - iofs(n)
        write (stdout,9000) n, nippts(n)
        ls = iofs(n) + 1
        le = lenp
        write (stdout,9100) (iperm(l),jperm(l), l=ls,le)
600   continue
c
c-----------------------------------------------------------------------
c     restore the original "kmt" field
c-----------------------------------------------------------------------
c
      do 700 j=1,jmt
        do 690 i=1,imt
          kmt(i,j) = kmz(i,j)
690     continue
700   continue
c
c-----------------------------------------------------------------------
c     if a fatal error was encountered print out error message and stop
c     otherwise load perimeter field into "kmz" and print it out
c-----------------------------------------------------------------------
c
      if (fatal) then
c
        write (stdout,*)
     $   ' Fatal error(s) in "iperim" land mass analysis'
        write (stdout,*)
     $    ' The "kmt" field must be fixed up before continuing ...'
        stop '=>iperim'
c
      else
c
c-----------------------------------------------------------------------
c     initialize scratch "kmz" field
c-----------------------------------------------------------------------
c
        do 800 j=1,jmt
          do 790 i=1,imt
            kmz(i,j) = 0
790       continue
800     continue
c
c-----------------------------------------------------------------------
c       identify perimeter points with island number
c-----------------------------------------------------------------------
c
        do 900 ni=1,nisle
          ls = iofs(ni) + 1
          le = ls + nippts(ni) - 1
          do 890 m=ls,le
            kmz(iperm(m),jperm(m)) = ni
890       continue
900     continue
c
c-----------------------------------------------------------------------
c       print out island perimeter field
c-----------------------------------------------------------------------
c
        linemx = 100
        linel  = 105
        line   = linel - 5
        if (line .gt. linemx) line = linemx
        nwr = (imt/line) + 1
c
        do 950 i=1,imt
          ncol(i) = mod(i,10)
950     continue
c
       write (stdout,9300)
        do 1000 n=1,nwr
          ia = 1 + (line*(n-1))
          ib = ia + line - 1
          if (ib .gt. imt) ib = imt
          write(stdout,9400) (ncol(i),i=ia,ib)
          do 990 jj=1,jmt
            jjj = jmt - jj + 1
            write(stdout,9500)jjj,(kmz(i,jjj),i=ia,ib)
990       continue
1000    continue
c
      endif
c
9000  format (/' Island # ',i2,' perimeter length is ',i4, ' points.'
     $, ' (i,j) coordinates are:'/)
9100  format (10(1x,'(',i4,',',i4,') '))
9200  format (///1x, ' ==> Error on island # ',i2,' at (i,j) = (',i4,','
     $,  i4,') ... (lon,lat) = (',f7.2,',',f7.2,')'/
     $, 1x,'    There must be at least two ocean points separating '
     $,    'an island and another land mass.'/)
9300  format (/,' Island perimeter locations '/)
9400  format('  i=>',100(i1))
9500  format(1x,i3,1x,100(i1))
c
#endif
      return
c
      end
#DECK isopyc.F
      subroutine isop0 (j)
c
#ifdef isopycmix
c=======================================================================
c
c     an adaptation of M. Cox's isopycnal diffusion code, after M. Redi
c     (this portion is called from subroutine step)
c
c     isopycmix does not yet work with microtasking, ntasks > 1, or
c     skipland
c     (because of need to have proper "esav" for all jsrows)
c
c   References:
c     Cox, M.D., 1987, Isopycnal diffusion in a z-coordinate model,
c       Ocean Modelling, issue 74, 1-5.
c     Redi, M.H., 1982, Oceanic isopycnal mixing by coordinate rotation,
c       J. Phys. Oceanogr., vol 12, 1154-1158, 1982.
c
c=======================================================================
c
#include "param.h"
#include "accel.h"
#include "chmix.h"
#include "cisop.h"
#include "ctask.h"
#include "cvmix.h"
#include "grdvar.h"
#include "slabs.h"
#include "temp.h"
c
      parameter ( c1e10 = 1.0e10 )
      parameter ( eps = 1.0e-25 )
c
c    "rx", "ry" & "rz" terms = store density differences used to compute
c               isopycnal diffusion tensor components "fk#"
c    "e" = density gradients (1=zonal; 2=meridional; 3=vertical)
c    "slmxr" = reciprocal of maximum allowable slope (limit mixing to
c        avoid numerical instabilities)
c    see "isop.h" for more details on variables listed above
c
c---------------------------------------------------------------------
c
c     compute five of the nine components of isopycnal diffusion tensor
c     and load coefficients into "fk..." arrays
c     components (1,1) & (2,2) of tensor are assumed = 1.0 (xx & yy)
c     components (1,2) & (2,1) of tensor are assumed = 0.0 (yx & xy)
c
c     scale density gradients by c1e10 to keep exponents in range later
c
c     numerical constraint:   slmxr > sqrt(4*ahisop*dt/dx*dz)
c     ("slmxr" can generally be 100 or less)
c
c---------------------------------------------------------------------
c
      if (j .eq. jsrow) then
c
c     for just the first jrow of a task, initialize the three "fk3"
c     coefficients (defined at the top of level one) to zero
c     (no diffusion of tracers through sea surface)
c
        do 100 i=1,imt
          fk3(i,1,1) = c0
          fk3(i,1,2) = c0
          fk3(i,1,3) = c0
100     continue
c
      else
c
c     for all tracer rows but the first row of a task, shift slabwise
c     rows of density differences
c
        do 200 k=1,km
          do 190 i=1,imt
            rx (i,k) = rxp(i,k)
            rys(i,k) = ryn(i,k)
            rz (i,k) = rzp(i,k)
190       continue
200     continue
c
        do 300 i=1,imt
          rz (i,kmp1) = rzp(i,kmp1)
300     continue
c
      endif
c
c     for all jrows...
c     load densities from row j+1 into tempik(i,k,1) & tempik(i,k,2)
c
      call statec ( t(1,1,jp,nm,1), t(1,1,jp,nm,2), tempik(1,1,1), 1)
      call statec ( t(1,1,jp,nm,1), t(1,1,jp,nm,2), tempik(1,1,2), 2)
c
c     calculate vertical density differences for j+1 row and load
c     into "rzp" (mult by phantom 1.e10)
c
c     first, subtract even numbered levels from the level above them
c
      do 400 k=2,km,2
        do 390 i=1,imt
          rzp(i,k) = fm(i,k-1,jp)*fm(i,k,jp)*c1e10*
     $               (tempik(i,k-1,1) - tempik(i,k,1))
390     continue
400   continue
c
c     second, subtract odd numbered levels from the level above them
c
      do 500 k=3,km,2
        do 490 i=1,imt
          rzp(i,k) = fm(i,k-1,jp)*fm(i,k,jp)*c1e10*
     $               (tempik(i,k-1,2) - tempik(i,k,2))
490     continue
500   continue
c
c     set vertical density differences to zero at top and bottom
c     interfaces
c
      do 600 i=1,imt
        rzp(i,1)    = c0
        rzp(i,kmp1) = c0
600   continue
c
c     load densities at center row j into tempik(i,k,1)
c     (compatible densities at row j+1 are still in tempik(i,k,2))
c
      call statec ( t(1,1,jc,nm,1), t(1,1,jc,nm,2), tempik(1,1,1), 2)
c
c     load east-center density differences at row j+1 into "rxp"
c     load north-center density differences (row j+1 - row j) into "ryn"
c     (multply "rxp" & "ryn"  by phantom 1.e10)
c
      do 700 k=1,km
        do 690 i=1,imtm1
          rxp(i,k) = fm(i+1,k,jp)*fm(i,k,jp)*c1e10*
     $               (tempik(i+1,k,2) - tempik(i,k,2))
          ryn(i,k) = fm(i  ,k,jp)*fm(i,k,jc)*c1e10*
     $               (tempik(i  ,k,2) - tempik(i,k,1))
690     continue
700   continue
c
      do 800 k=1,km
#ifdef cyclic
        rxp(imt,k) = rxp(2,k)
        ryn(imt,k) = ryn(2,k)
#else
        rxp(imt,k) = c0
        ryn(imt,k) = c0
#endif
800   continue
c
c     if this is the first row of a task, set up is finished
c     otherwise, continue with calculation of mixing tensors
c
      if (j .eq. jsrow .and. j .eq. 1) then
        do 900 m=1,nt
          do 890 k=1,km
            do 880 i=1,imt
              esav(i,k,m) = c0
880         continue
890       continue
900     continue
      endif

c NOTE: isopycmix does not yet work with microtasking yet
c       or for code using more than 1 tasks, or skipland option
c       (because of need to have proper "esav" for all jsrows)
c
c---------------------------------------------------------------------
c
       if (j .eq. jsrow) return
c
c---------------------------------------------------------------------
c
c     convert density differences into density gradients and load into
c     "e" to allow calculation of "fk1(3)" mixing component (xz).
c     resolved at center of eastern face of t,s box; at grid point
c     level "zt"; as indicated by "X" below.
c            lat/lon view               depth/lon view
c        u,v j   -> +-------+           +-------+ <- zw(k-1)
c                   |       |           |       |	
c        t,s j   -> |   i   X           |   i   X <- zt(k)
c                   |       |           |       |
c        u,v j-1 -> +-------+           +-------+ <- zw(k)
c
      do 1000 k=1,km
        do 990 i=1,imtm1
          e(i,k,1) = rx(i,k)*dxur(i)*cstr(j)
          e(i,k,2) = dyt4r(j)*
     $              (rys(i,k) + rys(i+1,k) + ryn(i,k) + ryn(i+1,k))
          e(i,k,3) = dzt2r(k)*p5*
     $              (rz(i,k) + rz(i+1,k) + rz(i,k+1) + rz(i+1,k+1))
990     continue
1000  continue
c
      do 1100 k=1,km
#ifdef cyclic
        e(imt,k,1) = e(2,k,1)
        e(imt,k,2) = e(2,k,2)
        e(imt,k,3) = e(2,k,3)
#else
        e(imt,k,1) = c0
        e(imt,k,2) = c0
        e(imt,k,3) = c0
#endif
1100  continue
c
c     use slmxr to limit slope of mixing in the vertical to guard
c     against numerical instabilities and compute the "fk1(3)"
c     mixing coefficient (zx).
c     "chkslp" = criterion used to check slope steepness
c
      do 1200 k=1,km
        do 1190 i=1,imt
          chkslp = -sqrt (e(i,k,1)**2 + e(i,k,2)**2) * slmxr * dtxsqr(k)
          if (e(i,k,3) .gt. chkslp) e(i,k,3) = chkslp
          fk1(i,k,3) = (-e(i,k,1)*e(i,k,3)*ahisop) / (e(i,k,3)**2 + eps)
1190    continue
1200  continue
c
c     convert density differences into density gradients and load into
c     "e" to allow calculation of "fk2(3)" mixing component. (zy)
c     resolved at center of northern face of t,s box; at grid point
c     level "zt"; as indicated by "X" below.
c            lat/lon view               depth/lon view
c        u,v j   -> +---X---+           +-------+ <- zw(k-1)
c                   |       |           |       |
c        t,s j   -> |   i   |           |   X   | <- zt(k)
c                   |       |           |       |
c        u,v j-1 -> +-------+           +-------+ <- zw(k)
c
      do 1300 k=1,km
        do 1290 i=2,imt
          e(i,k,1) = dxt4r(i)*csur(j)*
     $              (rx(i,k) + rx(i-1,k) + rxp(i,k) + rxp(i-1,k))
          e(i,k,2) = ryn(i,k)*dyur(j)
          e(i,k,3) = dzt2r(k)*p5*
     $              (rz(i,k) + rz(i,k+1) + rzp(i,k) + rzp(i,k+1))
1290    continue
1300  continue
c
      do 1400 k=1,km
#ifdef cyclic
        e(1,k,1) = e(imtm1,k,1)
        e(1,k,2) = e(imtm1,k,2)
        e(1,k,3) = e(imtm1,k,3)
#else
        e(1,k,1) = c0
        e(1,k,2) = c0
        e(1,k,3) = c0
#endif
1400  continue
c
c     use slmxr to limit slope of mixing in the vertical to guard
c     against numerical instabilities and compute the "fk2(3)"
c     mixing coefficient (zy).
c     "chkslp" = criterion used to check slope steepness
c
      do 1500 k=1,km
        do 1490 i=1,imt
          chkslp = -sqrt (e(i,k,1)**2 + e(i,k,2)**2) * slmxr * dtxsqr(k)
          if (e(i,k,3) .gt. chkslp) e(i,k,3) = chkslp
          fk2(i,k,3) = (-e(i,k,2)*e(i,k,3)*ahisop) / (e(i,k,3)**2 + eps)
1490    continue
1500  continue
c
c     convert density differences into density gradients and load into
c     "e" to allow calculation of the three "fk3(1:3)" tensor
c     components resolved at the center of upper face of t,s box; at
c     depth of "zw(k-1)" as indicated by "X" below.
c            lat/lon view               depth/lon view
c        u,v j   -> +-------+           +---X---+ <- zw(k-1)
c                   |       |           |       |
c        t,s j   -> |   X   |           |   i   | <- zt(k)
c                   |       |           |       |
c        u,v j-1 -> +-------+           +-------+ <- zw(k)
c
c     calculate density gradients at the top of all levels except k=1
c
      do 1600 k=2,km
        do 1590 i=2,imt
          e(i,k,1) = dxt4r(i)*cstr(j)*
     $              (rx(i,k-1) + rx(i-1,k-1) + rx(i,k) + rx(i-1,k))
          e(i,k,2) = dyt4r(j)*
     $              (rys(i,k) + rys(i,k-1) + ryn(i,k) + ryn(i,k-1))
          e(i,k,3) = dzwr(k-1)*rz(i,k)
1590    continue
1600  continue
c
      do 1700 k=2,km
#ifdef cyclic
        e(1,k,1) = e(imtm1,k,1)
        e(1,k,2) = e(imtm1,k,2)
        e(1,k,3) = e(imtm1,k,3)
#else
        e(1,k,1) = c0
        e(1,k,2) = c0
        e(1,k,3) = c0
#endif
1700  continue
c
c     use slmxr to limit slope of mixing in the vertical to guard
c     against numerical instabilities and compute the three "fk3"
c     mixing coefficients ("fk3(1)"=xz, "fk3(2)"=yz, "fk3(3)"=zz)
c     "chkslp" = criterion used to check slope steepness
c
      do 1800 k=2,km
        do 1790 i=1,imt
          chkslp = -sqrt (e(i,k,1)**2 + e(i,k,2)**2) * slmxr * dtxsqr(k)
          if (e(i,k,3) .gt. chkslp) e(i,k,3) = chkslp
1790    continue
1800  continue
c
c       "fk3(i,k,1)" and "fk3(i,k,2)" go to zero for uniform horizontal
c     densities.  otherwise, "fk3(i,k,1)" represents mixing across the
c     eastern face of the t,s box due to sloping isopycnals (xz) and
c     "fk3(i,k,2)" represents mixing across the northern face of the
c     t,s box due to sloping isopycnals (yz).
c       "fk3(i,k,3)" includes diffusion in the vertical due to sloping
c     isopycnals (zz).
c     later, in tracer, "fk3(i,k,3)" will be added into the vertical
c     (or almost diapycnic) mixing represented by the "vdc" variable
c     to get the full zz vertical mixing contribution.
c     (values for fk3 at k=1 were set at the top of this routine)
c
      do 1900 k=2,km
        do 1890 i=1,imt
          ahfctr = ahisop / (e(i,k,3)**2 + eps)
          fk3(i,k,1) = -e(i,k,3)*e(i,k,1)*ahfctr
          fk3(i,k,2) = -e(i,k,3)*e(i,k,2)*ahfctr
          fk3(i,k,3) = (e(i,k,1)**2 + e(i,k,2)**2)*ahfctr
1890    continue
1900  continue
c
#endif
      return
      end
      subroutine isop1 (j, mtrace)
c
#ifdef isopycmix
c=======================================================================
c
c     an adaptation of M. Cox's isopycnal diffusion code, after M. Redi
c     (this portion is called from subroutine tracer)
c
c=======================================================================
c
#include "param.h"
#include "chmix.h"
#include "cisop.h"
#include "cvmix.h"
#include "grdvar.h"
#include "slabs.h"
#include "temp.h"
c
c----------------------------------------------------------------------
c  compute isopycnal diffusion of tracers (except zz term)
c----------------------------------------------------------------------
c
      m = mtrace
c
c     use tracer gradients in the east - central (e(1)) and in the
c     north - central (e(2)) directions at all levels to calculate
c     effects of purely horizontal diffusion (uses the sum of the
c     along isopycnal and background horizontal diffusion coefficients
c     as the total diffusion coefficient)
c
      do 100 k=1,km
        do 90 i=1,imtm1
          e(i,k,1) = (ah + ahisop)*dxur(i)*cstr(j)*
     $               (t(i+1,k,jc,nm,m) - t(i,k,jc,nm,m))
          e(i,k,2) = (ah + ahisop)*dyur(j)*
     $               (t(i  ,k,jp,nm,m) - t(i,k,jc,nm,m))
90      continue
100   continue
c
c     for all but the top and bottom levels, add in the effects of
c     the along isopycnal diffusion computed using the "fk1" and "fk2"
c     mixing tensors (see subroutine isop0 for details)
c
      do 200 k=2,kmm1
        do 190 i=1,imtm1
          e(i,k,1) = e(i,k,1) + fk1(i,k,3)*dzt2r(k)*p5*
     $       ( fm(i  ,k-1,jc)*(t(i  ,k-1,jc,nm,m) - t(i  ,k  ,jc,nm,m))
     $       + fm(i+1,k-1,jc)*(t(i+1,k-1,jc,nm,m) - t(i+1,k  ,jc,nm,m))
     $       + fm(i  ,k+1,jc)*(t(i  ,k  ,jc,nm,m) - t(i  ,k+1,jc,nm,m))
     $       + fm(i+1,k+1,jc)*(t(i+1,k  ,jc,nm,m) - t(i+1,k+1,jc,nm,m)))
          e(i,k,2) = e(i,k,2) + fk2(i,k,3)*dzt2r(k)*p5*
     $       ( fm(i  ,k-1,jc)*(t(i  ,k-1,jc,nm,m) - t(i  ,k  ,jc,nm,m))
     $       + fm(i  ,k+1,jc)*(t(i  ,k  ,jc,nm,m) - t(i  ,k+1,jc,nm,m))
     $       + fm(i  ,k-1,jp)*(t(i  ,k-1,jp,nm,m) - t(i  ,k  ,jp,nm,m))
     $       + fm(i  ,k+1,jp)*(t(i  ,k  ,jp,nm,m) - t(i  ,k+1,jp,nm,m)))
190     continue
200   continue
c
c     do the special case of the top and bottom levels for e(1) & e(2).
c
      do 300 i=1,imtm1
        e(i, 1,1) = e(i, 1,1) + fk1(i, 1,3)*dzt2r( 1)*p5*
     $      ( fm(i  ,   2,jc)*(t(i  ,   1,jc,nm,m) - t(i  , 2,jc,nm,m))
     $      + fm(i+1,   2,jc)*(t(i+1,   1,jc,nm,m) - t(i+1, 2,jc,nm,m)))
        e(i,km,1) = e(i,km,1) + fk1(i,km,3)*dzt2r(km)*p5*
     $      ( fm(i  ,kmm1,jc)*(t(i  ,kmm1,jc,nm,m) - t(i  ,km,jc,nm,m))
     $      + fm(i+1,kmm1,jc)*(t(i+1,kmm1,jc,nm,m) - t(i+1,km,jc,nm,m)))
        e(i, 1,2) = e(i, 1,2) + fk2(i, 1,3)*dzt2r( 1)*p5*
     $      ( fm(i  ,   2,jc)*(t(i  ,  1,jc,nm,m) - t(i  ,  2,jc,nm,m))
     $      + fm(i  ,   2,jp)*(t(i  ,  1,jp,nm,m) - t(i  ,  2,jp,nm,m)))
        e(i,km,2) = e(i,km,2) + fk2(i,km,3)*dzt2r(km)*p5*
     $      ( fm(i  ,kmm1,jc)*(t(i  ,kmm1,jc,nm,m) - t(i  ,km,jc,nm,m))
     $      + fm(i  ,kmm1,jp)*(t(i  ,kmm1,jp,nm,m) - t(i  ,km,jp,nm,m)))
300   continue
c
c     apply land/sea masks: set mixing to zero if central point or
c     adjacent one is land.
c     "e(i,k,1)" represents diffusion at the eastern face arising from
c     the sloping isopycnal surfaces and from purely horizontal mixing
c     "e(i,k,2)" represents diffusion at the northern face arising from
c     the sloping isopycnal surfaces and from purely horizontal mixing
c
      do 400 k=1,km
        do 390 i=1,imtm1
          e(i,k,1) = fm(i+1,k,jc)*fm(i,k,jc)*e(i,k,1)
          e(i,k,2) = fm(i  ,k,jp)*fm(i,k,jc)*e(i,k,2)*csu(j)
390     continue
400   continue
c
c     e(i,k,3) represents diffusion at the top face arising from the
c     sloping isopycnal surfaces (xz + yz terms)
c
      do 500 k=2,km
        do 490 i=2,imtm1
          e(i,k,3) = fm(i  ,k-1,jc)*fm(i  ,k,jc)*
     $             ( fk3(i,k,1)*dxt4r(i)*cstr(j)*
     $       ( fm(i-1,k  ,jc)*(t(i  ,k  ,jc,nm,m) - t(i-1,k  ,jc,nm,m))
     $       + fm(i-1,k-1,jc)*(t(i  ,k-1,jc,nm,m) - t(i-1,k-1,jc,nm,m))
     $       + fm(i+1,k  ,jc)*(t(i+1,k  ,jc,nm,m) - t(i  ,k  ,jc,nm,m))
     $       + fm(i+1,k-1,jc)*(t(i+1,k-1,jc,nm,m) - t(i  ,k-1,jc,nm,m)))
     $             + fk3(i,k,2)*dyt4r(j)*
     $       ( fm(i  ,k  ,jm) * (t(i  ,k  ,jc,nm,m)-t(i  ,k  ,jm,nm,m))
     $       + fm(i  ,k-1,jm) * (t(i  ,k-1,jc,nm,m)-t(i  ,k-1,jm,nm,m))
     $       + fm(i  ,k  ,jp) * (t(i  ,k  ,jp,nm,m)-t(i  ,k  ,jc,nm,m))
     $       + fm(i  ,k-1,jp) * (t(i  ,k-1,jp,nm,m)-t(i  ,k-1,jc,nm,m)))
     $              )
490     continue
500   continue
c
c     set the values of e(3) to zero for level 1 and kmp1
c     for zero flux conditions through the surface and bottom
c
      do 600 i=1,imt
        e(i,   1,3) = c0
        e(i,kmp1,3) = c0
600   continue
c
      do 700 k=1,km
#ifdef cyclic
        e(imt,k,1) = e(2,k,1)
        e(imt,k,2) = e(2,k,2)
        e(imt,k,3) = e(2,k,3)
        e(1,k,3) = e(imtm1,k,3)
#else
        e(imt,k,1) = c0
        e(imt,k,2) = c0
        e(imt,k,3) = c0
        e(  1,k,3) = c0
#endif
700   continue
c
#endif
      return
      end
#DECK matrix.F
      subroutine matrix (array, irdim, istrt, im, jstrt, jm, scale)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c
c     matrix is a general two-dimensional array printing routine,
c     where:
c     array = the array to be printed
c     irdim = the 1st dimension of array
c     istrt = the 1st element of the 1st dimension to be printed
c     im    = the last element of the 1st dimension to be printed
c     jstrt = the 1st element of the 2nd dimension to be printed
c     jm    = the last element of the 2nd dimension to be printed
c             the 2nd dimension is printed in reverse order if both
c             jstrt & jm are negative
c     scale = a scaling factor by which array is divided before
c             printing.  (if this is zero, no scaling is done.)
c             if scale=0, 10 columns are printed across in e format
c             if scale>0, 20 columns are printed across in f format
c
c=======================================================================
c
#include "param.h"
c
      dimension array(irdim,1000)
c
c=======================================================================
c
      if (jstrt*jm .lt. 0) then
        write (stderr,999)  jstrt, jm
        stop '=>matrix'
      endif
c
c     allow for inversion of 2nd dimension
c
      if (jm .lt. 0) then
        js   = -jm
        je   = -jstrt
        jinc = -1
      else
        js   = jstrt
        je   = jm
        jinc = 1
      endif
c
      if (scale .eq. c0) then
c
        do 100 is=istrt,im,10
          ie = min(is + 9,im)
          write (stdout,9001) (i, i=is,ie)
          do 90 l=js,je,jinc
            write (stdout,9002) l, (array(i,l),i=is,ie)
90        continue
          write (stdout,'(//)')
100     continue
c
      else
c
        scaler = c1/scale
c
        do 200 is=istrt,im,20
          ie = min(is + 19,im)
          write (stdout,9003) (i, i=is,ie)
          do 190 l=js,je,jinc
            write (stdout,9004) l, (array(i,l)*scaler,i=is,ie)
190       continue
          write (stdout,'(//)')
200     continue
c
      endif
c
      return
c
999   format (1x,'jstrt=',i5,' jm=',i5,' in matrix')
9001  format(10i13)
9002  format(1x,i2,10(1pe13.5))
9003  format(3x,20i6)
9004  format(1x,i3,1x,20f6.2)
c
      end
#DECK nlmix.F
      subroutine nlmix(j)
#ifdef nlhmix
# ifdef microtasking
cfpp$ noconcur r
# endif
c=====================================================================
c
c     compute horizontal mixing coefficients based on Smagorinsky
c     non-linear viscosity as implemented and described in
c     Rosati & Miyakoda(jpo,vol 18,#11,1988).
c
#include "param.h"
#include "cnlmix.h"
#include "coord.h"
#include "cprnts.h"
#include "ctmngr.h"
#include "grdvar.h"
#include "slabs.h"
#include "switch.h"
c=======================================================================
c
c---------------------------------------------------------------------
c     compute tension rate of strain & shearing rate of strain
c     define dten,dshear at t row and u,v column
c---------------------------------------------------------------------
c
      fact1 = p5*cstr(j+1)
      fact2 = dytr(j+1)*cst(j+1)
      do 100 k=1,km
        do 90 i=2,imtm1
            dten(i,k) = ((u(i+1,k,jc,nm) + u(i+1,k,jp,nm))
     $                 - (u(i-1,k,jc,nm) + u(i-1,k,jp,nm)))
     $                 *fact1*dxu2r(i)
     $                 - (csur(j+1)*v(i,k,jp,nm) - csur(j)*v(i,k,jc,nm))
     $                 *fact2
          dshear(i,k) = ((v(i+1,k,jc,nm) + v(i+1,k,jp,nm))
     $                 - (v(i-1,k,jc,nm) + v(i-1,k,jp,nm)))
     $                 *fact1*dxu2r(i)
     $                 + (csur(j+1)*u(i,k,jp,nm) - csur(j)*u(i,k,jc,nm))
     $                 *fact2
90      continue
100   continue
#ifdef cyclic
      do 200 k=1,km
        dten(imt,k)   = dten(2,k)
        dshear(imt,k) = dshear(2,k)
        dten(1,k)     = dten(imtm1,k)
        dshear(1,k)   = dshear(imtm1,k)
200   continue
#endif
c
c---------------------------------------------------------------------
c     compute pure deformation
c---------------------------------------------------------------------
c
      do 300 k=1,km
        do 290 i=1,imt
          dpure(i,k) = sqrt(c2*(dten(i,k)**2 + dshear(i,k)**2))
290     continue
300   continue
c
c     compute effective anisentropic wavenumber of diffusing turbulence
c     for effective 2d isentropic wavenumber set effk & effky
c     to: (c28*sqrt(cs(j)*dxu(i)*dyu(j)))**2*sqrt2r
c
      sqrt2r   = c1/sqrt(c2)
      c28      = 0.28
      effky(j) = (c28*dyu(j))**2*sqrt2r
      do 400 i=1,imt
        effk(i) = (c28*csu(j)*dxu(i))**2*sqrt2r
400   continue
c
      if (diagts) then
c
c---------------------------------------------------------------------
c       print the solution at specified latitudes on diagnostic tsteps
c---------------------------------------------------------------------
c
        do 600 jlat=1,nlatpr
          jj = indp (prlat(jlat), yt, jmt)
          if (jj .eq. j .and. prlat(jlat) .le. yt(jmt)) then
            do 590 k=1,km
              do 580 i=1,imt
                dkmc(i,k) = effk(i)*dpure(i,k)
580           continue
590         continue
c
c           use pure deformation for diff coeff
c
            hfact = c1
            bah   = c0
            do 570 k=1,km
              do 560 i=2,imt
                dpt1 = p25*(dpure(i,k)  + dpure(i-1,k)
     $              + dpures(i,k) + dpures(i-1,k))
                dkhcx(i,k) = (effk(i)*hfact*dpures(i,k) + bah)
                dkhcy(i,k) = (effky(j)*hfact*dpt1 + bah)
560           continue
570         continue
            is = indp (prslon(jlat), xt, imt)
            ie = indp (prelon(jlat), xt, imt)
            ks = indp (prsdpt(jlat), zt, km)
            ke = indp (predpt(jlat), zt, km)
            fx = 1.0e-2
            scl = 1.e7
            write (stdout,9100) 'am ', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (dkmc(1,1), imt, is, ie, ks, ke, scl)
c
            scl = 1.e7
            write (stdout,9100) 'ahx', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (dkhcx(1,1), imt, is, ie, ks, ke, scl)
c
            scl = 1.e7
            write (stdout,9100) 'ahy', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (dkhcy(1,1), imt, is, ie, ks, ke, scl)
          endif
600     continue
      endif
9100  format(1x,a12,1x,'ts=',i10,1x,',j=',i3,', lat=',f6.2
     $,', lon:',f6.2,' ==> ',f6.2,', depth(m):',f6.1,' ==> ',f6.1
     $,', scaling=',1pg10.3)
c
#endif
      return
      end
#DECK ocean.F
      program ocean
c
c=======================================================================
c
c                        GFDL Modular Ocean Model
c
c
c             A primitive equation ocean model implemented by
c
c                R.C. Pacanowski   K. Dixon    A. Rosati
c
c                                at the
c
c              Geophysical Fluid Dynamics Laboratory /NOAA
c                         Princeton, NJ. 08542
c
c                         based on the work of
c
c         Kirk Bryan: A numerical method for the study of the  of the
c         circulation world ocean: 1969, J. Computat. Phys 4 347-376
c
c                                 and
c
c         the invaluable work of Mike Cox & Burt Semtner on earlier
c                       fortran implementations.
c
c
c        The GFDL Modular Ocean Model (acronym MOM) is a three
c        dimensional primitive equation ocean model intended  to be
c        a flexible tool useful for ocean and coupled air-sea modeling
c        applications over a wide range of space & time scales.
c        It is also intended to run efficiently on scalar, vector &
c        parallel architectures. The programming approach is
c        modular and additions to this model are encouraged to follow
c        this approach. Additional modules will be added with time and
c        new versions of this model will be released when ready. Please
c        refer to the READ_ME file for more details until the user's
c        guide is available.
c
c        Requirements:
c
c        Standard fortran 77 is used (except for use of namelist)
c        The preprocessor "cpp" (available on systems using "c" or UNIX)
c
c        Please refer questions or problems to:
c
c        R.C.P. e-mail: rcp@gfdl.princeton.edu    phone (609) 452-6527
c        K.D.   e-mail: kd@gfdl.princeton.edu     phone (609) 452-6574
c        A.R.   e-mail: ar@gfdl.princeton.edu     phone (609) 452-6584
c
c        Acknowlegments:
c
c        We wish to thank ...
c
c        Chris Kerr of Cray Research for his help in getting MOM to
c        autotask & multitask correctly.
c
c        Disclaimer:
c
c        MOM is an ocean modeling research tool at GFDL.
c        Others may freely use it but we assume no responsibility
c        for problems or incorrect use of MOM. To address this, we
c        have provided extensive diagnostic capability including
c        Global energetics & Regional term balances for the tracer and
c        momentum equations. It is left to the user to satisfy
c        (him/her)self that a particular configuration is working
c        correctly.
c
c
c=======================================================================
c
      external blkdta
c
#include "param.h"
#include "accel.h"
#include "cdiag.h"
#include "chmix.h"
#ifdef isopycmix
#include "cisop.h"
#endif
#include "coord.h"
#if defined fourfil || defined firfil
# include "cpolar.h"
#endif
#include "cprnts.h"
#include "cregin.h"
#ifdef ppvmix
# include "cppmix.h"
#endif
#include "crelax.h"
#include "ctask.h"
#include "ctmngr.h"
#include "cvbc.h"
#include "cvmix.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "iounit.h"
#include "levind.h"
#include "scalar.h"
#ifdef multitasking
# include "cshrbf.h"
# include "timelv.h"
#else
# include "slabs.h"
#endif
#include "switch.h"
#include "temp.h"
#include "versno.h"
#ifdef rigidlid
c
      dimension kmz(imt,jmt)
c
#endif
#ifndef readrmsk
c
      dimension ysr(nhreg), yer(nhreg), ylimr(nhreg+1)
c
c    "ysr", "yer" & "ylimr" are used to set up default horizontal
c                           regional masks (zonal bands)
c
#endif
c
      namelist /eddy/   am, ah, fkpm, fkph, bvdc, bvvc, cdbot
#ifdef tcvmix
     $,                 aq
#endif
#ifdef isopycmix
     $,                 ahisop, slmxr
#endif
#ifdef ppvmix
     $,                 fricmx, wndmix
#endif
     $,                 aidif
      namelist /tsteps/ dtts, dtuv, dtsf
      namelist /parms/  acor, mxscan, sor, crit
      namelist /contrl/ init, days, dgnstc, nmix, eb, restrt
     $,                 tsi, ntasks, ncon, travg, snaps
#ifdef islands
      namelist /iland/ alonis, alatis
#endif
c
c=======================================================================
c     begin introductory section
c=======================================================================
c
      open (stdin,file='ocean.in')
c
c     write MOM version info
c
      write (stdout,'(/25x,a80/)') model
c
c-----------------------------------------------------------------------
c     initialize various quantities
c-----------------------------------------------------------------------
c
      pi     = c4*atan(c1)
      radian = c360/(c2*pi)
      omega  = pi/43082.0
c
c-----------------------------------------------------------------------
c     read in run parameters
c-----------------------------------------------------------------------
c
      read  (stdin, contrl)
      write (stdout,contrl)
      read  (stdin, eddy)
      write (stdout,eddy)
      read  (stdin, tsteps)
      write (stdout,tsteps)
      read  (stdin, parms)
      write (stdout,parms)
#ifdef islands
      read (stdin, iland)
      write(stdout,iland)
#endif
#ifdef isopycmix
c
c-----------------------------------------------------------------------
c     print out tracer diffusion coefficients in isopycnal case
c-----------------------------------------------------------------------
c
      write(stdout,9101) am
      write(stdout,9102) ahisop, ah, slmxr
#endif
c
c-----------------------------------------------------------------------
c     set up model grids in x, y, & z
c-----------------------------------------------------------------------
c
      call grids
c
#if defined fourfil || defined firfil
c
c     compute sin and cos values for vector correction before filtering
c
      fx =  1.0e-10
      fxa = dxt(1)/radius
c
      do 110 i=2,imum1
        fxb = fxa*float(i-2)
        spsin(i) = sin(fxb)
        spcos(i) = cos(fxb)
        if (abs(spsin(i)) .lt. fx) spsin(i) = c0
        if (abs(spcos(i)) .lt. fx) spcos(i) = c0
110   continue
c
      spsin(1) = c0
      spcos(1) = c0
      spsin(imu) = c0
      spcos(imu) = c0
c
c     set up model indices for filtering high latitudes
c
      jfrst  = indp (rjfrst, yt, jmt)
      jft0   = indp (rjft0, yt, jmt)
      jft1   = indp (rjft1, yt, jmt)
      jft2   = indp (rjft2, yt, jmt)
      jfu0   = indp (rjfu0, yu, jmt)
      jfu1   = indp (rjfu1, yu, jmt)
      jfu2   = indp (rjfu2, yu, jmt)
      jskpt  = jft2-jft1
      jskpu  = jfu2-jfu1
      njtbft = (jft1-jfrst+1)+(jmtm1-jft2+1)
      njtbfu = (jfu1-jfrst+1)+(jmtm1-jfu2+1)
      if (njtbft .gt. jmtfil .or. njtbfu .gt. jmtfil) then
        write (stdout,9599) njtbft, njtbfu
        write (stderr,9599) njtbft, njtbfu
        stop '>ocean 1'
      endif
#  ifdef firfil
c
c     set "numflt" and "numflu" to filter more at higher latitudes
c     using "jft0" and "jfu0" as reference latitude rows.
c
      numfmx = imt * p25
      refcos = cst(jft0)
      write(stdout,9501) refcos, yt(jft0)
      do 170 j=jfrst,jmt
        if ((j .le. jft1 .or. j .ge. jft2) .and. j .ge. jfrst) then
          jj = j - jfrst + 1
          if (j .ge. jft2) jj = jj - jskpt + 1
          numflt(jj) = max(1,int(refcos/cst(j)))
          if (numflt(jj) .gt. numfmx) numflt(jj) = numfmx
          write(stdout,9502) j, jj, numflt(jj), yt(j)
        endif
170   continue
      refcos = csu(jfu0)
      write(stdout,9503) refcos, yu(jfu0)
      do 180 j=jfrst,jmt
        if ((j .le. jfu1 .or. j .ge. jfu2) .and. j .ge. jfrst) then
          jj = j - jfrst + 1
          if (j .ge. jfu2) jj = jj - jskpu + 1
          numflu(jj) = max(1,int(refcos/csu(j)))
          if (numflu(jj) .gt. numfmx) numflu(jj) = numfmx
          write(stdout,9502) j, jj, numflu(jj), yu(j)
        endif
180   continue
c
#  endif
#endif
c-----------------------------------------------------------------------
c     list code options chosen by user for this model run
c-----------------------------------------------------------------------
c
      call docmnt (stdout, .false., .false., .false., .false.)
c
c-----------------------------------------------------------------------
c     open the disk datasets
c-----------------------------------------------------------------------
c
      nbuf = 2
      call ostart (kontrl, 2, 2, 1)
      call ostart (kflds, nkflds*nwds, nwds, 1)
      call ostart (labs(1), jmt*nslab, nslab, nbuf)
      call ostart (labs(2), jmt*nslab, nslab, nbuf)
      call ostart (labs(3), jmt*nslab, nslab, nbuf)
c
c
c=======================================================================
c     end introductory section
c=======================================================================
c
c
c
c-----------------------------------------------------------------------
c     is this a start from initial conditions or a restart?
c     in either case, set the number of vertical levels on the "t" grid
c-----------------------------------------------------------------------
c
      open (iorest, access='SEQUENTIAL', form='UNFORMATTED')
c
      if (init) then
        call ocn1st
      else
        call rdrest
        call oget (kflds, nwds, 5*nwds+1, kmt)
      endif
c
c-----------------------------------------------------------------------
c     compute number of vertical levels on the "u" grid
c-----------------------------------------------------------------------
c
      do 800 j=1,jmt
        kmu(imt,j) = 0
800   continue
c
      do 900 i=1,imt
        kmu(i,jmt) = 0
900   continue
c
      do 1000 j=1,jmtm1
        do 990 i=1,imtm1
         kmu(i,j) = min (kmt(i,j), kmt(i+1,j), kmt(i,j+1), kmt(i+1,j+1))
990     continue
1000  continue
#ifdef cyclic
c
c     set cyclic conditions
c
      do 1100 j=1,jmt
        kmu(imt,j) = kmu(2,j)
1100  continue
#endif
#ifdef symmetry
c
c     set symmetry conditions
c
      do 1200 i=1,imt
        kmu(i,jmt) = kmu(i,jmtm2)
1200  continue
#endif
c
c---------------------------------------------------------------------
c     set the horizontal regional masks and names to be used when
c     computing averages on the "t" grid in subroutine region.
c     also set the vertical regional masks and names for use (along
c     with the horizontal ones) in term balance calculations for
c     tracers & momentum
c---------------------------------------------------------------------
c
c     open unit for tracer averages
c
      if (iotavg .ne. stdout) open (iotavg, access='SEQUENTIAL'
     $,                             form='FORMATTED')
#ifdef readrmsk
c
c    read in horizontal & vertical regional masks ("mskhr" & "mskvr")
c    and names ("hregnm" & "vregnm") on file "regionmasks" (unit iormsk)
c
      open (iormsk,file='regionmasks')
      call reg1st (iormsk, .true., .false., .false., .false., .true.)
      close (iormsk)
#else
c
c     set up the horizontal regions:
c     specify "mskhr" and "hregnm" values rather than reading them in
c     from a file.  (arbitrarily defaulted below for 5 zonal bands)
c
      xlimr  = xt(2)
      xstart = xt(indp (xlimr, xt, imt))
      xlimr  = xt(imtm1)
      xend   = xt(indp (xlimr, xt, imt))
c
      ylimr(1) = -90.0
      ylimr(2) = -60.0
      ylimr(3) = -23.0
      ylimr(4) =  23.0
      ylimr(5) =  60.0
      ylimr(6) =  90.0
c
      do 185 nr=1,nhreg
        jsr = indp (ylimr(nr), yt, jmt)
        if (ylimr(nr) .ge. yt(jsr)) jsr = jsr + 1
        jer = indp (ylimr(nr+1), yt, jmt)
        if (ylimr(nr+1) .lt. yt(jer)) jer = jer - 1
        ysr(nr) = yt(jsr)
        yer(nr) = yt(jer)
        write (hregnm(nr),9301) xstart, xend, ysr(nr), yer(nr)
185   continue
c
      do 200 j=1,jmt
        jmask = 0
        do 190 nr=1,nhreg
          if (yt(j).ge.ysr(nr) .and. yt(j).le.yer(nr)) jmask = nr
190     continue
        do 195 i=1,imt
          mskhr(i,j) = 0
          if (kmt(i,j) .gt. 0 .and. xt(i) .ge. xstart
     $       .and. xt(i) .le. xend)  mskhr(i,j) = jmask
195     continue
#ifdef cyclic
        mskhr(1,j)   = 0
        mskhr(imt,j) = 0
#endif
200   continue
c
c     set up the vertical regions:
c     specify "mskvr" and "vregnm" values. also the starting & ending
c     levels for the vertical regions. (arbitrarily defaulted as shown)
c
      do 270 k=1,km
        mskvr(k) = 0
270   continue
      llvreg(1,1) = 1
      llvreg(1,2) = 4
      llvreg(2,1) = 5
      llvreg(2,2) = 9
      do 290 n=1,nvreg
        ks = llvreg(n,1)
        ke = llvreg(n,2)
        itop = nint((zw(ks)-dzt(ks))*0.01)
        ibot = nint(zw(ke)*0.01)
        write (vregnm(n),'(a6,i4,a5,i4,a1)') "  dpt: ",itop, "m to "
     $,                                      ibot, "m"
        do 280 k=ks,ke
          mskvr(k) = n
280     continue
290   continue
#endif
c
c     print out regional mask info
c
      call reg1st (iotavg, .true., .false., .false., .true., .false.)
c
c---------------------------------------------------------------------
c     compute the surface area and volume of the ocean regions
c     (values used in subroutine region are done in terms of meters,
c     rather than centimeters)
c---------------------------------------------------------------------
c
      areag = c0
      volgt  = c0
c
      do 300  k=1,km
        volgk(k) = c0
300   continue
c
      do 380 n=0,numreg
        areat(n) = c0
        areau(n) = c0
        volt(n)  = c0
        volu(n)  = c0
380   continue
      do 400 mask=1,nhreg
        areab(mask) = c0
        volbt(mask) = c0
        do 390  k=1,km
          volbk(mask,k) = c0
390     continue
400   continue
c
      do 500 j=2,jmtm1
        do 490 i=2,imtm1
          mask = mskhr(i,j)
          kz = kmt(i,j)
          if (kz .gt. 0) then
            boxat = cst(j) * dxt(i) * dyt(j)
            if (kmu(i,j) .ne. 0) then
              boxau = csu(j) * dxu(i) * dyu(j)
            else
              boxau = c0
            endif
            areat(0) = areat(0) +  boxat
            areau(0) = areau(0) +  boxau
            if (mask .gt. 0) areab(mask)  = areab(mask) + boxat * 1.e-4
            do 480 k=1,kz
              if (mask .gt. 0) then
                volbk(mask,k) = volbk(mask,k) + boxat * dzt(k) * 1.e-6
              endif
              dvolt   = boxat * dzt(k)
              if (kmu(i,j) .ge. k) then
                dvolu   = boxau * dzt(k)
              else
                dvolu   = c0
              endif
              volt(0) = volt(0) +  dvolt
              volu(0) = volu(0) +  dvolu
              n = nhreg*(mskvr(k)-1) + mask
              if (n .gt. 0 .and. mask .gt. 0) then
                volt(n) = volt(n) +  dvolt
                volu(n) = volu(n) +  dvolu
                do 470 nv=1,nvreg
                  ks = llvreg(nv,1)
                  if (k .eq. ks) then
                    areat(n) = areat(n) +  boxat
                    areau(n) = areau(n) +  boxau
                  endif
470             continue
              endif
480         continue
          endif
490     continue
500   continue
c
c     prevent possible divides by zero in subroutine diag2 by replacing
c     regions with zero areas or volumes with very small values
c
      do 550 n=0,numreg
        if (areat(n) .eq. c0) areat(n) = epsln
        if (areau(n) .eq. c0) areau(n) = epsln
        if (volt(n)  .eq. c0) volt(n)  = epsln
        if (volu(n)  .eq. c0) volu(n)  = epsln
550   continue
c
      do 600 mask=1,nhreg
        do 590 k=1,km
          volbt(mask) = volbt(mask) + volbk(mask,k)
          volgk(k) = volgk(k) + volbk(mask,k)
590     continue
        areag = areag + areab(mask)
        volgt = volgt + volbt(mask)
600   continue
c
      call reg1st (iotavg, .true., .true., .true., .false., .false.)
c
      area   = c0
      volume = c0
      ocnp   = 0
c
c     this comment directive turns off autotasking on the YMP
c     for the following loop
c
cfpp$ noconcur l
      do 700 j=2,jmtm1
        do 690 i=2,imtm1
          if (kmt(i,j) .gt. 0) then
            area   = area + cst(j)*dxt(i)*dyt(j)
            volume = volume + cst(j)*dxt(i)*dyt(j)*zw(kmt(i,j))
            ocnp   = ocnp + float(kmt(i,j))
          endif
690     continue
700   continue
c
      sum = c0
      do 790 n=1,numreg
        sum = sum + volt(n)
790   continue
      sum    = 100.0*sum/volume
      pctocn = 100.0*ocnp/float((imt-2)*(jmt-2)*km)
      diffa  = 100.0 * (c1 - (area - 10000.0*areag)/area)
c
      write (stdout,9341) area, volume
      write (stdout,9342) diffa, numreg, sum, pctocn
c
      if (init) then
c
c---------------------------------------------------------------------
c       print map of "kmt" levels. (to print "kmu", set ikmu=1)
c---------------------------------------------------------------------
c
        ikmu = 0
        if (ikmu .ne. 0) then
          write (stdout,9401)
        else
          write (stdout,9402)
        endif
        do 1300 ibk=1,imt,40
          isp  = ibk
          iept = ibk + 40 - 1
          if(iept.gt.imt) iept=imt
          write (stdout,'(/, 4x, 40i3)') (ii, ii=isp,iept)
          do 1290 jrev=1,jmt
            j=jmt-jrev+1
            if (ikmu .ne. 0) then
              write (stdout,'(1x,i3, 40i3)')
     $               j, (kmu(i,j),i=isp,iept)
            else
              write (stdout,'(1x,i3, 40i3)')
     $               j, (kmt(i,j),i=isp,iept)
            endif
1290      continue
1300    continue
      endif
#ifdef islands
c
c-----------------------------------------------------------------------
c     find the island perimeter paths
c-----------------------------------------------------------------------
c
      call iperim (kmz)
#endif
c
c---------------------------------------------------------------------
c     compute depths and reciprocal depths
c---------------------------------------------------------------------
c
      do 1400 j=1,jmt
        do 1390 i=1,imt
          hr(i,j) = c0
          h(i,j)  = c0
          if (kmu(i,j) .ne. 0) then
            hr(i,j) = c1/zw(kmu(i,j))
            h (i,j) = zw(kmu(i,j))
          endif
1390    continue
1400  continue
#ifdef rigidlid
c
c-----------------------------------------------------------------------
c     compute an array to indicate "interior" stream function grid boxes
c-----------------------------------------------------------------------
c
      do 1500 j=1,jmt
        kmz(1,j)   = 0
        kmz(imt,j) = 0
1500  continue
c
      do 1600 i=1,imt
        kmz(i,1)   = 0
        kmz(i,jmt) = 0
1600  continue
c
      do 1700 j=2,jmtm1
        do 1690 i=2,imu
          kmz(i,j) = min(kmu(i-1,j-1), kmu(i,j-1), kmu(i-1,j), kmu(i,j))
     $
1690    continue
1700  continue
#  ifdef cyclic
c
c     set cyclic conditions
c
      do 1800 j=1,jmt
        kmz(1,j) = kmz(imtm1,j)
1800  continue
#  endif
c
c---------------------------------------------------------------------
c     compute longitudinal start & end indices for tracer, velocity &
c     stream function calculations
c---------------------------------------------------------------------
c
      do 1900 l=1,lseg
        do 1890 j=1,jmt
          isz(j,l) = 0
          iez(j,l) = 0
          ist(j,l) = 0
          iet(j,l) = 0
          isu(j,l) = 0
          ieu(j,l) = 0
1890    continue
1900  continue
      lsegp = lseg + 1
#ifdef skipland
c
c     indices for tracer calculations over ocean points
c
      do 2000 j=2,jmtm1
        l=1
        do 1990 i=2,imtm1
          if (kmt(i-1,j) .eq. 0 .and. kmt(i,j) .ne. 0) ist(j,l) = i
          if (i .eq. 2 .and. kmt(1,j) .ne. 0)          ist(j,l) = i
          if (kmt(i,j) .ne. 0 .and. kmt(i+1,j) .eq. 0) iet(j,l) = i
          if (i .eq. imtm1 .and. kmt(i+1,j) .ne. 0)    iet(j,l) = i
          if (kmt(i,j) .ne. 0 .and. kmt(i+1,j) .eq. 0) l=l+1
          if (l .gt. lsegp) then
            write (stderr,9499) ' tracer         ',j, lsegp
            stop ' ocean 2'
          endif
1990    continue
2000  continue
c
c     indices for velocity calculations over ocean points
c
      do 2100 j=2,jmtm1
        l=1
        do 2090 i=2,imum1
          if (kmu(i-1,j) .eq. 0 .and. kmu(i,j) .ne. 0) isu(j,l) = i
          if (i .eq. 2 .and. kmu(1,j) .ne. 0)          isu(j,l) = i
          if (kmu(i,j) .ne. 0 .and. kmu(i+1,j) .eq. 0) ieu(j,l) = i
          if (i .eq. imum1 .and. kmu(i+1,j) .ne. 0)    ieu(j,l) = i
          if (kmu(i,j) .ne. 0 .and. kmu(i+1,j) .eq. 0) l=l+1
          if (l .gt. lsegp) then
            write (stderr,9499) ' velocity       ',j, lsegp
            stop ' ocean 3'
          endif
2090    continue
2100  continue
#endif
c
c     indices for stream function calculation
c
      do 2200 j=3,jscan
        l=1
        do 2190 i=2,imum1
          if (kmz(i-1,j) .eq. 0. .and. kmz(i,j) .ne. 0.) isz(j,l)=i
          if (i .eq. 2 .and. kmz(imt,j) .ne. 0.) isz(j,l)=2
          if (kmz(i,j) .ne. 0. .and. kmz(i+1,j) .eq. 0.) iez(j,l)=i
          if (i .eq. imum1 .and. kmz(i+1,j) .ne. 0.) iez(j,l)=i
          if (kmz(i,j) .ne. 0. .and. kmz(i+1,j) .eq. 0.) l=l+1
          if (l .gt. lsegp) then
            write (stderr,9499) ' stream function',j, lsegp
            stop ' ocean 4'
          endif
2190    continue
2200  continue
#ifdef skipland
c
      write (stdout,9451) ' tracer '
c
      do 2300 jrev=1,jmt
        j = jmt - jrev + 1
        write (stdout,9461) j, (ist(j,l),iet(j,l),l=1,lseg)
2300  continue
c
      write (stdout,9451) ' velocity '
c
      do 2400 jrev=1,jmt
        j = jmt - jrev + 1
        write (stdout,9461) j, (isu(j,l),ieu(j,l),l=1,lseg)
2400  continue
#endif
c
      write (stdout,9451) ' stream function '
c
      do 2500 jrev=1,jmt
        j = jmt - jrev + 1
        write (stdout,9461) j, (isz(j,l),iez(j,l),l=1,lseg)
2500  continue
#endif
#ifdef fourfil
c
c---------------------------------------------------------------------
c     find and print start & end indices for filtering
c---------------------------------------------------------------------
c
      write (stdout,9551)
      if (lsegf.gt.11) write (stdout,9552)
      write (stdout,9553)
      call findex (kmt, jmtfil, km, jft1, jft2, imt, istf, ietf)
      write (stdout,9554)
      call findex (kmu, jmtfil, km, jfu1, jfu2, imu, isuf, ieuf)
      write (stdout,9555)
      call findex (kmz, jmtfil, 1, jfu1, jfu2, imt, iszf, iezf)
#endif
c
c---------------------------------------------------------------------
c     print out ts timestep multipliers
c---------------------------------------------------------------------
c
      write (stdout,9601) (dtxcel(k),k=1,km)
#ifdef isopycmix
c
c-----------------------------------------------------------------------
c     store the square root of the tracer timestep acceleration values
c     into variable "dtxsqr" for use in isopycnal mixing
c-----------------------------------------------------------------------
c
      do 2550 k=1,km
       dtxsqr(k) = sqrt(dtxcel(k))
2550  continue
#endif
c
c-----------------------------------------------------------------------
c     read in control block & set relative time in years for tmngr
c-----------------------------------------------------------------------
c
      call oget (kontrl, 2, 1, itt)
      relyr = years
c
c-----------------------------------------------------------------------
c     compute permuting disc indicators and read in 2 levels of
c     stream function.
c-----------------------------------------------------------------------
c
      ndisk  = mod(itt+0,3) + 1
      ndiska = mod(itt+1,3) + 1
c
      call oget (kflds, nwds, (ndisk-1)*nwds+1, p(1,1,2))
      call oget (kflds, nwds, (ndiska-1)*nwds+1, p(1,1,1))
c
c-----------------------------------------------------------------------
c     initialize various things
c-----------------------------------------------------------------------
c
      do 2600 j=1,jmt
        do 2590 i=1,imt
          ztd(i,j) = c0
          zu(i,j)  = c0
          zv(i,j)  = c0
2590    continue
2600  continue
c
c     initialize the coriolis factor
c
      do 2660 j=1,jmt
        fcor(j) = c2*omega*sine(j)
2660  continue
c
c     initialize the diffusion factors
c
#ifdef biharmonic
      asubh = sqrt(ah)
      asubm = sqrt(am)
#endif
#ifdef consthmix
      asubh = ah
      asubm = am
#endif
#ifdef nlhmix
      asubh = c1
      asubm = c1
#endif
      do 2670 j=2,jmtm1
        bbt(j) = asubh*c8*cstr(j)*cstr(j)
        cct(j) = asubh*csu(j  )*dyur(j  )*dytr(j)*cstr(j)
        ddt(j) = asubh*csu(j-1)*dyur(j-1)*dytr(j)*cstr(j)
c
        bbu(j) = asubm*c8*csur(j)*csur(j)
        ccu(j) = asubm*cst(j+1)*dytr(j+1)*dyur(j)*csur(j)
        ddu(j) = asubm*cst(j  )*dytr(j  )*dyur(j)*csur(j)
        ggu(j) = asubm*(c1-tng(j)*tng(j))/(radius*radius)
        hhu(j) = asubm*c2*sine(j)/(radius*csu(j)*csu(j))
2670  continue
c
c-----------------------------------------------------------------------
c     set up the division of slabs into chunks by means of starting
c     and ending indices.  there may be one or more slabs per chunk.
c     each chunk will be a task to be completed by a single processor.
c     when "multitasking", multiple processors are deployed against the
c     available tasks. tasks may be done in any order but within a task
c     slabs are handled sequentially (in order).
c-----------------------------------------------------------------------
c
      nchunk = min(ntasks,jmt-2)
      inc   = max((nchunk+jmt-2)/nchunk, 1)
      jxtra = inc*nchunk - (jmt-1)
      jtemp = 1
      write (stdout,'(/,1x,"Tasking configuration: ")')
      write (stdout,'(/,1x,a6,4x,a10,4x,a10,4x,a10)') "task #"
     $,        "chunk size","start row","end row"
      do 2680 ntask=1,nchunk
        jsrowb(ntask) = jtemp
        jerowb(ntask) = min(jmt-1,jsrowb(ntask)+inc)
        if (ntask .le. jxtra) jerowb(ntask) = jerowb(ntask)-1
        jtemp         = jerowb(ntask)
        ilen          = jerowb(ntask)-jsrowb(ntask)+1
        write (stdout,'(1x,i5,5x,i10,4x,i10,4x,i10)')
     $         ntask, ilen, jsrowb(ntask), jerowb(ntask)
2680  continue
c
c-----------------------------------------------------------------------
c     do all consistency checks now
c-----------------------------------------------------------------------
c
      call checks
c
#ifdef timing
c    measure cp & wall clock time neglecting overhead of "ocean"
c
      cps   = second()
      walls = timef()
c
#endif
c-----------------------------------------------------------------------
c     open units for term balances & saving data
c-----------------------------------------------------------------------
c
      open (iosnap, access='SEQUENTIAL', form='UNFORMATTED')
      if (iotrmb .ne. stdout) open (iotrmb, access='SEQUENTIAL'
     $,                             form='FORMATTED')
c
c-----------------------------------------------------------------------
c     start the time step loop
c-----------------------------------------------------------------------
c
      do 3400 loop=1,9999999
c
c-----------------------------------------------------------------------
c       update timestep counter, set corresponding model time, and set
c       all time dependent logical switches to determine program flow
c-----------------------------------------------------------------------
c
        call tmngr (dtts)
c
c-----------------------------------------------------------------------
c       should a copy of the data be saved for off line analysis?
c-----------------------------------------------------------------------
c
        if (snapts) then
          write (iosnap) itt, dtts, relyr, stamp
          write (iosnap) xt, yt, zt
        endif
c
c-----------------------------------------------------------------------
c       adjust various quantities for normal/mixing timesteps
c-----------------------------------------------------------------------
c
        mxpas2 = .false.
        eots   = .true.
        if (mixts) then
          if (eb) eots = .false.
          c2dtts = dtts
          c2dtuv = dtuv
          c2dtsf = dtsf
          do 2700 j=1,jmt
            do 2690 i=1,imt
              p(i,j,2) = p(i,j,1)
2690        continue
2700      continue
        else
          c2dtts = c2*dtts
          c2dtuv = c2*dtuv
          c2dtsf = c2*dtsf
        endif
c
c-----------------------------------------------------------------------
c       update  pointers (indices) to tau-1, tau, & tau+1 discs
c-----------------------------------------------------------------------
c
#ifdef diskless
#  ifdef multitasking
        ndiskb = mod(itt+2,ntlev) + 1
        ndisk  = mod(itt  ,ntlev) + 1
        ndiska = mod(itt+1,ntlev) + 1
#  else
        ndiskb = mod(itt+1,ntlev) + 1
        ndisk  = mod(itt  ,ntlev) + 1
        ndiska = ndiskb
#  endif
#else
        ndiskb = mod(itt+2,ntlev) + 1
        ndisk  = mod(itt  ,ntlev) + 1
        ndiska = mod(itt+1,ntlev) + 1
#endif
c
2800    continue
c
c-----------------------------------------------------------------------
c       initialize various quantities for on line integral analysis
c-----------------------------------------------------------------------
c
        if (prntsi) then
          do 2900 j=1,jmt
            do 2890 k=0,km
              ektot(k,j) = c0
              do 2880 m=1,nt
                dtabs(k,m,j) = c0
2880          continue
2890        continue
2900      continue
        endif
c
c-----------------------------------------------------------------------
c       the memory slab window is "ntau" time levels deep.
c       set time pointers (indices) for the memory slab window.
c       (note: these pointers (indices) are distinct from the disc
c        pointers (indices) .)
c       nc = current tau, np = tau + 1, nm = tau - 1
c       note: np is currently not used since tau+1 data is stored in
c       the buffer slab "ta, ua, va"
c-----------------------------------------------------------------------
c
        nm = mod(itt+1,ntau) + 1
        nc = mod(itt  ,ntau) + 1
        np = mod(itt+2,ntau) + 1
c
c-----------------------------------------------------------------------
c       cycle chunks of slabs from disk into the memory slab window.
c       perform calculations then cycle chunks back to disk. on tracer
c       averaging or diagnostic time steps, allow only one chunk of
c       "jmt-2" slabs ... otherwise arbitrary chunk sizes are allowed.
c-----------------------------------------------------------------------
c
        if (diagts .or. tavgts .or. snapts) then
          ntask = 0
          call step (ntask)
        else
#ifdef multitasking
c
c         the parallel region starts with this loop.
c         everything called from "step.F" is within the parallel region
c
cmic$ doall
#endif
          do 3000 ntask=1,nchunk
            call step (ntask)
3000      continue
        endif
c
c-----------------------------------------------------------------------
c       print on line integral analysis
c-----------------------------------------------------------------------
c
        if (eots .and. prntsi) then
          do 3100 j=2,jmtm1
            do 3070 k=km,1,-1
              ektot(0,1) = ektot(0,1) + ektot(k,j)
3070        continue
            do 3090 m=1,nt
              do 3080 k=km,1,-1
                dtabs(0,m,1) = dtabs(0,m,1) + dtabs(k,m,j)
3080          continue
3090        continue
3100      continue
          ektot(0,1) = ektot(0,1)/volume
          do 3200 m=1,nt
            dtabs(0,m,1)=dtabs(0,m,1)/volume
3200      continue
          write (stdout,9602) itt, stamp, ektot(0,1), dtabs(0,1,1)
     $,                      dtabs(0,2,1), mscan
        endif
c
c-----------------------------------------------------------------------
c       construct the vorticity
c-----------------------------------------------------------------------
c
        call vort
c
c-----------------------------------------------------------------------
c       solve for the new stream function
c-----------------------------------------------------------------------
c
#ifdef rigidlid
# ifdef congrad5pt
c       use 5 point laplacian
c
        call congr5
# endif
# ifdef congrad9pt
c       use 9 point laplacian allowing for more accurate reconstrucion
c       of the rigid lid surface pressure
c
        call congr9
# endif
# ifdef oldrelax
c       use sequential over-relaxation to solve the laplacian equation
c       the same as in the codes of Cox (1984) and Semtner (1974)
c
        call relax
# endif
# ifdef hypergrid
c       use sequential over-relaxation to solve the laplacian along
c       diagonals to allow for complete vectorization & parallelization
c
        call hyper
# endif
c
c-----------------------------------------------------------------------
c       should a copy of the data be saved for off line analysis?
c-----------------------------------------------------------------------
c
        if (eots .and. snapts) then
          do 3220 j=1,jmt
            do 3210 i=1,imt
              res(i,j) = p(i,j,1)
3210        continue
3220      continue
          write (iosnap) res
        endif
#endif
c
c-----------------------------------------------------------------------
c       calculate & print the remaining diagnostics outside the parallel
c       region
c-----------------------------------------------------------------------
c
        if (eots .and. diagts) call diag2
c
c-----------------------------------------------------------------------
c       if this is the end of the 1st pass of an euler backward timestep
c       set the input disc units so that the proper levels are fetched
c       on the next pass. the output for the 2nd pass will be placed on
c       the "ndiska" unit. return to the top to do the 2nd pass.
c-----------------------------------------------------------------------
c
        if (mixts .and. eb) then
          eots   = .true.
          mixts  = .false.
          mxpas2 = .true.
          ndiskx = ndiskb
          ndiskb = ndisk
          ndisk  = ndiska
          ndiska = ndiskx
          go to 2800
        endif
#if !defined diskless || defined multitasking
c
c-----------------------------------------------------------------------
c       if this is the end of the 2nd pass of an euler backward timestep
c       transfer data which was temporarily written to "ndiskx" to its
c       final destination (the original "ndiska")
c-----------------------------------------------------------------------
c
        if (mxpas2) then
          ndiska = ndisk
          ndisk  = ndiskb
c
          do 3300 j=2,jmtm1
            call oget (labs(ndiskx), nslab, (j-1)*nslab+1, ta)
            call oput (labs(ndiska), nslab, (j-1)*nslab+1, ta)
3300      continue
        endif
#endif
c
c-----------------------------------------------------------------------
c       after everything is complete for this time step, update the
c       stream functions & control block on disk. also, set "first"
c       to .false.
c-----------------------------------------------------------------------
c
        years = relyr
        call oput (kflds, nwds, mod(itt+1,3)*nwds+1, p(1,1,1))
        call oput (kontrl, 2, 1, itt)
        if (loop .eq. 1) first = .false.
c
        if (last) go to 3401
3400  continue
3401  continue
#ifdef timing
c
c     use cray specific timing calls
c
      cpe   = second()
      walle = timef()
      write (stdout,'(/,1x, a16, f9.3, a12, f9.3, a19)')
     $      'timing summary: ', cpe - cps,  ' cp seconds,',
     $                (walle - walls)/1000.0, ' wall clock seconds'
      write (stdout,'(16x, a1, g14.7, a42,/)')
     $    '(',(cpe-cps)/(loop*imt*jmt*km),
     $' cp seconds per grid point per time step)'
#endif
c
c-----------------------------------------------------------------------
c     documentation info at end of run
c-----------------------------------------------------------------------
c
      call docmnt (stdout, .true., .true., .true., .true.)
c
c-----------------------------------------------------------------------
c     save restart at end of run if restrt is true
c-----------------------------------------------------------------------
c
      if (restrt) call wrrest
c
c-----------------------------------------------------------------------
c     close all units
c-----------------------------------------------------------------------
c
      call oclose (kontrl)
      call oclose (kflds)
      call oclose (labs(1))
      call oclose (labs(2))
      call oclose (labs(3))
      close (unit=stdin,status='keep')
      if (stderr .ne. stdout) close (unit=stderr,status='keep')
      if (iotavg .ne. stdout) close (unit=iotavg,status='keep')
      if (iorest .ne. stdout) close (unit=iorest,status='keep')
      if (iotrmb .ne. stdout) close (unit=iotrmb,status='keep')
      write (stdout,'(1x,a7)') 'MOMdone'
      close (unit=stdout,status='keep')
c
      stop
c
#ifdef isopycmix
9101  format(/' am = ',e12.6,' cm**2/sec for horizontal mixing of ',
     $'momentum')
9102  format(/' ahisop = ',e12.6,' along isopyncal tracer mixing '
     $,  '(cm**2/sec) '/' ah = ',e12.6,' cm**2/sec for background '
     $,  'horizontal tracer diffusion'/' slmxr = ',e12.6,' to limit '
     $,  'slope used in computing mixing tensors')
#endif
9301  format ('lon: ',f5.1,' => ',f5.1,'  lat: ',f5.1,' => ',f5.1,2i7)
9341  format (//,'  Regional & Global ocean statistics:'
     $,/,'  the total ocean surface area (t grid) =',1pe15.8,'cm**2'
     $,/,'  the total ocean volume (t grid)       =',1pe15.8,'cm**3')
9342  format ('  the horizontal regional masks cover',f8.3
     $, '% of the total ocean surface area.'/
     $, '  there are ', i6, ' regions over which tracer & '
     $, 'momentum balances will be computed',/,'  accounting for '
     $, f6.2,'% of the total ocean volume.'/
     $, 1x,f6.2,'% of the grid points lie within the ocean.'/)
9401  format(/t50,'number of levels on "u,v" grid')
9402  format(/t50,'number of levels on "t,s" grid')
9451  format (/' ==== start and end indices for',a17,'====')
9461  format (' j=',i3,5x,5(2i5,10x))
9499  format (/' error => lseg too small for',a15,' indices'
     $        /'          j =',i5,'  lseg + 1 =',i8)
#ifdef firfil
9501  format(/' firfil reference cosine for tracers =',e12.6,' (',
     $       f7.3,' deg)'/'     jrow      jj numflt(jj)  latitude')
9502  format(1x,3i8,6x,f7.3)
9503  format(/' firfil reference cosine for velocities =',e12.6,' (',
     $       f7.3,' deg)'/'     jrow      jj numflu(jj)  latitude')
#endif
#if defined fourfil  || defined firfil
9551  format (/' ==== start and end indices for fourier filtering ====')
9552  format (' only 11 sets of indices fit across the page.',
     $       '  others will not be printed.'/)
9553  format (/,' == filtering indices for t,s ==')
9554  format (/,' == filtering indices for u,v ==')
9555  format (/,' == filtering indices for stream function ==')
9599  format (/,' error => jmtfil must be >= max(njtbft,njtbfu)',
     $        /,'          njtbft=',i8,' njtbfu=',i8)
#endif
9601  format(/,' "dtxcel(km)" tracer timestep multipliers:',/,10(f9.3))
9602  format (1x,'ts=',i7, 1x, a32, ', ke=', 1pe13.6,' dtemp=',1pe13.6
     $,        ' dsalt=',1pe13.6,' scans=',i3)
c
      end
#DECK ocn1st.F
      subroutine ocn1st
c
c
c=======================================================================
c
c     initialize quantites at initial condition time
c
c=======================================================================
c
c
#include "param.h"
#include "coord.h"
#include "ctmngr.h"
#include "cvbc.h"
#include "emode.h"
#include "grdvar.h"
#include "iounit.h"
#include "levind.h"
#include "scalar.h"
#ifdef multitasking
      parameter (ntp1=nt+1, ntp2=nt+2, ntp3=nt+3, ntp4=nt+4
     $,          ntp5=nt+5, ntp6=nt+6, ntp7=nt+7)
#include "cshrbf.h"
      dimension ua(imt,km), va(imt,km)
      equivalence (ta(1,1,ntp1), ua(1,1))
      equivalence (ta(1,1,ntp2), va(1,1))
# ifdef tcvmix
      dimension vvca(imt,km), vdca(imt,km), vdqca(imt,km), q2a(imt,km)
      equivalence (ta(1,1,ntp3), vvca(1,1))
      equivalence (ta(1,1,ntp4), vdca(1,1))
      equivalence (ta(1,1,ntp5), vdqca(1,1))
      equivalence (ta(1,1,ntp6), q2a(1,1))
#  ifdef leq
      dimension q2la(imt,km)
      equivalence (ta(1,1,ntp7), q2la(1,1))
#  endif
# endif
#else
#include "slabs.h"
#endif
#include "switch.h"
c
      dimension tinit(km,nt)
c
c-----------------------------------------------------------------------
c     generate topography over "t" points
c-----------------------------------------------------------------------
c
      call topog
c
c-----------------------------------------------------------------------
c     initialize slab data on disk
c-----------------------------------------------------------------------
c
      do 200 j=1,jmt
c
c      construct initial density profile
c
       do 110 k=1,km
         tinit(k,1) = theta0 (yt(j), zt(k))
         tinit(k,2) = 0.0349
110    continue
c
c       set internal mode velocities to zero
c
        do 130 k=1,km
          do 120 i=1,imt
            ua(i,k) = c0
            va(i,k) = c0
#ifdef tcvmix
c
c      set turbulent kinetic energy
c
            q2a(i,k)  = 1.e-6
#  ifdef leq
            q2la(i,k) = 1.e-4
#  endif
#endif
120       continue
130     continue
c
        do 160 m=1,nt
          do 150 k=1,km
            do 140 i=1,imt
              ta(i,k,m) = c0
140         continue
150       continue
160     continue
c
c       set tracers over ocean points to specified values
c
        do 190 i=1,imt
          kz = kmt(i,j)
          if (kz .ne. 0) then
            do 180 k=1,kz
              do 170 m=1,nt
                ta(i,k,m) = tinit(k,m)
                if(m .eq. 1) ta(i,k,m) = tinit(k,m)
                if(m .eq. 2) ta(i,k,m) = tinit(k,m) - 0.035
170           continue
180         continue
          endif
190     continue
c
c       send the initial slabs to disk. use "oput" since data is
c       contiguous in buffer slab "ta"
c
        call oput (labs(1), nslab, (j-1)*nslab+1, ta)
        call oput (labs(2), nslab, (j-1)*nslab+1, ta)
        if (ntlev .eq. 3 .and. (j .eq. 1 .or. j .eq. jmt))
     $     call oput (labs(3), nslab,(j-1)*nslab+1, ta)
200   continue
c
c-----------------------------------------------------------------------
c     end slab initialization on disk
c-----------------------------------------------------------------------
c
c
c-----------------------------------------------------------------------
c     initialize two dimensional fields on disk
c-----------------------------------------------------------------------
c
      do 300 n=1,ntau
        do 290 j=1,jmt
          do 280 i=1,imt
            p (i,j,n) = c0
280       continue
290     continue
300   continue
c
c     block's 1 through 3 are for stream function time levels
c     block's 4 & 5 are for the stream function guess field
c     block 6 is for the level indicators over "t" points
c
      call oput (kflds, nwds, 1, p)
      call oput (kflds, nwds, nwds+1, p)
      call oput (kflds, nwds, 3*nwds+1, p)
      call oput (kflds, nwds, 4*nwds+1, p)
      call oput (kflds, nwds, 5*nwds+1, kmt)
c
c-----------------------------------------------------------------------
c     initialize control block on disk
c-----------------------------------------------------------------------
c
      itt   = 0
      years = c0
c
      call oput (kontrl, 2, 1, itt)
c
      return
      end
#DECK odam.F
      subroutine odam (lu, nwrs, nfrst, a)
#ifdef multitasking
cfpp$ noconcur r
#endif
#ifdef diskless
c
c=======================================================================
c
c  odam (ocean direct access manager) is a set of routines which
c       simulates memory/disc data transfer management, using the
c       central memory array, "big" as a virtual disc. this results
c       in a totally memory contained system. the arguments, in terms
c       of normal disc i/o, are:
c         lu   =i/o unit number
c         ntot =length of unit, in words
c         nblk =length of each block on the unit
c         nbuf =number of buffers supplied to the unit
c         nwrs =number of words to transfer
c         nfrst=unit address of the first word to be transferred
c         a    =origination/destination array in memory
c
c=======================================================================
c
#include "param.h"
#include "iounit.h"
c
c---------------------------------------------------------------------
c     "sdisk" is the simulated disk using memory
c---------------------------------------------------------------------
c
      parameter (n11=20, n12=imt*jmt*nkflds
     $,           nsl=nslab*jmt, ntb=n11+n12+ntlev*nsl)
      dimension sdisk(ntb)
      dimension a(nwrs)
      save sdisk
c
c-----------------------------------------------------------------------
c     begin executable code
c-----------------------------------------------------------------------
c
      entry ostart (lu, ntot, nblk, nbuf)
      return
      entry ofind (lu, nwrs, nfrst)
      return
c
c-----------------------------------------------------------------------
c     virtual disc-to-memory transfer. used to move contiguous portions
c     of the virtual disk to contiguous portions of memory
c-----------------------------------------------------------------------
c
      entry oget (lu, nwrs, nfrst, a)
      nskp = 0
      if (lu .gt. kontrl) nskp = nskp + n11
      if (lu .gt. kflds) nskp = nskp + n12
      ns = nfrst + nskp
      if (lu .ge. labs(1)) ns = nskp + (ntlev*((nfrst-1)/nwrs)+
     $                                 (lu-labs(1)))*nwrs +1
      ne = ns + nwrs - 1
      do 100 n=ns,ne
        a(n-ns+1) = sdisk(n)
100   continue
      return
c
c---------------------------------------------------------------------
c     memory-to-virtual disc transfer. used to move contiguous portions
c     of memory to contiguous portions of the virtual disc
c---------------------------------------------------------------------
c
      entry oput (lu, nwrs, nfrst, a)
      nskp = 0
      if (lu .gt. kontrl) nskp = nskp + n11
      if (lu .gt. kflds) nskp = nskp + n12
      ns =nfrst + nskp
      if (lu .ge. labs(1)) ns = nskp+(ntlev*((nfrst-1)/nwrs)+
     $                          (lu-labs(1)))*nwrs+1
      ne = ns + nwrs - 1
      do 200 n=ns,ne
        sdisk(n) = a(n-ns+1)
200   continue
      return
c
      entry oclose (lu)
      return
c
c---------------------------------------------------------------------
c     initialize virtual disc from tape
c---------------------------------------------------------------------
c
      entry ord (lu)
      read (lu) sdisk
      return
c
c---------------------------------------------------------------------
c     save virtual disc to tape
c---------------------------------------------------------------------
c
      entry owrt (lu)
      rewind lu
      write (lu) sdisk
      return
#define ioalreadyset
#endif
#if defined crayio && !defined ioalreadyset
#include "param.h"
c
c=======================================================================
c
c     odam (ocean direct access manager) is a set of cray routines for
c     doing disk i/o. The arguments are:
c
c     lu   = i/o unit number
c     ntot = length of unit, in words
c     nblk = length of each block on the unit
c     nbuf = number of buffers supplied to the unit
c     nwrs = number of words to transfer
c     nfrst= unit address of the first word to be transferred
c     a    = origination/destination array in memory
c
c=======================================================================
c
      dimension a(nwrs)
c
      entry ostart (lu, ntot, nblk, nbuf)
      istats=1
      call wopen (lu, nblk/512+1, istats)
      return
      entry ofind (lu, nwrs, nfrst)
cmic$ guard
      call seek (lu, nfrst, nwrs)
cmic$ end guard
      return
      entry oget (lu, nwrs, nfrst, a)
cmic$ guard
      call getwa (lu, a, nfrst, nwrs)
cmic$ end guard
      return
      entry oput (lu, nwrs, nfrst, a)
cmic$ guard
#ifdef multitasking
      call aputwa (lu, a, nfrst, nwrs)
#else
      call putwa (lu, a, nfrst, nwrs)
#endif
cmic$ end guard
      return
      entry oclose (lu)
      call wclose (lu)
      return
#define ioalreadyset
#endif
#if defined fio && !defined ioalreadyset
c
c=======================================================================
c
c     odam (ocean direct access manager) is a set of fio routines for
c     doing disk i/o. The arguments are:
c
c     lu   = i/o unit number
c     ntot = length of unit, in words
c     nblk = length of each block on the unit
c     nbuf = number of buffers supplied to the unit
c     nwrs = number of words to transfer
c     nfrst= unit address of the first word to be transferred
c     a    = origination/destination array in memory
c
c=======================================================================
c
      dimension a(nwrs)
c
      entry ostart (lu, ntot, nblk, nbuf)
      open (unit=lu, access='DIRECT', form='UNFORMATTED',
     $           recl=8*nblk)
      return
      entry ofind (lu, nwrs, nfrst)
      return
      entry oget (lu, nwrs, nfrst, a)
      read (lu, rec=(nfrst-1)/nwrs+1) a
      return
      entry oput (lu, nwrs, nfrst, a)
      write (lu, rec=(nfrst-1)/nwrs+1) a
      return
      entry oclose (lu)
      close (lu)
      return
#define ioalreadyset
#endif
#ifndef ioalreadyset
      dimension a(nwrs)
c
      entry ostart (lu, ntot, nblk, nbuf)
      open (unit=lu, access='DIRECT', form='UNFORMATTED',
     $           recl=8*nblk)
      return
      entry ofind (lu, nwrs, nfrst)
      return
      entry oget (lu, nwrs, nfrst, a)
      read (lu, rec=(nfrst-1)/nwrs+1) a
      return
      entry oput (lu, nwrs, nfrst, a)
      write (lu, rec=(nfrst-1)/nwrs+1) a
      return
      entry oclose (lu)
      close (lu)
      return
#endif
#undef ioalreadyset
      end
      subroutine xfer (buffer, slab)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c     transfer contiguous data from the buffer area to non-contiguous
c     locations (variables) in the memory slab window
c
#include "param.h"
      dimension slab(imt,km,nslabs,ntau,nvar), buffer(imt,km,nvar)
c
      do 100 n=1,nvar
        do 90 k=1,km
          do 80 i=1,imt
            slab(i,k,1,1,n) = buffer(i,k,n)
80        continue
90      continue
100   continue
      return
      end
#DECK ppmix.F
      subroutine ppmix (j)
#ifdef ppvmix
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c
c    compute vertical mixing coefficients based on the pacanowski &
c    philander richardson mixing scheme (jpo vol 11, #11, 1981).
c    note: this parameterization was designed for equatorial models
c    and may not do a good job in mid or high latitudes.
c
c     inputs:
c
c     j    = current central slab row
c
c     outputs:
c
c     vertical mixing coefficient arrays "vdc,vvc" in "cvmix.h"
c
c=======================================================================
c
#include "param.h"
#include "coord.h"
#include "cppmix.h"
#include "cprnts.h"
#include "ctask.h"
#include "ctmngr.h"
#include "cvmix.h"
#include "grdvar.h"
#ifdef skipland
#include "index.h"
#endif
#include "levind.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
#include "temp.h"
c
      if (j .eq. jsrow) then
c
c-----------------------------------------------------------------------
c       compute density difference across bottoms of "t" boxes for row
c       "jsrow" at time level tau-1.
c-----------------------------------------------------------------------
c
c       compute vertical difference of density.
c
        do 100 ks=1,2
          call statec (t(1,1,jc,nm,1), t(1,1,jc,nm,2), tempik(1,1,1),ks)
          do 90 k=ks,kmm1,2
            do 80 i=1,imt
              drhoc(i,k) = tempik(i,k,1) - tempik(i,k+1,1)
80          continue
90        continue
100     continue
c
c       set no-flux density across bottom
c
        do 200 i=1,imt
          if (kmt(i,j) .ne. 0) then
            drhoc(i,kmt(i,j)) = c0
          endif
200     continue
      endif
c
c-----------------------------------------------------------------------
c     compute richardson number at bottoms of "t" boxes for row j+1
c     at time level tau-1.
c-----------------------------------------------------------------------
c
c     compute vertical difference of density.
c
      do 300 ks=1,2
        call statec (t(1,1,jp,nm,1), t(1,1,jp,nm,2), tempik(1,1,1), ks)
        do 290 k=ks,kmm1,2
          do 280 i=1,imt
            drhop(i,k) = tempik(i,k,1) - tempik(i,k+1,1)
280       continue
290     continue
300   continue
c
c     set no-flux density across bottom
c
      do 400 i=1,imt
        if (kmt(i,j+1) .ne. 0) then
          drhop(i,kmt(i,j+1)) = c0
        endif
400   continue
c
c     compute richardson number on "u" grid box bottoms
c
      fx = -p25*grav
      do 500 k=1,kmm1
        t1 = fx*dzw(k)
        do 470 i=2,imtm1
          riuc(i,k) = t1*gm(i,k+1,jc)*(drhop(i,k) + drhop(i+1,k)
     $               + drhoc(i,k) + drhoc(i+1,k))
     $                /((u(i,k,jc,nm) - u(i,k+1,jc,nm))**2
     $               +  (v(i,k,jc,nm) - v(i,k+1,jc,nm))**2 + epsln)
470     continue
#ifdef cyclic
        riuc(1,k)   = riuc(imtm1,k)
        riuc(imt,k) = riuc(2,k)
#else
        riuc(1,k)   = c0
        riuc(imt,k) = c0
#endif
500   continue
c
      if (j .gt. jsrow) then
c
#ifdef skipland
        do 1400 lstrip=1,lseg
          istart = ist(j,lstrip)
          iend   = iet(j,lstrip)
          if (istart .ne. 0) then
#endif
c
c-----------------------------------------------------------------------
c           compute vertical viscosity coeff on "u" grid box bottoms
c-----------------------------------------------------------------------
c
            do 700 k=1,kmm1
              do 690 i=istart,iend
                t1       = c1/(c1 + c5*riuc(i,k))
                vvc(i,k) = fricmx*t1**2 + bvvc
690           continue
700         continue
c
c           in regions of gravitational instability, reset the vertical
c           mixing coefficient
c
            do 800 k=1,kmm1
              do 790 i=istart,iend
                if (riuc(i,k) .lt. c0) vvc(i,k) = vvclim
790           continue
800         continue
c
c-----------------------------------------------------------------------
c           compute richardson number at bottoms of boxes on "t" grid
c           by averaging
c-----------------------------------------------------------------------
c
            do 900 k=1,kmm1
              do 890 i=istart,iend
                tempik(i,k,1) = p25*(riuc(i,k) + riuc(i-1,k)
     $                             + rium(i,k) + rium(i-1,k))
890           continue
900         continue
c
c-----------------------------------------------------------------------
c           compute vertical diffusivity coeff on "t" grid box bottoms
c-----------------------------------------------------------------------
c
            do 1000 k=1,kmm1
              do 990 i=istart,iend
                t1       = c1/(c1 + c5*tempik(i,k,1))
                vdc(i,k) = fricmx*t1**3 + bvdc
990           continue
1000        continue
c
c           in regions of gravitational instability, reset the vertical
c           mixing coefficient to the limit
c
            do 1100 k=1,kmm1
              do 1090 i=istart,iend
                if (tempik(i,k,1) .lt. c0) vdc(i,k) = vdclim
1090          continue
1100        continue
c
c-----------------------------------------------------------------------
c           approximation for high freq wind mixing near the surface
c-----------------------------------------------------------------------
c
            do 1200 i=istart,iend
              if (vvc(i,1) .lt. wndmix) vvc(i,1) = wndmix
              if (vdc(i,1) .lt. wndmix) vdc(i,1) = wndmix
1200        continue
c
c-----------------------------------------------------------------------
c           set viscosity & diffusivity to zero in land
c-----------------------------------------------------------------------
c
            do 1390 k=1,kmm1
              do 1380 i=istart,iend
                vvc(i,k) = gm(i,k+1,jc)*vvc(i,k)
                vdc(i,k) = fm(i,k+1,jc)*vdc(i,k)
1380          continue
1390        continue
c
c           set viscosity & diffusivity at level km
c
            do 1300 i=istart,iend
              vvc(i,km) = c0
              vdc(i,km) = c0
1300        continue
c
#ifdef skipland
          endif
1400    continue
#endif
      endif
c
c-----------------------------------------------------------------------
c     transfer richardson numbers for use with next row
c-----------------------------------------------------------------------
c
      do 1501 k=1,km
        do 1490 i=1,imt
          drhoc(i,k) = drhop(i,k)
          rium(i,k) = riuc(i,k)
1490    continue
1501  continue
c
      if (diagts .and. eots) then
c
c---------------------------------------------------------------------
c       print the solution at specified latitudes on diagnostic tsteps
c---------------------------------------------------------------------
c
        do 6200 jlat=1,nlatpr
          jj = indp (prlat(jlat), yt, jmt)
          if (jj .eq. j .and. prlat(jlat) .le. yt(jmt)) then
            is  = indp (prslon(jlat), xt, imt)
            ie  = indp (prelon(jlat), xt, imt)
            ks  = indp (prsdpt(jlat), zt, km)
            ke  = indp (predpt(jlat), zt, km)
            fx  = 1.0e-2
            scl = c1
            write (stdout,9100) 'vvc ', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (vvc(1,1), imt, is, ie, ks, ke, scl)
c
            scl = c1
            write (stdout,9100) 'vdc ', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (vdc(1,1), imt, is, ie, ks, ke, scl)
          endif
6200    continue
      endif
9100  format(1x,a12,1x,'ts=',i10,1x,',j=',i3,', lat=',f6.2
     $,', lon:',f6.2,' ==> ',f6.2,', depth(m):',f6.1,' ==> ',f6.1
     $,', scaling=',1pg10.3)
#endif
      return
      end
#DECK reg1st.F
      subroutine reg1st (nunit, wrform, wrvol, wrk, wrmask, rmask)
c
c=======================================================================
c
c     Subroutine reg1st is i/o routine for the user defined horizontal
c     and vertical regional masks used in MOM.
c     It is also the i/o routine that can be used to write volume
c     information for the horizontal regions used in calculating
c     volume weighted averages of tracers and surface tracer fluxes.
c     Both formatted and unformatted i/o is supported.
c     (see "cregin.h" for more details on variables).
c
c     The "mskhr" horizontal masks are used in calculations in
c     subroutines clinic, tracer, and region.
c     The "mskvr" vertical masks are used in calculations in subroutines
c     clinic, tracer, and diag2.
c
c     when "readrmsk" is defined, "mskhr","mskvr", "hregnm" &"vregnm"
c     will be read from file "regionmasks" which is assigned to
c     "iormsk" in the same manner as this routine writes that
c     information. ("iormsk" is set in "blkdta.F")
c     alternatively, the horizontal region masks can be specified in
c     "ocean.F", and although a simple, latitude dependent default
c     setting is provided, the user should consider specifying a more
c     appropriate set of masks.
c
c=======================================================================
c
#include "param.h"
#include "cregin.h"
c
c  nunit = unit to be written to or read from
c  wrform= true(false) switch for formatted(unformatted) writes
c  wrvol = switch to write volume & area information
c  wrk   = switch to write k-level volume information
c  wrmask= switch to write horizontal region masks field
c  rmask = switch to read horizontal region masks field from specified
c          unit
c  settop, setbot = used in defining level limits for vertical regions
c
      logical  wrform, wrvol, wrk, wrmask, rmask
      logical  settop, setbot
c
      dimension ncol(imt)
c
c-----------------------------------------------------------------------
c     write out regional volume information
c-----------------------------------------------------------------------
c
        if (wrvol) then
          if(wrform) then
            write(nunit,9000)
            if(wrk) then
              write(nunit,9001) (mask,mask=1,nhreg)
              do 700 k=1,km
                write(nunit,9002) k, volgk(k),
     $                           (volbk(mask,k),mask=1,nhreg)
700           continue
            endif
            write(nunit,9003) volgt, (volbt(mask),mask=1,nhreg)
            write(nunit,9004) areag, (areab(mask),mask=1,nhreg)
          else
            if(wrk) write(nunit) volgk, volbk
            write(nunit) volgt, volbt
            write(nunit) areag, areab
          endif
        endif
c
c-----------------------------------------------------------------------
c       read in (write out) horizontal & vertical region masks
c       set linel to length of desired formatted printout line
c-----------------------------------------------------------------------
c
        if (wrmask .or. rmask) then
c
          if(wrform) then
            if (wrmask) write(nunit,9011)
            if (wrmask) write(nunit,9012)
     $         (' domain for hor mask #',i,'=',hregnm(i),i=1,nhreg)
            if ( rmask) then
              read (nunit,9099)
              read (nunit,9099)
            endif
            if ( rmask) read (nunit,9013) (hregnm(i),i=1,nhreg)
            linemx = 100
            linel  = 105
            line   = linel - 5
            if (line .gt. linemx) line = linemx
            nwr = (imt/line) + 1
c
            do 900 i=1,imt
              ncol(i) = mod(i,10)
900         continue
c
            do 1000 n=1,nwr
              ia = 1 + (line*(n-1))
              ib = ia + line - 1
              if (ib .gt. imt) ib = imt
              if (wrmask) write(nunit,9021) (ncol(i),i=ia,ib)
              if ( rmask) read (nunit,9099)
              do 990 jj=1,jmt
                jjj = jmt - jj + 1
                if (wrmask) write(nunit,9022)jjj,(mskhr(i,jjj),i=ia,ib)
                if ( rmask) then
                  read (nunit,9022) jr , (mskhr(i,jjj),i=ia,ib)
                  if (jr .ne. jjj) then
                    write (stdout,999) nunit, jjj, jr
                    write (stderr,999) nunit, jjj, jr
                    stop ' regin  '
                  endif
                endif
990           continue
1000        continue
c
            if (wrmask) write(nunit,9031)
            if (wrmask) write(nunit,9032)
     $         (' domain for ver mask #',i,'=',vregnm(i),i=1,nvreg)
            if (wrmask) write(nunit,9034) mskvr
c
            if ( rmask) then
               read (nunit,9099)
               read (nunit,9099)
            endif
            if ( rmask) read (nunit,9033) (vregnm(i),i=1,nvreg)
            if ( rmask) read (nunit,9034) mskvr
c
          else
            if (wrmask) then
              write(nunit) mskhr, mskvr
              write(nunit) hregnm, vregnm
            endif
            if (rmask) then
              read (nunit) mskhr, mskvr
              read (nunit) hregnm, vregnm
            endif
          endif
        endif
c
c       if vertical masks were read in, set level limits for defining
c       vertical regions in term balance calculations
c
        if (rmask) then
          do 1100 i=1,nvreg
            settop = .false.
            setbot = .false.
            do 1090 k=1,km
              kk = km-k+1
              if (mskvr(k)  .eq. i .and. .not. settop) then
                llvreg(i,1) = k
                settop = .true.
              endif
              if (mskvr(kk) .eq. i .and. .not. setbot) then
                llvreg(i,2) = kk
                setbot = .true.
              endif
1090        continue
1100        continue
        endif
c
      return
c
999   format(/' error => bad j-row when reading regionmasks from unit ',
     $       i3,/'   expected',i4,'    read in',i4)
9000  format(/' Horizontal regional volumes [cubic m] and areas [sq m]')
9001  format('    k','  All Regions ',9(1x,i7,5x))
9002  format(1x,i4,10(1x,e12.6))
9003  format('  SUM',10(1x,e12.6))
9004  format(/' AREA',10(1x,e12.6))
9011  format(/' Horizontal regional mask names & domains:')
9012  format(a22,i4,a1,a40)
9013  format(27x,a40)
9021  format('  i=>',100(i1))
9022  format(1x,i3,1x,100(i1))
9031  format(/' Vertical regional mask names & domains:')
9032  format(a22,i4,a1,a20)
9033  format(27x,a20)
9034  format (1x, 42i3)
9099  format(1x)
      end
#DECK region.F
      subroutine region (j, nunit, wrform, wrtr, wrk)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c
c     subroutine region is provided to allow the computation of area
c     and volume weighted averages of tracers and surface tracer fluxes
c     under user defined horizontal regions within the model grid.
c     individual averages are calculated for each region as specified by
c     the integer region masks stored in "mskhr", and for each of the
c     "km" model levels.
c     (see "cregin.h" for more details on variables, and "reg1st.F" for
c     set up and horizontal mask i/o considerations).
c
c     the region averages are calculated at intervals of "travg" days,
c     and are written to unit "iotavg".
c
c=======================================================================
c
#include "param.h"
#include "coord.h"
#include "cregin.h"
#include "ctmngr.h"
#include "cvbc.h"
#include "docnam.h"
#include "grdvar.h"
#include "scalar.h"
#include "slabs.h"
c
c  nunit = unit to be written to or read from
c  wrform= true(false) switch for formatted(unformatted) writes
c  wrtr  = switch to write tracer information
c  wrk   = switch to write k-level averages
c  sumbt = volume weighted tracer sum for a given region
c  avgbt = volume weighted tracer average for a given region
c  sumbk = volume weighted tracer sum for a region at a k level
c  avgbk = volume weighted tracer average for a region at a k level
c  sumgt = total global volume wtd tracer sum
c  avggt = total global volume wtd tracer average
c  sumgk = total global volume wtd tracer sum at a k level
c  avggk = total global volume wtd tracer average at a k level
c  sumbf = area weighted tracer flux sum for a given region
c  avgbf = average area weighted tracer flux for a region
c  sumgf = global area weighted tracer flux sum
c  avggf = global average area weighted tracer flux
c
      logical  wrform, wrtr, wrk
c
      dimension sumbk(nhreg,km,nt), sumbt(nhreg,nt)
      dimension sumgk(km,nt), sumgt(nt)
      dimension sumbf(nhreg,nt), sumgf(nt)
      dimension avgbk(nhreg,km,nt), avgbt(nhreg,nt)
      dimension avggk(km,nt), avggt(nt)
      dimension avgbf(nhreg,nt), avggf(nt)
c
      save sumbk, sumbf, avgbk
c
c-----------------------------------------------------------------------
c     initialize sums for averages under horizontal regions
c-----------------------------------------------------------------------
c
      if (j .eq. 2) then
        do 100 m=1,nt
          do 90 mask=1,nhreg
            sumbf(mask,m) = c0
            do 80 k=1,km
              sumbk(mask,k,m) = c0
              avgbk(mask,k,m) = c0
80          continue
90        continue
100     continue
      endif
c
c-----------------------------------------------------------------------
c     accumulate sums for averages under horizontal regions
c     (compute in units of meters, rather than cm)
c-----------------------------------------------------------------------
c
      if (j .ge. 2 .and. j .le. jmtm1) then
        do 200 i=2,imtm1
          mask = mskhr(i,j)
          if (mask .ne. 0) then
            boxar = cst(j) * dxt(i) * dyt(j) * fm(i,1,jc) * 0.0001
            do 190 m=1,nt
              sumbf(mask,m) = sumbf(mask,m) + stf(i,m) * boxar
              do 180 k=1,km
                sumbk(mask,k,m) = sumbk(mask,k,m) +
     $               t(i,k,jc,nc,m) * boxar * dzt(k) * fm(i,k,jc) * 0.01
180           continue
190         continue
          endif
200     continue
      endif
c
c-----------------------------------------------------------------------
c     compute averages under horizontal regions after accumulating all
c     jrows ... then write them out
c-----------------------------------------------------------------------
c
      if (j .eq. jmtm1) then
c
c       initialize sums for horizontal regions & tracer averages
c
        do 300 m=1,nt
          sumgf(m) = c0
          avggf(m) = c0
          sumgt(m) = c0
          avggt(m) = c0
          do 280 mask=1,nhreg
            sumbt(mask,m) = c0
            avgbt(mask,m) = c0
            avgbf(mask,m) = c0
280       continue
          do 290  k=1,km
            sumgk(k,m) = c0
            avggk(k,m) = c0
290       continue
300     continue
c
c       compute sums for tracer averages over horizontal regions
c
        do 400 m=1,nt
          do 390 mask=1,nhreg
            sumgf(m) = sumgf(m) + sumbf(mask,m)
            do 380  k=1,km
              sumbt(mask,m) = sumbt(mask,m) + sumbk(mask,k,m)
              sumgk(k,m) = sumgk(k,m) + sumbk(mask,k,m)
380         continue
            sumgt(m) = sumgt(m) + sumbt(mask,m)
390       continue
400     continue
c
        do 500 k=1,km
          if (volgk(k) .gt. c0) then
            rvolgk = c1 / volgk(k)
            do 490 m=1,nt
              avggk(k,m) = sumgk(k,m) * rvolgk
              do 480 mask=1,nhreg
                if (volbk(mask,k) .gt. c0) then
                  avgbk(mask,k,m) = sumbk(mask,k,m) / volbk(mask,k)
                endif
480           continue
490         continue
          endif
500     continue
c
        rvolgt = c1 / volgt
        rareag = c1 / areag
        do 600 m=1,nt
          avggt(m) = sumgt(m) * rvolgt
          avggf(m) = sumgf(m) * rareag
          do 590 mask=1,nhreg
            if (volbt(mask) .gt. c0) then
              avgbt(mask,m) = sumbt(mask,m) / volbt(mask)
            endif
            if (areab(mask) .gt. c0) then
              avgbf(mask,m) = sumbf(mask,m) / areab(mask)
            endif
590       continue
600     continue
c
c       write out regional tracer means
c
        if (wrtr) then
          if(wrform) then
            do 800 m=1,nt
              write(nunit,9004) trname(m), itt, stamp
              if(wrk) then
                write(nunit,9001) (mask,mask=1,nhreg)
                do 790 k=1,km
                  write(nunit,9002) k, avggk(k,m),
     $                             (avgbk(mask,k,m),mask=1,nhreg)
790             continue
              endif
              write(nunit,9003) avggt(m), (avgbt(mask,m),mask=1,nhreg)
              write(nunit,9014) avggf(m), (avgbf(mask,m),mask=1,nhreg)
800         continue
          else
            if(wrk) write(nunit)  avggk, avgbk
            write(nunit) avggt, avgbt
            write(nunit) avggf, avgbf
          endif
        endif
      endif
c
      return
c
9001  format('    k','  All Regions ',9(1x,i7,5x))
9002  format(1x,i4,10(1x,e12.6))
9003  format('  SUM',10(1x,e12.6))
9004  format(/' Volume Weighted Averages for ',a12,' on ts =',i10,a33)
9014  format(/' FLUX',10(1x,e12.6),/)
      end
#DECK relax.F
      subroutine relax
#ifdef oldrelax
c
c=======================================================================
c                                                                    ===
c  relax takes as input the vorticity driving function computed in   ===
c        "clinic" (ztd) and, using sequential over-relaxation,       ===
c        solves the laplacian equation for the external mode of      ===
c        velocity in terms of a mass transport stream function (p).  ===
c                                                                    ===
c=======================================================================
c
c---------------------------------------------------------------------
c  define global data
c---------------------------------------------------------------------
c
#include "param.h"
#include "crelax.h"
#include "ctmngr.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "iounit.h"
#include "scalar.h"
#include "switch.h"
#include "temp.h"
c
c---------------------------------------------------------------------
c  demension and equivalence local data
c---------------------------------------------------------------------
c
      dimension ptdb(imt,jmt)
      equivalence (res,ptdb)
c
c---------------------------------------------------------------------
c  begin executable code
c---------------------------------------------------------------------
c
c=======================================================================
c  begin introductory section to prepare for the relaxation  ===========
c=======================================================================
c
c---------------------------------------------------------------------
c  initiate readin of relaxation solution of 2 timesteps back
c  for the purpose of computing an initial guess for the present pass
c  (input unit alternates on tsteps between 4 & 5)
c---------------------------------------------------------------------
c
      luptdb=5-mod(itt,2)
      luptd =4+mod(itt,2)
      call ofind(kflds,nwds,(luptdb-1)*nwds+1)
c
c---------------------------------------------------------------------
c  initialize the work area
c---------------------------------------------------------------------
c
      fx=c0
      do 100 j=1,jmt
        do 90 i=1,imt
          cfn(i,j)=fx
          cfs(i,j)=fx
          cfe(i,j)=fx
          cfw(i,j)=fx
#ifdef islands
          cof(i,j)=c1
#endif
90      continue
100   continue
c
c---------------------------------------------------------------------
c  complete readin of relaxation solution of 2 timesteps back and
c  initiate readin of relaxation solution of previous timestep
c  (input unit alternates on timesteps between 5 & 4)
c---------------------------------------------------------------------
c
      call oget(kflds,nwds,(luptdb-1)*nwds+1,ptdb)
      call ofind(kflds,nwds,(luptd-1)*nwds+1)
c
c---------------------------------------------------------------------
c  generate arrays of coefficients for relaxation
c---------------------------------------------------------------------
c
c  1st, compute coefficients of the laplacian star
c  (hold non-interior points to zero using start and end indices)
c
      do 600 j=3,jmtm1
      do 600 l=1,lseg
        is=isz(j,l)
        if(is.eq.0) go to 600
        ie=iez(j,l)
        fxa=c2*cstr(j)*cstr(j)
        fxb=c2*csu(j  )*cstr(j)*dytr(j)*dyur(j  )
        fxc=c2*csu(j-1)*cstr(j)*dytr(j)*dyur(j-1)
        fx=c1
        do 570 i=is,ie
          cfn(i,j)=fxb/(h(i-1,j)+h(i,j))
          cfs(i,j)=fxc/(h(i-1,j-1)+h(i,j-1))
          cfe(i,j)=fxa*dxur(i)*dxtr(i)/(h(i,j)+h(i,j-1))
          cfw(i,j)=fxa*dxur(i-1)*dxtr(i)/(h(i-1,j)+h(i-1,j-1))
          cpf(i,j)=fx/(cfn(i,j)+cfs(i,j)+cfe(i,j)+cfw(i,j))
570     continue
c
c  2nd, augment coefficients for implicit treatment of coriolis term
c
        if(acor.ne.c0) then
          fx=-c2dtsf*acor*cstr(j)*dytr(j)*omega
          do 580 i=is,ie
            cfn(i,j)=cfn(i,j)+(hr(i,j  )-hr(i-1,j  ))*sine(j  )
     *                        *fx*dxtr(i)
            cfs(i,j)=cfs(i,j)-(hr(i,j-1)-hr(i-1,j-1))*sine(j-1)
     *                        *fx*dxtr(i)
            cfe(i,j)=cfe(i,j)-(hr(i  ,j)*sine(j)-hr(i  ,j-1)*sine(j-1))
     *                        *fx*dxtr(i)
            cfw(i,j)=cfw(i,j)+(hr(i-1,j)*sine(j)-hr(i-1,j-1)*sine(j-1))
     *                        *fx*dxtr(i)
580       continue
        endif
c
c  3rd, normalize coefficients and forcing term for efficiency
c
        do 590 i=is,ie
          cfn(i,j)=cfn(i,j)*cpf(i,j)
          cfs(i,j)=cfs(i,j)*cpf(i,j)
          cfe(i,j)=cfe(i,j)*cpf(i,j)
          cfw(i,j)=cfw(i,j)*cpf(i,j)
          ztd(i,j)=ztd(i,j)*cpf(i,j)
590     continue
600   continue
#ifdef islands
c
c  4th, compute coefficients on island perimeter points
c
      do 700 isle=1,nisle
        cofis(isle)=c0
        do 690 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          fxa=c2*cstr(j)*cstr(j)
          fxb=c2*csu(j  )*dyur(j  )*dytr(j)*cstr(j)
          fxc=c2*csu(j-1)*dyur(j-1)*dytr(j)*cstr(j)
          fxd=-c2dtsf*acor*cstr(j)*dytr(j)*omega
          if(hr(i-1,j  ).ne.c0 .or. hr(i  ,j  ).ne.c0)
     *      cfn(i,j)=fxb/(h(i-1,j)+h(i,j))
     *         +fxd*dxtr(i)*(hr(i,j)-hr(i-1,j))*sine(j)
          if(hr(i-1,j-1).ne.c0 .or. hr(i  ,j-1).ne.c0)
     *      cfs(i,j)=fxc/(h(i-1,j-1)+h(i,j-1))
     *         -fxd*dxtr(i)*(hr(i,j-1)-hr(i-1,j-1))*sine(j-1)
          if(hr(i  ,j  ).ne.c0 .or. hr(i  ,j-1).ne.c0)
     *      cfe(i,j)=fxa*dxtr(i)*dxur(i)/(h(i,j)+h(i,j-1))
     *         -fxd*dxtr(i)*(hr(i,j)*sine(j)-hr(i,j-1)*sine(j-1))
          if(hr(i-1,j  ).ne.c0 .or. hr(i-1,j-1).ne.c0)
     *      cfw(i,j)=fxa*dxtr(i)*dxur(i-1)/(h(i-1,j)+h(i-1,j-1))
     *         +fxd*dxtr(i)*(hr(i-1,j)*sine(j)-hr(i-1,j-1)*sine(j-1))
          cof(i,j)=c1/(cfn(i,j)+cfs(i,j)+cfe(i,j)+cfw(i,j))
          cfn(i,j)=cfn(i,j)*cof(i,j)
          cfs(i,j)=cfs(i,j)*cof(i,j)
          cfe(i,j)=cfe(i,j)*cof(i,j)
          cfw(i,j)=cfw(i,j)*cof(i,j)
          ztd(i,j)=ztd(i,j)*cof(i,j)
          cof(i,j)=cst(j)*dxt(i)*dyt(j)/cof(i,j)
          cofis(isle)=cofis(isle)+cof(i,j)
690     continue
        cofis(isle)=c1/cofis(isle)
700   continue
#endif
c
c  finally, multiply the coefficients by the overrelaxation factor
c
      do 800 j=1,jmt
        do 790 i=1,imt
          cfn(i,j)=cfn(i,j)*sor
          cfs(i,j)=cfs(i,j)*sor
          cfe(i,j)=cfe(i,j)*sor
          cfw(i,j)=cfw(i,j)*sor
790     continue
800   continue
c
c---------------------------------------------------------------------
c  compute a first guess for the relaxation by extrapolating the two
c  previous solutions forward in time.
c---------------------------------------------------------------------
c
c  1st, complete readin of relaxation solution of previous timestep
c
      call oget(kflds,nwds,(luptd-1)*nwds+1,ptd)
c
c  2nd, perform time extrapolation (accounting for mixing timestep)
c
      fxa=c1
      fxb=c2
      if(mixts.or.mxpas2) fxa=p5
      do 900 j=1,jmt
        do 890 i=1,imt
          ptd(i,j)=fxa*(fxb*ptd(i,j)-ptdb(i,j))
890     continue
900   continue
c
c  compute criterion for convergence of relaxation and set residuals 0
c
      crtp=crit*fxa*sor
      do 1000 j=1,jmt
        do 990 i=1,imt
          res(i,j)=c0
990     continue
1000  continue
c
c=======================================================================
c  end introductory section  ===========================================
c=======================================================================
c
c=======================================================================
c  begin section to do the relaxation  =================================
c=======================================================================
c
      mscan=0
10000 mscan=mscan+1
c
c---------------------------------------------------------------------
c  compute entire field of residuals as in simultaneous relaxation
c---------------------------------------------------------------------
c
      do 1100 j=3,jscan
        do 1090 i=2,imtm1
        res(i,j)=cfn(i,j)*ptd(i,j+1)
     *          +cfs(i,j)*ptd(i,j-1)
     *          +cfe(i,j)*ptd(i+1,j)
     *          +cfw(i,j)*ptd(i-1,j)
     *          -sor*(ptd(i,j)+ztd(i,j))
1090    continue
1100  continue
#ifdef islands
c
c---------------------------------------------------------------------
c  reset residuals to zero over land
c---------------------------------------------------------------------
c
      do 1200 j=3,jscan
        do 1170 i=1,imt
          tempik(i,1,1)=c0
1170    continue
        do 1180 l=1,lseg
          is=isz(j,l)
          if(is.eq.0) go to 1181
          ie=iez(j,l)
        do 1180 i=is,ie
          tempik(i,1,1)=res(i,j)
1180     continue
1181   continue
        do 1190 i=1,imt
          res(i,j)=tempik(i,1,1)
1190    continue
1200  continue
#endif
#ifdef cyclic
c
c---------------------------------------------------------------------
c  set cyclic boundary conditions on the residuals
c---------------------------------------------------------------------
c
      do 1300 j=3,jscan
        res(1,j)   = res(imum1,j)
        res(imt,j) = res(2,j)
1300  continue
#else
      do 1300 j=3,jscan
        res(1,j)   = c0
        res(imt,j) = c0
1300  continue
#endif
c
c---------------------------------------------------------------------
c  perform correction on southern point to yield sequential relaxation
c---------------------------------------------------------------------
c
      do 1400 j=3,jscan
#ifdef islands
        do 1360 l=1,lseg
          is=isz(j,l)
          if(is.eq.0) go to 1361
          ie=iez(j,l)
          do 1350 i=is,ie
            res(i,j)=res(i,j)+cfs(i,j)*res(i,j-1)
 1350     continue
 1360   continue
 1361   continue
#else
        do 1370 i=2,imtm1
          res(i,j)=res(i,j)+cfs(i,j)*res(i,j-1)
 1370   continue
#endif
c
c---------------------------------------------------------------------
c  perform correction on western point to yield sequential relaxation
c---------------------------------------------------------------------
c
        do 1390 l=1,lseg
          is=isz(j,l)
          if(is.eq.0) go to 1400
          ie=iez(j,l)
          do 1380 i=is,ie
            res(i,j)=res(i,j)+cfw(i,j)*res(i-1,j)
1380      continue
1390    continue
1400  continue
c
c---------------------------------------------------------------------
c  make a correction to ptd based on the residuals
c---------------------------------------------------------------------
c
      do 1500 j=3,jscan
        do 1490 i=1,imt
          ptd(i,j)=ptd(i,j)+res(i,j)
1490    continue
1500  continue
c
c---------------------------------------------------------------------
c  find the maximum absolute residual to determine convergence
c---------------------------------------------------------------------
c
      resmax=c0
      do 1600 j=3,jscan
        do 1590 i=2,imtm1
          resmax=max(abs(res(i,j)),resmax)
1590    continue
1600  continue
#ifdef islands
c
c---------------------------------------------------------------------
c  do hole relaxation for each island
c---------------------------------------------------------------------
c
      fx=c0
      do 1700 isle=1,nisle
        resis=fx
        do 1660 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
              resis=resis+(cfn(i,j)*ptd(i  ,j+1)
     *                    +cfs(i,j)*ptd(i  ,j-1)
     *                    +cfe(i,j)*ptd(i+1,j  )
     *                    +cfw(i,j)*ptd(i-1,j  )
     *                    -sor*(ptd(i,j)+ztd(i,j)))*cof(i,j)
1660    continue
c
c  normalize the island residual and update the maximum
c  absolute residual of the relaxation if necessary
c
        resis=resis*cofis(isle)
        resmax=max(abs(resis),resmax)
c
c  make a correction to ptd over the island and its perimeter points
c
        do 1690 n=1,nippts(isle)
          i = iperm(iofs(isle)+n)
          j = jperm(iofs(isle)+n)
          ptd(i,j)=ptd(i,j)+resis
1690    continue
1700  continue
#endif
#ifdef symmetry
c
c---------------------------------------------------------------------
c  set symmetry boundary condition
c---------------------------------------------------------------------
c
      do 1800 i=1,imt
        ptd(i,jmt)=-ptd(i,jmtm1)
1800  continue
#endif
#ifdef cyclic
c
c---------------------------------------------------------------------
c  set cyclic boundary condition
c---------------------------------------------------------------------
c
      do 1900 j=1,jmt
        ptd(1,j)=ptd(imum1,j)
        ptd(imu,j)=ptd(2,j)
1900  continue
#endif
c
c---------------------------------------------------------------------
c  test maximum residual for convergence of the relaxation.
c  if not converged, proceed with another scan.
c  (..note.. if the number of scans reaches mxscan, leave the loop)
c---------------------------------------------------------------------
c
      if(resmax.ge.crtp .and. mscan.lt.mxscan) go to 10000
c
c=======================================================================
c  end of the relaxation  ==============================================
c=======================================================================
c
c---------------------------------------------------------------------
c  update the stream function based upon the relaxation solution
c---------------------------------------------------------------------
c
      if(.not. mxpas2) then
        do 2000 j=1,jmt
          do 1990 i=1,imt
            ptdb(i,j) = p(i,j,2)+ptd(i,j)
            p(i,j,2) = p(i,j,1)
            p(i,j,1) = ptdb(i,j)
1990      continue
2000     continue
      else
        do 2100 j=1,jmt
          do 2090 i=1,imt
            p(i,j,1) = p(i,j,2)+ptd(i,j)
2090      continue
2100    continue
      endif
c
c---------------------------------------------------------------------
c  save ptd to compute 1st guess for relaxation next timestep
c  (..note.. on 1st pass of euler backward timestep, bypass this
c            save, since it will be done on the 2nd pass)
c  (..note.. on a mixing timestep, alter ptd to be consistent with
c            normal, leap-frog stepping)
c---------------------------------------------------------------------
c
      if(mixts .and. eb) return
      if(mxpas2 .or. mixts) then
        do 2200 j=1,jmt
          do 2190 i=1,imt
            ptd(i,j)=c2*ptd(i,j)
2190      continue
2200    continue
      endif
      call oput(kflds,nwds,(luptdb-1)*nwds+1,ptd)
#endif
      return
      end
#DECK restio.F
      subroutine restio
c
c=======================================================================
c
c     read and write restart file
c
c=======================================================================
c
#include "param.h"
#include "ctmngr.h"
#include "emode.h"
#include "iounit.h"
#include "levind.h"
#ifdef multitasking
#include "cshrbf.h"
#else
#include "slabs.h"
#endif
c
      entry rdrest
#ifdef diskless
      call ord (iorest)
#else
c
c-----------------------------------------------------------------------
c     read unformatted i/o restart file
c-----------------------------------------------------------------------
c
c     record 1 is the control block
c     record's 2 & 3 are for stream function time levels
c     record's 4 & 5 are for the stream function guess field
c     record 6 is for the level indicators over "t" points
c
      read (iorest) itt, years
      write (stdout,9100) iorest, itt
      relyr = years
      call oput (kontrl, 2, 1, itt)
      ndiskb = mod(itt+2,ntlev) + 1
      ndisk  = mod(itt  ,ntlev) + 1
      ndiska = mod(itt+1,ntlev) + 1
c
      read (iorest) ptd
      call oput (kflds, nwds, (ndisk-1)*nwds+1, ptd)
c
      read (iorest) ptd
      call oput (kflds, nwds, (ndiska-1)*nwds+1, ptd)
c
c
      read (iorest) ptd
      call oput (kflds, nwds, 3*nwds+1, ptd)
c
      read (iorest) ptd
      call oput (kflds, nwds, 4*nwds+1, ptd)
c
      read (iorest) kmt
      call oput (kflds, nwds, 5*nwds+1, kmt)
c
c     next come the slabs (2 time levels)
c
      do 100 j=1,jmt
       read (iorest) bufsl
       call oput (labs(ndisk), nslab, (j-1)*nslab+1, bufsl)
       if (j .eq. 1 .or. j .eq. jmt) then
         call oput (labs(ndiskb), nslab, (j-1)*nslab+1, bufsl)
       endif
100   continue
c
      do 200 j=1,jmt
       read (iorest) bufsl
       call oput (labs(ndiska), nslab, (j-1)*nslab+1, bufsl)
200   continue
c
9100  format (1x,"===> reading ocean restart data from unit",i3
     $,      " on ts=", i10)
c
      rewind iorest
c
#endif
      return
c
      entry wrrest
      write (stdout,9200) '==>  Writing  MOM restart on unit ',iorest
     $,                    itt, stamp
#ifdef diskless
      call owrt (iorest)
#else
c
c-----------------------------------------------------------------------
c     write restart file using unformatted fortran i/o
c-----------------------------------------------------------------------
c
c     record 1 is the control block
c     record's 2 & 3 are for stream function time levels
c     record's 4 & 5 are for the stream function guess field
c     record 6 is for the level indicators over "t" points
c
      call oget (kontrl, 2, 1, itt)
      write (iorest) itt, years
c
      call oget (kflds, nwds, (ndisk-1)*nwds+1, ptd)
      write (iorest) ptd
c
      call oget (kflds, nwds, (ndiska-1)*nwds+1, ptd)
      write (iorest) ptd
c
      call oget (kflds, nwds, 3*nwds+1, ptd)
      write (iorest) ptd
c
      call oget (kflds, nwds, 4*nwds+1, ptd)
      write (iorest) ptd
c
      call oget (kflds, nwds, 5*nwds+1, kmt)
      write (iorest) kmt
c
c     next come the slabs (2 time levels)
c
      do 400 j=1,jmt
        call oget (labs(ndisk), nslab, (j-1)*nslab+1, bufsl)
        write (iorest) bufsl
400   continue
c
      do 500 j=1,jmt
        call oget (labs(ndiska), nslab, (j-1)*nslab+1, bufsl)
        write (iorest) bufsl
500   continue
c
#endif
      return
9200   format (/1x,a34,i3,', ts = ',i7,1x, a32/)
      end
#DECK setgrid.F
      subroutine cmesh (dx, apb, amb, wid, n, ndir)
c
c
c=======================================================================
c
c                   c-o-s-i-n-e   m-e-s-h
c
c     calculate variable width spacings "dx" in domain of width "wid"
c     which is imbedded between fine & coarse resolution domains on
c     either side. the variation of "dx" between fine & coarse
c     resolutions follows a cosine.
c
c     inputs:
c
c     apb=a+b = coarse resolution
c     amb=a-b = fine resolution
c     wid = width between coarse & fine resolution
c     ndir = (1,-1) = spacing (inc,dec) with increasing index
c
c     outputs:
c
c     dx = variable width spacings
c     n  = number of variable spaces calculated to span wid
c        = 2 * wid / ( coarse + fine resoultion)
c
c=======================================================================
c
#include "param.h"
#include "scalar.h"
c
      dimension dx(1000)
c
      a     = p5*(apb+amb)
      b     = p5*(apb-amb)
      c     = (wid/a) + 0.001
      n     = c
      rn    = c1/float(n)
c
      do 100 ii=1,n
        if (ndir .eq. 1)  then
          i = n+1-ii
        elseif (ndir .eq. -1) then
          i = ii
        else
          write (stdout, 9009) ndir
          write (stderr, 9009) ndir
          stop ' cmesh1'
        endif
        dx(i) = a + b*cos(pi*rn*(ii-p5))
100   continue
      write (stdout,9000) apb, amb, wid, c
c
      frac = c-int(c)
      if (frac .gt. 0.01*a) then
        write (stdout, 9010)
        write (stderr, 9010)
        stop ' cmesh  '
      endif
      return
9000  format (/1x,'max res=',e11.4,'  min res=',e11.4,'  width=',e11.4,
     $'  number of grid boxes=',e14.7)
9009  format (/' error => "ndir" =',i8,' but should be 1 or -1 '/)
9010  format (/' error => non integral number of boxes in "wid"'/)
      end
      subroutine grids
c
c
c=======================================================================
c
c     calculate all grid related items
c
c=======================================================================
c
c
#include "param.h"
#include "accel.h"
#include "coord.h"
#include "grdvar.h"
#include "scalar.h"
c
c-----------------------------------------------------------------------
c     set width & height of grid boxes (in degrees)
c-----------------------------------------------------------------------
c
      call mesh (dxt, dyt)
c
c-----------------------------------------------------------------------
c     set latitudes & longitudes of "t" & "u,v" grid points (in degrees)
c-----------------------------------------------------------------------
c
      xt(1) = stlon + p5*dxt(1)
      xu(1) = stlon + dxt(1)
      do 100 i=2,imt
        xt(i) = xt(i-1) +  p5*(dxt(i) + dxt(i-1))
        xu(i) = xu(i-1) +  dxt(i)
100   continue
c
      yt(1) = stlat + p5*dyt(1)
      yu(1) = stlat + dyt(1)
      do 200 j=2,jmt
        yt(j) = yt(j-1) +  p5*(dyt(j) + dyt(j-1))
        yu(j) = yu(j-1) +  dyt(j)
200   continue
c
c     convert to centimeters
c
      do 300 j=2,jmtm1
        dyt(j) = dyt(j)*radius/radian
300   continue
      dyt(1)   = dyt(2)
      dyt(jmt) = dyt(jmtm1)
c
      do 400 i=2,imtm1
        dxt(i) = dxt(i)*radius/radian
400   continue
      dxt(1)   = dxt(2)
      dxt(imt) = dxt(imtm1)
#ifdef cyclic
c
c     set cyclic conditions on dxt
c
      dxt(1)=dxt(imtm1)
      dxt(imt)=dxt(2)
#endif
c
c-----------------------------------------------------------------------
c     compute auxiliary arrays based upon the spacing specified above
c-----------------------------------------------------------------------
c
      do 500 k=1,km
        c2dzt(k) = c2*dzt(k)
        dzt2r(k) = c1/c2dzt(k)
500   continue
c
      dzw(0) = p5*dzt(1)
      zw(1)  = dzt(1)
      do 600 k=2,km
        dzw(k-1) = p5*(dzt(k-1)+dzt(k))
        zw(k)    = zw(k-1)+dzt(k)
600   continue
c
      dzw(km)   = p5*dzt(km)
      dzwr(km)  = c1/dzw(km)
      dzw2r(km) = p5/dzw(km)
      zt(1)     = dzw(0)
c
      do 700 k=1,km
        dzwr(k-1)  = c1/dzw(k-1)
        dzw2r(k-1) = p5/dzw(k-1)
        zt(k+1)  = zt(k) + dzw(k)
700   continue
c
      do 800 k=1,km
#if defined implicitvmix || defined isopycmix
        dztur(k) = c1/(dzw(k-1)*dzt(k))
        dztlr(k) = c1/(dzw(k)*dzt(k))
#endif
#ifdef tcvmix
        dzwur(k) = c1/(dzt(k)*dzw(k))
        if (k .lt. km) dzwlr(k) = c1/(dzt(k+1)*dzw(k))
#endif
        dztr(k)  = c1/dzt(k)
800   continue
c
      phi(1)   = yu(1)/radian
      phit(1)  = phi(1) - p5*dyt(1)/radius
      sumdy    = phi(1)
      dyu(jmt) = dyt(jmt)
c
      do 900 j=1,jmt
        if (j .ne. jmt) dyu(j) = p5*(dyt(j)+dyt(j+1))
        dytr(j)  = c1/dyt(j)
        dyt2r(j) = p5/dyt(j)
        dyt4r(j) = p25/dyt(j)
        dyur(j)  = c1/dyu(j)
        dyu2r(j) = p5/dyu(j)
        dyu4r(j) = p25/dyu(j)
        if (j .ne. jmt) sumdy = sumdy + dyt(j+1)/radius
        if (j .ne. jmt) phi(j+1) = sumdy
        if (j .ne. 1) phit(j) = p5*(phi(j-1)+phi(j))
        cst(j)  = cos(phit(j))
        csu(j)  = cos(phi (j))
        sine(j) = sin(phi(j))
        cstr(j) = c1/cst(j)
        csur(j) = c1/csu(j)
        tng(j)  = sine(j)/csu(j)
#ifndef nohilats
        tanra(j)= tng(j)/radius
#endif
900   continue
c
      dxu(imt)=dxt(imt)
#ifdef cyclic
      dxu(imt)=p5*(dxt(2)+dxt(3))
#endif
c
      do 1000 i=1,imt
        if (i .ne. imt) dxu(i) = p5*(dxt(i)+dxt(i+1))
        dxtr(i)  = c1/dxt(i)
        dxt2r(i) = p5/dxt(i)
        dxt4r(i) = p25/dxt(i)
        dxur(i)  = c1/dxu(i)
        dxu2r(i) = p5/dxu(i)
        dxu4r(i) = p25/dxu(i)
1000  continue
#ifndef implicitvmix
c
c     for convection code, compute values needed to include effects
c     of tracer timestep acceleration on effective layer thicknesses
c
      do 1100 k=1,km
        dztxcl(k) = dzt(k)/dtxcel(k)
1100  continue
c
      do 1200 k=1,kmm1
        dzwxcl(k) = c1/(dztxcl(k)+dztxcl(k+1))
1200  continue
      dzwxcl(km) = c0
c
#endif
c
c-----------------------------------------------------------------------
c     print grid related arrays
c-----------------------------------------------------------------------
c
      write (stdout,9101)
      write (stdout,9001) dzt
      write (stdout,9102)
      write (stdout,9001) dzw
      write (stdout,9103)
      write (stdout,9001) zw
      write (stdout,9104)
      write (stdout,9001) zt
      write (stdout,9105)
      write (stdout,9001) yt
      write (stdout,9106)
      write (stdout,9001) yu
      write (stdout,9107)
      write (stdout,9001) xt
      write (stdout,9108)
      write (stdout,9001) xu
c
       return
c
9001  format (1x,10g13.5)
9101  format (/,' "t" grid box thickness (cm): "dzt(k) k=1..km"')
9102  format (/,' "w" grid box thickness (cm): ',
     $        '"dzw(k) k=0..km"')
9103  format (/,' depth to "t" box bottom (cm): "zw(k) k=1..km"')
9104  format (/,' depth to "t" & "u,v" grid points (cm): "zt(k) ',
     $        'k=1..kmp1"')
9105  format (/,' latitude of t,s points (deg): "yt(j) j=1,jmt"')
9106  format (/,' latitude of u,v points (deg): "yu(j) j=1,jmt"')
9107  format (/,' longitude of t,s points (deg): "xt(i) i=1,imt"')
9108  format (/,' longitude of u,v points (deg): "xu(i) i=1,imt"')
c
       end
      function indp(c, ca, ia)
c
c
c=======================================================================
c
c     indp = index of nearest data point
c
c     inputs:
c
c     c      = arbitrary data point...same units as ca
c     ca     = array of data points  (must be monotonically increasing)
c     ia     = dimension of ca
c
c     output:
c
c     indp =  index of nearest data point to "c"
c             if "c" is outside the domain of "ca" then indp is set to
c             1 or ia depending on  whether c(1) or c(ia) is closest
c
c             note: if "ca" is dimensioned ca(0:ia) in the calling
c                   program, then the returned index should be reduced
c                   by one to account for the zero base.
c
c     example:
c
c     let model depths be defined by the following:
c     parameter (km=5)
c     dimension z(km)
c     data z /5.0, 10.0, 50.0, 100.0, 250.0/
c
c     k1 = indp (12.5, z, km)
c     k2 = indp (0.0, z, km)
c
c     k1 would be set to 2, & k2 would be set to 1 so that
c     z(k1) would be the nearest data point to 12.5 and z(k2) would
c     be the nearest data point to 0.0
c
c=======================================================================
c
c
#ifdef multitasking
cfpp$ noconcur r
#endif
      dimension ca(ia)
c
      if (c .lt. ca(1) .or. c .gt. ca(ia)) then
        if (c .lt. ca(1))  indp = 1
        if (c .gt. ca(ia)) indp = ia
        return
      else
        do 10 i=2,ia
          if (c .le. ca(i)) then
            indp = i
            if (ca(i)-c .gt. c-ca(i-1)) indp = i-1
            go to 11
          endif
10      continue
11      continue
      endif
      return
      end
      subroutine mesh (dx, dy)
c
c=======================================================================
c
c     construct grid spacing "dx" & "dy" by building up "nxres"
c     and "nyres" sub domains
c
c     inputs:
c
c     see "coord.h"
c
c
c     outputs:
c
c     dx = array of longitudinal widths of "t" boxes
c     dy = array of latitudinal heights of "t" boxes
c     see "coord.h" for others
c
c=======================================================================
c
#include "param.h"
#include "coord.h"
      dimension dx(imt), dy(jmt)
c
c-----------------------------------------------------------------------
c     construct longitudinal domains
c-----------------------------------------------------------------------
c
      m  = 1
      xs = stlon
      do 30 l=1,nxres
        write (stdout,'(/,1x,a22,i2)') 'longitude section # ', l
        call cmesh (dx(m), xmax(l), xmin(l), xwid(l), n, idir(l))
        sum = c0
        do 20 i=m,m+n-1
          sum = sum + dx(i)
20      continue
        xe = xs + sum
        write (stdout,'(/,1x,a21,g14.7,a3,g14.7)')
     $         'longitudinal domain: ', xs, '==>', xe
        write (stdout,'(/,1x,a5)')  ' dxt='
        write (stdout,'(1x,10g12.6)') (dx(m+i-1),i=1,n)
        xs = xe
        m = m + n
30    continue
c
c-----------------------------------------------------------------------
c     construct latitudinal domains
c-----------------------------------------------------------------------
c
      m  = 1
      ys = stlat
c
      do 100 l=1,nyres
        write (stdout,'(/,1x,a21,i2)') 'latitude section # ', l
c
        call cmesh (dy(m), ymax(l), ymin(l), ywid(l), n, jdir(l))
c
        sum = c0
        do 90 j=m,m+n-1
          sum = sum + dy(j)
90      continue
        ye = ys + sum
        write (stdout,'(/,1x,a20,g14.7,a3,g14.7)')
     $         'latitudinal domain: ', ys, '==>', ye
        write (stdout,'(/,1x,a5)')  ' dyt='
        write (stdout,'(1x,10g12.6)') (dy(m+j-1),j=1,n)
        ys = ye
        m = m + n
100   continue
c
      return
      end
#DECK setkmp.F
      subroutine setkmp (alat1, slon1, elon1, alat2, slon2, elon2, num)
c
c-----------------------------------------------------------------------
c     set the topography mask "kmt(i,j)" = "num" within the area of the
c     parallelogram bounded by vertices:
c     (alat1,slon1), (alat1,elon1), (alat2,slon1), & (alat2,elon2)
c
c-----------------------------------------------------------------------
c
#include "param.h"
#include "coord.h"
#include "levind.h"
c
c     convert the four vertices into model indices
c     (js,is1), (js,ie1), (je,is2), (je,ie2)
c
      j1 = indp (alat1, yt, jmt)
      j2 = indp (alat2, yt, jmt)
      js = min (j1,j2)
      je = max (j1,j2)
c
      i1  = indp (slon1, xt, imt)
      i2  = indp (elon1, xt, imt)
      is1 = min (i1,i2)
      ie1 = max (i1,i2)
c
      i1  = indp (slon2, xt, imt)
      i2  = indp (elon2, xt, imt)
      is2 = min (i1,i2)
      ie2 = max (i1,i2)
c
      is = is1
      ie = ie1
c
c     fill in the area bounded by (js,is1), (js,ie1), (je,is2), (je,ie2)
c
      if (js .eq. je) then
        rdj = c1
      else
        rdj = c1/(je-js)
      endif
      do 100 j=js,je
        do 90 i=is,ie
          kmt(i,j) = num
90      continue
        is = nint(rdj*((j-js)*is2 + (je-j)*is1))
        ie = nint(rdj*((j-js)*ie2 + (je-j)*ie1))
100   continue
      return
      end
#DECK setvbc.F
      subroutine setvbc (j)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c
c     compute vertical boundary conditions for clinic & tracer
c
c=======================================================================
c
#include "param.h"
#include "cvbc.h"
#include "grdvar.h"
#include "levind.h"
#include "scalar.h"
#include "slabs.h"
c
      dimension star(4)
c
c----------------------------------------------------------------------
c     get test case surface temperatures, salinities and wind stresses
c     (they vary with latitude)
c----------------------------------------------------------------------
c
c     note: test case assumes nt=2 (potential temperature and salinity)
c
      call bcest (j, star)
c
c     convert surface salinity to model units from parts per mil
c
      star(2) = (star(2) - 35.0) * 0.001
c
c----------------------------------------------------------------------
c     set test case surface tracer fluxes
c----------------------------------------------------------------------
c
c     set no flux condition for tracer at surface & bottom.
c
      do 100 m=1,2
        do 90 i=2,imtm1
          stf(i,m) = c0
          btf(i,m) = c0
90      continue
100   continue
c
#ifdef restorst
c
c----------------------------------------------------------------------
c     restore surface tracers to prescribed values via
c     newtonian damping term with restoring time scale of "rests" days
c----------------------------------------------------------------------
c
      gamma = secday/rests
      do 200 m=1,2
        do 190 i=2,imtm1
          restr(i,m) = gamma * (star(m)-t(i,1,jc,nm,m))
190     continue
200   continue
#endif
c
c----------------------------------------------------------------------
c     set test case surface & bottom stresses
c----------------------------------------------------------------------
c
      do 300 i=1,imt
        kz = kmu(i,j)
        smf(i,1) = star(3)
        smf(i,2) = star(4)
        if (kz .ne. 0) then
          uvmag    = sqrt(u(i,kz,jc,nm)**2 +v(i,kz,jc,nm)**2)
          bmf(i,1) = cdbot*u(i,kz,jc,nm)*uvmag
          bmf(i,2) = cdbot*v(i,kz,jc,nm)*uvmag
        else
          bmf(i,1) = c0
          bmf(i,2) = c0
        endif
300   continue
c
      return
      end
#DECK size.F
      subroutine size
c      program size
c
c-----------------------------------------------------------------------
c     "size" is a stand alone program to determine memory & disk
c      requirements for various MOM configurations.
c
c     to use:
c       a) define the ifdef options (below or on the compile statement)
c       b) set the appropriate parameters ( imt,jmt,km...etc)
c       c) run it
c-----------------------------------------------------------------------
c
c     define some "ifdef's" here (by removing the "c" in column 1)
c
c#define biharmonic
c#define rigidlid
c#define congrad5pt
c#define ppvmix
c#define islands
c
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     imt    = number of grid points in longitudinal direction
c     jmt    = number of grid points in latitudinal direction
c     km     = number of grid points in the vertical direction
c     nt     = number of tracers
c     lseg   = maximum number of longitudinal stream function segments
c     nisle  = number of islands
c     nslabs = number of j rows (slabs) in the memory slab window
c     ntau   = number of time levels in the memory slab window
c     numjpt = number of pointers for internal mode velocities
c              (also used for del**2 fields with biharmonic option)
c     istart = starting longitude for calculations
c              (if "skipland" is set, "istart" is calculated for each
c               longitudinal strip of ocean ... skipping land points)
c     iend   = ending longitude for calculations
c              (if "skipland" is set, "iend" is calculated for each
c               longitudinal strip of ocean ... skipping land points)
c     nvar   = number of prognostic variables
c     nvarbh = number of prognostic variables using biharmonic mixing
c     ntlev  = number of time levels on disk
c     nxres  = number of sub domains of either constant or smoothly
c              varying grid box width (see "coord.h")
c     nyres  = number of sub domains of either constant or smoothly
c              varying grid box height (see "coord.h")
c     nhreg = number of regions in the horizontal used for averaging
c             tracers.
c     nvreg = number of regions in the vertical used for term balance
c             calculations. note "nvreg" is not used for tracer averages
c     numreg= total number of regions ( = product of nhreg & nvreg)
c             used for term balance calculations
c
      parameter (imt=362, jmt=190, km=30, nt=2, lseg=5, nisle=2
     $,          ntau=2, nxres=1, nyres=5
#ifdef biharmonic
     $,          nslabs=4, numjpt=3
#else
     $,          nslabs=3, numjpt=2
#endif
     $,          nhreg = 5, nvreg = 2, numreg = nhreg*nvreg
     $,          nvar=nt+2
#ifdef tcvmix
     $                    +4
# ifdef leq
     $                      +1
# endif
#endif
#ifdef biharmonic
     $,          nvarbh=nt+2
# ifdef tcvmix
     $                    +1
#  ifdef leq
     $                      +1
#  endif
# endif
#endif
#if defined diskless && !defined multitasking
     $,          ntlev=2
#else
     $,          ntlev=3
#endif
#ifdef cyclic
     $,          imu=imt)
#else
     $,          imu=imt-1)
#endif
      parameter  (imtp1=imt+1, imtm1=imt-1, imtm2=imt-2, imum1=imu-1
     $,          imum2=imu-2, jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2
#ifndef skipland
     $,          istart=2, iend=imtm1
#endif
#ifdef symmetry
     $,          jscan=jmtm2+1
#else
     $,          jscan=jmtm2
#endif
     $,          kmp1=km+1, kmp2=km+2, kmm1=km-1
     $,          imtkm=imt*km, nwds=imt*jmt, nkflds=6
     $,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (ie: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (ie: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (ie: p5 for 0.5)
c     use prefix of "r" for reciprocals (ie: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (ie: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c4=4.0, c5=5.0, c8=8.0)
      parameter (c16=16.0, c360=360.0)
      parameter (p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     stdin, stdout, and stderr set the Fortran units for
c     standard input, standard output, and standard error messages
c     (used in read and write statements)
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
      parameter (nlatpr=10)
      parameter (lsegf=5, jmtfil=20)
c
c-----------------------------------------------------------------------
c     list ifdef options (only those which affect sizing calculations)
c-----------------------------------------------------------------------
c
      write (stdout,'(//a32)') '  MOM"s activated ifdef options:'
#ifdef multitasking
      write(stdout,*) ' multitasking'
#endif
#ifdef biharmonic
      write(stdout,*) ' biharmonic'
#endif
#ifdef tcvmix
       write(stdout,*) ' tcvmix'
#endif
#ifdef leq
       write(stdout,*) ' leq'
#endif
#ifdef diskless
       write(stdout,*) ' diskless'
#endif
#ifdef isopycmix
       write(stdout,*) ' isopycmix'
#endif
#ifdef islands
       write(stdout,*) ' islands'
#endif
#ifdef ppvmix
       write(stdout,*) ' ppvmix'
#endif
#ifdef congrad5pt
       write(stdout,*) ' congrad5pt'
#endif
#ifdef congrad9pt
       write(stdout,*) ' congrad9pt'
#endif
#ifdef hypergrid
       write(stdout,*) ' hypergrid'
#endif
#ifdef implicitvmix
       write(stdout,*) ' implicitvmix'
#endif
#ifdef fourfil
       write(stdout,*) ' fourfil'
#endif
#ifdef firfil
       write(stdout,*) ' firfil'
#endif
#ifdef restorst
       write(stdout,*) ' restorst'
#endif
#ifdef keepterms
      write(stdout,*) ' keepterms'
#endif
#ifdef nohilats
      write(stdout,*) ' nohilats'
#endif
#ifdef rigidlid
      write(stdout,*) ' rigidlid'
#endif
      write (stdout,'(a30)')   '  end ifdef options list'
c
      write (stdout,9000) ' include file  ','size (words)'
c
      priv = c0
      shar = c0
      disk = c0
c
c====================== include file "accel.h" =========================
c
      accel =  km
      shar = shar + accel
      write (stdout,9100) '        accel.h', nint(accel)
c
c====================== include file "cbihar.h" ========================
c
#ifdef biharmonic
      cbihar = imtkm*nvarbh*numjpt
      priv = priv + cbihar
      write (stdout,9100) '       cbihar.h', nint(cbihar)
#endif
c
c====================== include file "cdiag.h" =========================
c
      cdiag =  kmp1*(jmt + nt*jmt + 8) + 8 + nt
     $        + nt*(numreg+1 + nhreg+1) + 3*numreg
#ifdef isopycmix
      cdiag = cdiag + kmp1*9*nt*(numreg+1)
#else
      cdiag = cdiag + kmp1*8*nt*(numreg+1)
#endif
      cdiag = cdiag + kmp1*13*2*numreg + kmp1*nt*(numreg+1)
     $        + (nt+2)*(nhreg+1) + km+1 + 4*8*imt
     $        + km + 2*km*nt + 8*jmt*ntmin2 + jmt*km
      shar = shar + cdiag
      write (stdout,9100) '        cdiag.h', nint(cdiag)
c
c====================== include file "chmix.h" =========================
c
      chmix = 8*jmt + 4
      shar = shar + chmix
      write (stdout,9100) '        chmix.h', nint(chmix)
c
c====================== include file "cisop.h" =========================
c
#ifdef isopycmix
      cisop = (9+nt)*imtkm + 5*imt*kmp1 + 2
      shar = shar + cisop
      write (stdout,9100) '        cisop.h', nint(cisop)
#endif
c
c====================== include file "coord.h" =========================
c
      coord = 2 + 2*imt + 2*jmt + km + kmp1 + 4*(nxres + nyres)
      shar = shar + coord
      write (stdout,9100) '        coord.h', nint(coord)
c
c====================== include file "cpolar.h" ========================
c
#if defined fourfil || defined firfil
      cpolar = 2*imt
      shar = shar + cpolar
      write (stdout,9100) '       cpolar.h', nint(cpolar)
c
#endif
c
c====================== include file "cprnts.h" =======================
c
      cprnts = 5*nlatpr + 4
      shar = shar + cprnts
      write (stdout,9100) '       cprnts.h', nint(cprnts)
c
c====================== include file "cregin.h" ========================
c
      cregin = nwds + km + numreg*2 + kmp1*nhreg + km + 2 + nhreg
     $         + 4*(numreg+1)
      shar = shar + cregin
      write (stdout,9100) '       cregin.h', nint(cregin)
c
c====================== include file "cppmix.h" ========================
c
#ifdef ppvmix
      cppmix = 4*imtkm
      priv   = priv + cppmix
      cppmix = cppmix + 4
      shar   = shar + 4
      write (stdout,9100) '       cppmix.h', nint(cppmix)
#endif
c
c====================== include file "crelax.h" ========================
c
      crelax = 4
      shar   = shar + crelax
      write (stdout,9100) '       crelax.h', nint(crelax)
c
c====================== include file "cshrbf.h" =======================
c
#ifdef multitasking
      cshrbf = nslab
      write (stdout,9100) '       cshrbf.h', nint(cshrbf)
      shar   = shar + cshrbf
#endif
c
c====================== include file "ctask.h" =========================
c
      ctask = 2*jmt + 2
      priv  = priv + ctask
      ctask = ctask + 2
      shar  = shar + 2
      write (stdout,9100) '        ctask.h', nint(ctask)
c
c====================== include file "ctcmix.h"=========================
c
#ifdef tcvmix
      ctcmix = (15+nslabs)*imtkm
# ifdef leq
      ctcmix = ctcmix + 3*imtkm
# endif
      priv   = priv + ctcmix
      ctcmix = ctcmix + 29
      shar   = shar +  29
      write (stdout,9100) '       ctcmix.h', nint(ctcmix)
#endif
c
c====================== include file "ctmngr.h" ========================
c
      ctmngr = 21
      shar   = shar +  21
      write (stdout,9100) '       ctmngr.h', nint(ctmngr)
c
c====================== include file "cvbc.h" ==========================
c
      cvbc = (2*nt + 4)*imt
      priv   = priv + cvbc
      write (stdout,9100) '         cvbc.h', nint(cvbc)
c
c====================== include file "cvmix.h" =========================
c
#ifndef tcvmix
      cvmix = 2*imtkm
      priv   = priv + cvmix
      write (stdout,9100) '        cvmix.h', nint(cvmix)
#endif
c
c====================== include file "emode.h" =========================
c
      emode = 13*nwds
#ifdef hypergrid
      emode = emode + nwds
#endif
#if defined congrad5pt || defined congrad9pt
      emode = emode + 3*nwds + jmt
#endif
#ifdef congrad9pt
      emode = emode + 4*nwds
#endif
#ifdef islands
      emode = emode + nwds + nisle
#endif
      shar = shar + emode
      write (stdout,9100) '        emode.h', nint(emode)
c
c====================== include file "grdvar.h" ========================
c
      grdvar = 8*imt + 17*jmt + 4*km + 3*kmp1
#ifdef tcvmix
      grdvar = grdvar + 2*km
#endif
#if defined implicitvmix || defined isopycmix
      grdvar = grdvar + 2*km
#endif
#ifndef nohilats
      grdvar = grdvar + jmt
#endif
      shar = shar + grdvar
      write (stdout,9100) '       grdvar.h', nint(grdvar)
c
c====================== include file "index.h" =========================
c
      index = 4*jmt*lseg
#ifdef rigidlid
      index = index + 2*jmt*lseg
#  ifdef islands
      index = index + 8*nisle
#  endif
      index = index + 4*jmtfil*lsegf*km + 2*jmtfil*lsegf
#endif
      shar = shar + index
      write (stdout,9100) '        index.h', index
c
c====================== include file "pfil.h" ==========================
c
#if defined fourfil || defined firfil
      pfil = 18
#ifdef firfil
      pfil = pfil + jmtfil*2
#endif
      shar = shar + pfil
      write (stdout,9100) '         pfil.h', nint(pfil)
#endif
c
c====================== include file "iounit.h" ========================
c
      iounit = 12
      shar = shar + iounit
      write (stdout,9100) '       iounit.h', iounit
c
c====================== include file "levind.h" ========================
c
      levind = 2*nwds
      shar = shar + levind
      write (stdout,9100) '       levind.h', levind
c
c====================== include file "scalar.h" ========================
c
      scalar = 15
      shar = shar + scalar
      write (stdout,9100) '       scalar.h', nint(scalar)
c
c====================== include file "slabs.h" =========================
c
#ifdef biharmonic
      slabs = 10
#else
      slabs = 6
#endif
      slabs = slabs + nslab*nslabs*ntau
      bufout = nslab
      bufin = nslab
      work = 2*imtkm*numjpt + (8+2*nslabs)*imtkm + 6*imt*kmp1
#ifdef restorst
      work = work + imt*nt + 1
#endif
      aux = 4*imtkm

      source = 2*imtkm + imtkm*nt
#ifdef keepterms
      terms = 3*imtkm
# ifdef isopycmix
      terms = terms + 3*imtkm
# else
      terms = terms + 2*imtkm
# endif
      terms = terms + 7*imtkm
# ifndef nohilats
      terms = terms + 2*imtkm
# endif
      terms = terms + 10*imtkm
      priv = priv + terms
      write (stdout,9100) '        terms.h', nint(terms)
#endif
c
      priv = priv +  bufin + source + bufout + slabs + work + aux
      write (stdout,9100) '        bufin.h', nint(bufin)
      write (stdout,9100) '       bufout.h', nint(bufout)
      write (stdout,9100) '       source.h', nint(source)
      write (stdout,9100) '        slabs.h', nint(slabs)
      write (stdout,9100) '         work.h', nint(work)
      write (stdout,9100) '          aux.h', nint(aux)
c
c====================== include file "switch.h" ========================
c
      switch = 17
      shar = shar + switch
      write (stdout,9100) '       switch.h', nint(switch)
c
c====================== include file "temp.h" ==========================
c
      temp = 2*imtkm
#if defined implicitvmix || defined isopycmix
      temp = temp + 2*imtkm
#endif
      priv = priv + temp
      write (stdout,9100) '         temp.h', nint(temp)
c
c     local storage starts here
c
      write (stdout,'(/a28/)') '  storage local to routines'
c
#ifdef rigidlid
      local = nwds
      shar = shar + local
      write (stdout,9100) '  ocean (local)', local
#endif
#ifdef multitasking
      local = imtkm
      shar = shar + local
      write (stdout,9100) '  vort (local)', local
#endif
#ifdef implicitvmix
      local = imtkm*6
      priv = priv + local
      write (stdout,9100) '  invtri (local)', local
#endif
#ifdef tcvmix
      local = imtkm*(nslabs+1)
#ifndef implicitvmix
      local = local + imtkm
# ifdef leq
      local = local + imtkm
# endif
#endif
      priv = priv + local
      write (stdout,9100) '  tcmix (local)', local
#ifdef implicitvmix
      local = local + imtkm*8
#endif
      priv = priv + local
      write (stdout,9100) '  implq (local)', local
#endif
c
c     disk storage
c
      write (stdout,'(/a28/)') '  storage needed for disk  '
#ifdef diskless
      sdisk = ntlev*nwds*km*nvar
      shar = shar + sdisk
      write (stdout,9100) ' simulated disk', nint(sdisk)
#else
      disk = ntlev*nwds*km*nvar
      write (stdout,9100) '           disk', nint(disk)
#endif
c
c     convert to megawords
c
      priv = priv * 1.0e-6
      shar = shar * 1.0e-6
      disk = disk * 1.0e-6
c
c     show results
c
#ifdef multitasking
      do 100 n=1,4
        write (stdout,9200) 'Resources needed for ', 2*n, ' processors'
        pri  = priv*2*n
        totm = pri + shar
        write (stdout,9300) ' private variables   = ', pri, ' MW'
        write (stdout,9300) ' shared  variables   = ', shar, ' MW'
        write (stdout,9300) ' total memory needed = ', totm, ' MW'
        write (stdout,9300) ' total disk needed   = ', disk, ' MW'
100   continue
#else
      write (stdout,9250) 'Resources needed '
      totm = priv + shar
      write (stdout,9300) ' total memory needed = ', totm, ' MW'
      write (stdout,9300) ' total disk needed   = ', disk, ' MW'
#endif
      stop
9000  format (//8x,'MOM"s resource estimates',//,4x,a15,3x, a12/)
9100  format (a15,5x,i10)
9200  format (//10x,a20,i2,a11/)
9250  format (//10x,a20/)
9300  format (10x,a23,f7.2,a3)
      end
#DECK state.F
      subroutine state (t, s, rho)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c
c=======================================================================
c
c     state computes one row of normalized densities by using a 3rd
c     order polynomial fit to the knudsen formula, for each level
c     subtract normalizing constants from temperature and salinity
c     and compute polynomial approximation of knudsen density.
c
c     note.. for precision purposes, there is a depth dependent
c     constant subtracted from the density returned by this routine.
c     so... this routine should be used only for horizontal gradients
c     of density.
c
c     inputs:
c
c     t = the input row of temperatures
c     s = the input row of salinities (units: (ppt-35)/1000)
c
c     output:
c
c     rho = normalized densities
c
c=======================================================================
c
c
#include "param.h"
c
      dimension t(imt,km), s(imt,km), rho(imt,km)
      common /cstate/ to(km), so(km), c(km,9)
c
#include "dncoef.h"
c
c-----------------------------------------------------------------------
c     statement function
c-----------------------------------------------------------------------
c
      dens (tq, sq, k) = (c(k,1) + (c(k,4) + c(k,7)*sq)*sq +
     $                   (c(k,3) + c(k,8)*sq + c(k,6)*tq)*tq)*tq +
     $                   (c(k,2) + (c(k,5) + c(k,9)*sq)*sq)*sq
c
c-----------------------------------------------------------------------
c
      do 100 k=1,km
        do 90 i=1,imt
          rho(i,k) = dens (t(i,k)-to(k), s(i,k)-so(k), k)
90      continue
100   continue
c
      return
c
c
c
c
      entry statec (t, s, rho, ind)
c
c
c=======================================================================
c
c     statec computes, for one row, the normalized densities by using
c     a 3rd order polynomial fit to the knudsen formula. For
c     purposes of checking vertical stability between adjacent
c     levels, the reference depth for pressure dependence in
c     the knudsen formula must be held constant. that level is
c     determined by "ind".
c
c     inputs:
c
c     t   = the input row of temperatures
c     s   = the input row of salinities (units: (ppt-35)/1000)
c     ind = 1 for comparing levels 1 to 2, 3 to 4, etc.
c           (coefficients for the lower of the 2 levels are used)
c           2 for comparing levels 2 to 3, 4 to 5, etc.
c           (coefficients for the lower of the 2 levels are used)
c
c     output:
c
c     rho = normalized densities
c
c=======================================================================
c
c
      if (ind .lt. 1 .or. ind .gt. 2) then
        write (stderr,99)
        stop '1 statec'
      endif
c
      do 200 l=1,km,2
        if (ind .eq. 1) then
          k = min(l+1,km)
        else
          k = l
        endif
        do 190 i=1,imt
          rho(i,l) = dens (t(i,l)-to(k), s(i,l)-so(k), k)
190     continue
200   continue
c
      do 300 l=2,km,2
        if (ind .eq. 1) then
          k = l
        else
          k = min(l+1,km)
        endif
        do 290 i=1,imt
          rho(i,l) = dens (t(i,l)-to(k), s(i,l)-so(k), k)
290     continue
300   continue
      return
   99 format(/' error => bad "ind" in statec: ind =',i10)
      end
#DECK step.F
      subroutine step (ntask)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c
c     step is called once per timestep. it initializes various
c     quantities and cycles data from tau & tau-1 discs into the memory
c     slab window a row at a time. after prognostic variables are
c     predicted for each row, it writes them out to the tau+1 disc.
c
c=======================================================================
c
c
#include "param.h"
#include "cdiag.h"
#ifdef isopycmix
#include "cisop.h"
#endif
#include "crelax.h"
#include "ctask.h"
#include "ctmngr.h"
#include "cvbc.h"
#include "cvmix.h"
#include "emode.h"
#include "grdvar.h"
#include "iounit.h"
#include "levind.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
#include "temp.h"
c
      dimension ubar(imt), vbar(imt)
c
c-----------------------------------------------------------------------
c     set up the starting & ending j rows for this task
c-----------------------------------------------------------------------
c
      if (ntask .ne. 0) then
        jsrow =  jsrowb(ntask)
        jerow =  jerowb(ntask)
      else
        jsrow =  1
        jerow =  jmt-1
      endif
c
c-----------------------------------------------------------------------
c     queue up disk reads
c-----------------------------------------------------------------------
c
      do 100 j=jsrow,jerow
        if (mixts) then
          call ofind(labs(ndisk),nslab,(j-1)*nslab+1)
        else
          call ofind(labs(ndiskb),nslab,(j-1)*nslab+1)
        endif
        call ofind(labs(ndisk),nslab,(j-1)*nslab+1)
100   continue
c
#ifdef biharmonic
c
c-----------------------------------------------------------------------
c     read  row  "jsrow-1", "jsrow" & "jsrow+1" variables from disk into
c     the memory slab window. save internal modes, construct masks &
c     total velocity for tau & tau-1
c-----------------------------------------------------------------------
c
      jm  = mod(jsrow-1,nslabs) + 1
      jc  = mod(jsrow,  nslabs) + 1
      jp  = mod(jsrow+1,nslabs) + 1
c
      call getvar (max(1,jsrow-1),jm)
      call getvar (jsrow,  jc)
      call getvar (jsrow+1,jp)
c
c-----------------------------------------------------------------------
c     compute del**2 quantities for "jsrow"
c-----------------------------------------------------------------------
c
      call delsqr (jsrow, jm, jc, jp)
#else
c
c-----------------------------------------------------------------------
c     read  row "jsrow" variables from disk into the memory slab window.
c     save internal modes, construct masks & total velocity for tau &
c     tau-1
c-----------------------------------------------------------------------
c
      jc = mod(jsrow,nslabs) + 1
c
      call getvar (jsrow, jc)
#endif
c
c
c=======================================================================
c=======================================================================
c
c     begin row-by-row computation of prognostic variables within task
c
c=======================================================================
c=======================================================================
c
      do 700 j=jsrow,jerow
c
c-----------------------------------------------------------------------
c       set the memory slab window pointers (indices)
c       jm = southern slab (row j-1, m stands for minus one)
c       jc = central slab  (row j)
c       jp = northern slab (row j+1, p stands for plus one)
c-----------------------------------------------------------------------
c
        jm = mod(j-1,nslabs) + 1
        jc = mod(j  ,nslabs) + 1
        jp = mod(j+1,nslabs) + 1
#ifdef biharmonic
c
c-----------------------------------------------------------------------
c       set additional memory slab window pointer (index)
c       jpp = northern most slab (row j+2, p stands for plus one)
c       read row j+2 variables from disk into the memory slab window.
c       save internal modes, construct masks & total velocity for tau &
c       tau-1 then ... compute del**2 quantities for row "j+1"
c-----------------------------------------------------------------------
c
        jpp = mod(j+2,nslabs) + 1
c
        call getvar (j+2, jpp)
        call delsqr (j+1, jc, jp, jpp)
#else
c
c-----------------------------------------------------------------------
c       read row j+1 variables from disk into the memory slab window.
c       save internal modes, construct masks & total velocity for tau &
c       tau-1)
c-----------------------------------------------------------------------
c
        call getvar (j+1, jp)
#endif
c
c-----------------------------------------------------------------------
c       initiate writeout of newly computed data from previous row
c       should a copy of the data be saved for off line analysis also?
c-----------------------------------------------------------------------
c
        if (j .gt. jsrow + 1) then
c
          call oput (labs(ndiska), nslab, (j-2)*nslab+1, ta)
c
          if (eots .and. snapts) then
            if (j .eq. jsrow + 2) then
              write (stdout,920)
     $         '==>  Writing  a snapshot of MOM"s data on unit '
     $,                    iosnap, itt, stamp
            endif
            write (iosnap) smf, stf, ta, ua, va
#ifdef tcvmix
     $,                    vvca, vdca, vdqca, q2a
# ifdef leq
     $,                    q2la
# endif
#endif
          endif
        endif
c
#ifdef symmetry
c
c-----------------------------------------------------------------------
c       set symmetry boundary conditions on last row
c-----------------------------------------------------------------------
c
        if (j .eq. jmtm1) then
          do 500 m=1,nt
            do 490 k=1,km
              do 480 i=1,imt
                t(i,k,jp,nm,m) = t(i,k,jc,nm,m)
                t(i,k,jp,nc,m) = t(i,k,jc,nc,m)
480           continue
490         continue
500       continue
        endif
#endif
c
c-----------------------------------------------------------------------
c       set all source terms
c-----------------------------------------------------------------------
c
        if (j .ne. jsrow) then
          do 660 k=1,km
            do 650 i=1,imt
              sourcu(i,k) = c0
              sourcv(i,k) = c0
650         continue
660       continue
          do 690 m=1,nt
            do 680 k=1,km
              do 670 i=1,imt
                sourct(i,k,m) = c0
670           continue
680         continue
690       continue
        endif
c
c-----------------------------------------------------------------------
c       set vertical boundary conditions (surface & bottom)
c-----------------------------------------------------------------------
c
        if (j .ne. jsrow) call setvbc (j)
c
c-----------------------------------------------------------------------
c       set vertical mixing coefficients
c-----------------------------------------------------------------------
c
#ifdef ppvmix
        call ppmix (j)
#endif
#if defined constvmix
        if (j .ne. jsrow) call cnvmix (j)
#endif
#ifdef tcvmix
        call tcmix(j)
#endif
#ifdef isopycmix
c
c       calculate slopes and set mixing coefficients
c       to orient diffusion of tracers along isopycnal surfaces
c
        call isop0 (j)
#endif
#ifdef testcfl
c
c-----------------------------------------------------------------------
c       monitor velocities at current time level "nc"
c-----------------------------------------------------------------------
c
        call cfl (j)
#endif
c
c-----------------------------------------------------------------------
c       calculate internal mode velocities
c-----------------------------------------------------------------------
c
#ifdef symmetry
        call clinic (j)
#else
        if (j .ne. jmtm1) call clinic (j)
#endif
c
c-----------------------------------------------------------------------
c       calculate tracers
c-----------------------------------------------------------------------
c
        call tracer (j)
c
c-----------------------------------------------------------------------
c       calculate & print diagnostics on diagnostic timesteps
c-----------------------------------------------------------------------
c
        if (diagts .and. eots) call diag (j)
c
700   continue
c
c-----------------------------------------------------------------------
c     initiate writeout of newly computed data from row "jerow"
c     should a copy of the data be saved for off line analysis also?
c-----------------------------------------------------------------------
c
      call oput (labs(ndiska), nslab, (jerow-1)*nslab+1, ta)
c
      if (eots .and. snapts) then
        write (iosnap) smf, stf, ta, ua, va
#ifdef tcvmix
     $,                vvca, vdca, vdqca, q2a
# ifdef leq
     $,                q2la
# endif
#endif
      endif
      return
920   format (/1x,a47,i3,', ts = ',i7,1x, a32/)
      end
      subroutine getvar (jrowt, jptr)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c
c     read prognostic variables from row "jrowt" on disk into the
c     memory slab window at position "jptr". set the masks for "jrowt" &
c     save a copy of the internal modes before constructing the full
c     velocity.
c
c=======================================================================
c
#include "param.h"
#include "ctask.h"
#include "emode.h"
#include "grdvar.h"
#include "iounit.h"
#include "levind.h"
#include "slabs.h"
#include "switch.h"
c
      dimension ubar(imt), vbar(imt)
c
c     limit size of jrow
c
      jrow = min(jrowt,jmt)
c
c-----------------------------------------------------------------------
c     read slabs from row "jrow" on disk into the memory slab window
c     at row "jptr"
c-----------------------------------------------------------------------
c
      if (jrow .lt. jmt) then
        if (mixts) then
          call oget (labs(ndisk), nslab, (jrow-1)*nslab+1, bufsl)
        else
          call oget (labs(ndiskb), nslab, (jrow-1)*nslab+1, bufsl)
        endif
        call xfer (bufsl, t(1,1,jptr,nm,1))
        call oget (labs(ndisk ), nslab, (jrow-1)*nslab+1, bufsl)
        call xfer (bufsl, t(1,1,jptr,nc,1))
      endif
c
c-----------------------------------------------------------------------
c     set masks for row "jrow"
c-----------------------------------------------------------------------
c
      do 100 k=1,km
        do 90 i=1,imt
          if (kmt(i,jrow) .ge. k) then
            fm(i,k,jptr) = c1
          else
            fm(i,k,jptr) = c0
          endif
          if (kmu(i,jrow) .ge. k) then
            gm(i,k,jptr) = c1
          else
            gm(i,k,jptr) = c0
          endif
90      continue
100   continue
c
c-----------------------------------------------------------------------
c     set pointers (indices) to cycle internal modes
c     (also used to cycle del**2 quantities for biharmonic option)
c-----------------------------------------------------------------------
c
      jpt1 = mod (jrowt+1,numjpt) + 1
      jpt2 = mod (jrowt+2,numjpt) + 1
      jpt  = jpt2
#ifdef biharmonic
      jpt3 = mod (jrowt+3,numjpt) + 1
      jpt  = jpt3
#endif
c
c-----------------------------------------------------------------------
c     save a copy of the internal mode velocity from row "jrow"
c     (row "jrow + 1"  if the biharmonic option is enabled) for use
c     in constructing "fvsu" in clinic and diagnostic caluclations
c-----------------------------------------------------------------------
c
      do 200 k=1,km
        do 190 i=1,imt
          uclin(i,k,jpt) = u(i,k,jptr,nc)
          vclin(i,k,jpt) = v(i,k,jptr,nc)
190     continue
200   continue
c
c-----------------------------------------------------------------------
c     add external mode velocity to internal mode velocity for row
c     row "jsrow" (tau & tau-1)
c-----------------------------------------------------------------------
c
      if (jrow .le. jmtm1) then
        do 300 m=1,2
          if (m .eq. 1) then
            n = nc
          else
            n = nm
          endif
          do 270 i=1,imtm1
            diag1   = p(i+1,jrow+1,m) - p(i  ,jrow,m)
            diag0   = p(i  ,jrow+1,m) - p(i+1,jrow,m)
            ubar(i) = -(diag1+diag0)*dyu2r(jrow)*hr(i,jrow)
            vbar(i) =  (diag1-diag0)*dxu2r(i)*hr(i,jrow)*csur(jrow)
270       continue
#ifdef cyclic
c
c         set cyclic boundary conditions
c
          ubar(imt) = ubar(2)
          vbar(imt) = vbar(2)
#endif
          do 290 k=1,km
            do 280 i=1,imu
              u(i,k,jptr,n) = (u(i,k,jptr,n) + ubar(i))*gm(i,k,jptr)
              v(i,k,jptr,n) = (v(i,k,jptr,n) + vbar(i))*gm(i,k,jptr)
280         continue
290       continue
300     continue
      endif
c
      return
      end
#DECK tcmix.F
      subroutine tcmix (j)
c
c=======================================================================
c
c     compute vertical mixing coefficients based on mellor-yamada level
c     2.5 turbulence closure scheme as implemented and described in
c     rosati & miyakoda (jpo,vol 18,#11,1988).
c
c     inputs:
c
c     j      = row j
c
c     outputs:
c
c     vertical mixing coefficient arrays "vdca,vvca or vdc,vvc"
c     in "tcslab.h"
c
c=======================================================================
c
#ifdef tcvmix
#include "param.h"
#include "coord.h"
#include "cprnts.h"
#include "chmix.h"
#include "ctask.h"
#include "ctcmix.h"
#include "ctmngr.h"
#include "cvbc.h"
#include "cvmix.h"
#include "grdvar.h"
#include "levind.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
#include "temp.h"
      dimension drho(imt,km)
#ifdef lalg
      dimension sum0(imt), sum1(imt)
#endif
      dimension ekn(imt,km,nslabs)
      dimension bcl(imt), ustar(imt)
#ifndef implicitvmix
      dimension q2dif(imt,0:km)
#  ifdef leq
     $         ,q2ldif(imt,0:km)
#  endif
#endif
c
c----------------------------------------------------------------------
c     construct physical operators using statement functions
c----------------------------------------------------------------------
c
c     zonal,meridional & vertical advection of tke
c
      uq2x(i,k) = aux1(i+1,k) - aux1(i,k)
      vq2y(i,k) = p5*(fvn(i,k)+fvn(i,k+1))
     $              *(q2(i,k,jp,nc)+q2(i,k,jc,nc))
     $           -p5*(fvsq(i,k)+fvsq(i,k+1))
     $              *(q2(i,k,jc,nc)+q2(i,k,jm,nc))
      wq2z(i,k) = (fwb1(i,k-1) - fwb1(i,k))*dzw2r(k)*p5
c
c     zonal,meridional diffusion of tke
c
          q2xx(i,k)=bbtj*dxt4r(i)*
     $             (fm(i+1,k,jc)*aux3(i+1,k)-fm(i-1,k,jc)*aux3(i,k))
          q2yy(i,k) = cctj*fm(i,k,jp)*(q2(i,k,jp,nm)-q2(i,k,jc,nm))+
     $                 ddtj*fm(i,k,jm)*(q2(i,k,jm,nm)-q2(i,k,jc,nm))
#ifndef implicitvmix
c
c     vertical diffusion of tke
c
      q2zz(i,k) = eeq(i,k)*q2dif(i,k-1) - ffq(i,k)*q2dif(i,k)
#endif
#ifdef leq
c
c     zonal,meridional & vertical advection of tkel
c
      uq2lx(i,k) = aux2(i+1,k) - aux2(i,k)
      vq2ly(i,k) = p5*(fvn(i,k)+fvn(i,k+1))
     $              *(q2l(i,k,jp,nc)+q2l(i,k,jc,nc))
     $           -p5*(fvsq(i,k)+fvsq(i,k+1))
     $              *(q2l(i,k,jc,nc)+q2l(i,k,jm,nc))
      wq2lz(i,k) = (fwb2(i,k-1) - fwb2(i,k))*dzw2r(k)*p5
c
c     zonal,meridional diffusion of tke
c
          q2lxx(i,k)=bbtj*dxt4r(i)*
     $             (fm(i+1,k,jc)*aux4(i+1,k)-fm(i-1,k,jc)*aux4(i,k))
          q2lyy(i,k) = cctj*fm(i,k,jp)*(q2l(i,k,jp,nm)-q2l(i,k,jc,nm))+
     $                 ddtj*fm(i,k,jm)*(q2l(i,k,jm,nm)-q2l(i,k,jc,nm))
#  ifndef implicitvmix
c
c     vertical diffusion of tke
c
      q2lzz(i,k) = eeq(i,k)*q2ldif(i,k-1) - ffq(i,k)*q2ldif(i,k)
#  endif
#endif
c
c     initialize mixing coefficients to constant values
c
      if (init .and. first) then
        do  100 k=1,km
          do  90 i=1,imt
            vvc (i,k,jc,nc) = fkpm
            vdc (i,k,jc,nc) = fkph
            vdqc(i,k,jc,nc) = fkph
            vvc (i,k,jc,nm) = fkpm
            vdc (i,k,jc,nm) = fkph
            vdqc(i,k,jc,nm) = fkph
90        continue
100     continue
      endif
      if (first) then
c
c     set up some print locations for diagnostic printout
c
        jpr1 = jmt/2
        ipr1 = imt/2
        jpr2 = (3*jmt)/4
        ipr2 = imt/2
      endif
      if (j .eq. jsrow) then
c
c-----------------------------------------------------------------------
c       on the first row of a task:
c
c       1) compute the advective coefficients at the south face of the
c          "t" grid box for the next row (jsrow+1)
c
c       2) return
c-----------------------------------------------------------------------
c
        fxb = cstr(j+1)*dytr(j+1)*csu(j)
        do 200 k=1,km
          do 190 i=2,imt
            fvsq(i,k)  = (v(i,k,jc,nc)*dxu(i) + v(i-1,k,jc,nc)*dxu(i-1))
     $               *fxb*dxt4r(i)
190       continue
200     continue
c
        return
      else
c
c-----------------------------------------------------------------------
c       on all but the first row of a task:
c
c       1) compute the advective coefficients "fuw" at the west face of
c         the "t" grid box & "fvn" at the north face of the "t" grid box
c
c-----------------------------------------------------------------------
c
        fxa = cstr(j)*dytr(j)
        fxb = fxa*csu(j)
        do 300 k=1,km
          do 290 i=2,imt
            fuw(i,k) = (u(i-1,k,jc,nc)*dyu(j) + u(i-1,k,jm,nc)*dyu(j-1))
     $               *fxa*dxt4r(i)
            fvn(i,k) = (v(i  ,k,jc,nc)*dxu(i) + v(i-1,k,jc,nc)*dxu(i-1))
     $               *fxb*dxt4r(i)
290       continue
300     continue
c
      endif
c
      tdt=c2dtts
      do  400 k=1,km
        do  390 i=1,imt
          sprod(i,k) = c0
          bprod(i,k) = c0
          dissp(i,k) = c0
          tke(i,k)   = c0
          hdq2(i,k)  = c0
#ifdef leq
          tkel(i,k)  = c0
          hdq2l(i,k) = c0
#endif
390     continue
400   continue
c
c-----------------------------------------------------------------------
c    set time level ln depending on implicit or explicit treatment
c-----------------------------------------------------------------------
#ifdef implicitvmix
      ln = nc
#else
      ln = nm
#endif
c
c-----------------------------------------------------------------------
c     compute vertical difference of density on "t" grid row j+1 at
c     time level tau for implicit time differencing.
c     time level tau-1 for explicit  time differencing.
c     set no-flux condition on density at bottom. bottom boundary
c     condition on velocity will determine if there is drag.
c     bottom boundary condition on tracer is no flux.
c-----------------------------------------------------------------------
c
      do 500 ks=1,2
        call statec (t(1,1,jc,ln,1), t(1,1,jc,ln,2), tempik(1,1,1), ks)
        do 490 k=ks,kmm1,2
          do 480 i=1,imt
            drho(i,k) = tempik(i,k,1) - tempik(i,k+1,1)
480       continue
490     continue
500   continue
c
      do 600 i=1,imt
        if (kmt(i,j) .ne. 0) then
          drho(i,kmt(i,j)) = c0
        endif
600   continue
c
#ifdef dataassim
c
c     increment rho to increase stability for data assimilation
c
      do 700 k=1,kmm1
        do 690 i=1,imt
          drho(i,k)=drho(i,k)+2.e-6*dzwr(0)/dzwr(k-1)
690     continue
700   continue
#endif
c
c      compute vertical diffusion coefficients for q2
c
      do 800 k=2,km
        do 790 i=1,imt
          eeq(i,k) = p5*(vdqc(i,k-1,jc,ln)+vdqc(i,k,jc,ln))*dzwur(k)
790     continue
800   continue
      do 900 k=1,kmm1
        do 890 i=1,imt
          ffq(i,k) = p5*(vdqc(i,k,jc,ln)+vdqc(i,k+1,jc,ln))*dzwlr(k)
890     continue
900   continue
      do 1000 i=1,imt
          eeq(i,1)   = p5*vdqc(i,1,jc,ln)*dzwur(1)
          ffq(i,km)=c0
1000  continue
c
#ifdef leq
c     set top boundary condition for q2l
      do  1100 i=1,imt
        bcl(i) = c0
1100  continue
#endif
c
c-----------------------------------------------------------------------
c     solve for turbulant kinetic energy
c-----------------------------------------------------------------------
c
c
c     compute friction velocity ustar
c
      do 1200 i = 1,imt
        ustar(i) = smf(i,1)**2 + smf(i,2)**2
1200  continue
      b1tt = (b1**(2./3.))/rhoh2o
c    note that ustar is really b1**2/3*ustar**2
      do 1300 i=1,imt
        ustar(i) = b1tt*sqrt(ustar(i))
1300  continue
#ifdef lalg
c
c     compute length scale from algebraic eqn (lalg)
c
      do 1400 i = 1,imt
        sum0(i) = c0
        sum1(i) = c0
1400  continue
      do 1500 k=1,km
        do 1490 i=1,imt
          sum0(i) = sqrt(q2(i,k,jc,nc))*dzt(k) + sum0(i)
          sum1(i) = sqrt(q2(i,k,jc,nc))*dzt(k)*zw(k) + sum1(i)
1490    continue
1500  continue
      alpha=0.2
      do 1600 k=1,km
        do 1590 i=1,imt
          el0        = alpha*abs(sum1(i)/(sum0(i)+epsln))
          el(i,k,jc) = (el0*vk*abs(zw(k)))/(vk*abs(zw(k))+el0)
1590    continue
1600  continue
#endif
#ifdef leq
      do 1700 k=1,km
        do 1690 i=1,imt
          el(i,k,jc) = q2l(i,k,jc,nc)/(q2(i,k,jc,nc)+epsln)
          el(i,k,jp) = q2l(i,k,jp,nc)/(q2(i,k,jp,nc)+epsln)
1690    continue
1700  continue
#endif
c
c-------------------------------------------------------------------
c   compute vertical velocity in q2 columns
c-------------------------------------------------------------------
c
      do 1800 k=1,kmm1
        do 1790 i=2,imtm1
          w(i,k) = c2dzt(k)*((fuw(i+1,k)-fuw(i,k))
     $                     +fvn(i  ,k)-fvsq(i,k))
1790    continue
1800  continue
      do 1900 k=2,kmm1
        do 1890 i=2,imtm1
          w(i,k) = w(i,k)+w(i,k-1)
1890    continue
1900  continue
c
c     set vertical velocity at the surface to zero (rigidlid)
c     set vertical velocity at the bottom to zero
c
      do 2000 i=2,imtm1
        w(i,0)        = c0
        w(i,kmt(i,j)) = c0
2000  continue
c
c------------------------------------------------------------------
c     calculate quantities for the computation of
c     vertical advevtion of tke
c-----------------------------------------------------------------
c
      do 2100 k=1,kmm1
        do 2090 i=2,imtm1
          fwb1(i,k) = (w(i,k)+w(i,k+1))
     $               *(q2(i,k,jc,nc)+q2(i,k+1,jc,nc))
#ifdef leq
          fwb2(i,k) = (w(i,k)+w(i,k+1))
     $               *(q2l(i,k,jc,nc)+q2l(i,k+1,jc,nc))
#endif
2090    continue
2100  continue
c
c     for vertical advection of tke:
c     set k=0 elements of vertical advection array to
c     (w(0)+w(1))*(u*+q2(1))
#ifdef leq
c     for tkel:
c     (w(0)+w(1))*(bcl+q2l(1))
#endif
c     also assume w(km)=0.if "kz" < "km"
c     and there is a bottom slope, w(kz) may be non zero.
c
      do 2200 i=2,imtm1
        fwb1(i,0) = (w(i,0)+w(i,1))
     $              *(ustar(i)+q2(i,1,jc,nc))
        fwb1(i,km) = c0
#ifdef leq
        fwb2(i,0) = (w(i,0)+w(i,1))
     $              *(bcl(i)+q2l(i,1,jc,nc))
        fwb2(i,km) = c0
#endif
2200  continue
c
c------------------------------------------------------------------
c     construct auxiliary arrays for statement functions to
c     prevent unnecessary computation
c------------------------------------------------------------------
c
      do 2300 k=1,kmm1
        do 2290 i=2,imt
          aux1(i,k) = p5*(fuw(i,k)+fuw(i,k+1))
     $                  *(q2(i,k,jc,nc)+q2(i-1,k,jc,nc))
          aux3(i,k) = dxu2r(i-1)*(q2 (i,k,jc,nm)-q2 (i-1,k,jc,nm))
#ifdef leq
          aux2(i,k) = p5*(fuw(i,k)+fuw(i,k+1))
     $                  *(q2l(i,k,jc,nc)+q2l(i-1,k,jc,nc))
          aux4(i,k) = dxu2r(i-1)*(q2l(i,k,jc,nm)-q2l(i-1,k,jc,nm))
#endif
2290    continue
2300  continue
c
c---------------------------------------------------------------------
c     set horizontal diffusion coefficients
c---------------------------------------------------------------------
c
      bbtj = 8.0*cstr(j)*cstr(j)
      cctj = csu(j  )*dyur(j  )*dytr(j)*cstr(j)
      ddtj = csu(j-1)*dyur(j-1)*dytr(j)*cstr(j)
      bbtj = bbtj*aq
      cctj = cctj*aq
      ddtj = ddtj*aq
c
c   store contribution from  advection of tke into advq2
c   store contribution from hor. diff. of tke into hdq2
c
      do 2400 k=1,kmm1
        do 2390 i=2,imtm1
          advq2(i,k) = uq2x(i,k)  + vq2y(i,k)  + wq2z(i,k)
          hdq2(i,k)  = q2xx(i,k)  + q2yy(i,k)
#ifdef leq
          advq2l(i,k) = uq2lx(i,k) + vq2ly(i,k) + wq2lz(i,k)
          hdq2l(i,k)  = q2lxx(i,k) + q2lyy(i,k)
#endif
2390    continue
2400  continue
c
      do 2500 k=1,kmm1
        do 2490 i=2,imtm1
c
c--------------------------------------------------------------------
c       calculate shear and buoyancy production
c--------------------------------------------------------------------
c
        sprod(i,k) = (p25*(u(i-1,k+1,jm,nc)+u(i-1,k+1,jc,nc)
     $                  +u(i,k+1,jm,nc)+u(i,k+1,jc,nc))
     $             -p25*(u(i-1,k,jm,nc)+u(i-1,k,jc,nc)
     $                  +u(i,k,jm,nc)+u(i,k,jc,nc)))**2
        sprod(i,k) = sprod(i,k)
     $        +(p25*(v(i-1,k+1,jm,nc)+v(i-1,k+1,jc,nc)
     $              +v(i,k+1,jm,nc)+v(i,k+1,jc,nc))
     $        -p25*(v(i-1,k,jm,nc)+v(i-1,k,jc,nc)
     $             +v(i,k,jm,nc)+v(i,k,jc,nc)))**2
        sprod(i,k) = sprod(i,k)*vvc(i,k,jc,nc)*dzwr(k)*dzwr(k)
c       betag      = grav*(8.75e-6*(t(i,k,1)+9.))
c       bprod(i,k) = vdc(i,k,jc,nc)*betag*(t(i,k,jc,nc,1)
c    $                                       -t(i,k+1,jc,nc,1))*dzwr(k)
        bprod(i,k) = vdc(i,k,jc,nc)*grav*drho(i,k)*dzwr(k)
c
c-----------------------------------------------------------------------
c       calculate dissipation
c-----------------------------------------------------------------------
c
        dissp(i,k) = c2*(sqrt(q2(i,k,jc,ln))*q2(i,k,jc,ln))
c       if explicit calc of dissp no need to divide by q2 and use q2b
#ifdef implicitvmix
#  ifdef leq
        dissp(i,k) = dissp(i,k)/(b1*q2l(i,k,jc,ln)+epsln)
#  endif
#  ifdef lalg
        dissp(i,k) = dissp(i,k)/(b1*el(i,k,jc)*q2(i,k,jc,ln)+epsln)
#  endif
#else
        dissp(i,k) = dissp(i,k)/(b1*el(i,k,jc)+epsln)
#endif
c
c-----------------------------------------------------------------------
c       compute partial tendency
c-----------------------------------------------------------------------
c
          tke(i,k) = q2(i,k,jc,nm)
     $                 +tdt*c2*(sprod(i,k)+bprod(i,k))
     $                 -tdt*advq2(i,k)+tdt*hdq2(i,k)
2490    continue
2500  continue
#ifdef implicitvmix
c
c     include vertical diffusion and solve implicitly
c
      call implq (q2a, tke, tdt, ustar, j)
#else
c
c     calculate tke explictly add on dissipation
c     and vertical diffusion
c
      do 2600 k=1,kmm1
        do 2590 i=2,imtm1
          q2dif(i,k) = q2(i,k,jc,nm) - q2(i,k+1,jc,nm)
2590    continue
2600  continue
c
c     for vertical diffusion of q2:
c     set k=0 to b1**2/3*ustar**2
c     set bottom level "kz" =0
c
      do 2700 i=2,imtm1
        q2dif(i,0)        = ustar(i) - q2(i,1,jc,nm)
        q2dif(i,kmt(i,j)) = c0
2700  continue
      do 2800 k=1,km
        do 2790 i=2,imtm1
          q2a(i,k) = tke(i,k)-tdt*dissp(i,k)
     $                     +tdt*q2zz(i,k)
2790    continue
2800  continue
#endif
#ifdef lalg
      do 2900 k=1,km
        do 2890 i=1,imt
          if (q2a(i,k) .lt. small) q2a(i,k) = small
2890    continue
2900  continue
#endif
c
c     mask out land values   q2
c
      do 3000 k=1,km
        do 2990 i=1,imt
          q2a(i,k) = q2a(i,k)*fm(i,k,jc)
2990    continue
3000  continue
#ifdef leq
c
c----------------------------------------------------------------------
c      compute master length scale  (leq)
c----------------------------------------------------------------------
c
      do 3100 k=1,kmm1
        do 3090 i=1,imt
c
c     compute wall proximity function w = 1 + e2(l/L)**2
c
          wallc = (c1/abs(zw(k))+c1/(abs(zw(k)-zw(kmt(i,j)))+deps))/vk
          wallf = c1+e2*(wallc*el(i,k,jc))**2
c
c-----------------------------------------------------------------------
c       calculate dissipation
c-----------------------------------------------------------------------
c
#ifdef implicitvmix
          dissp(i,k) = p5*dissp(i,k)*wallf
#else
          dissp(i,k) = (sqrt(q2(i,k,jc,ln))*q2(i,k,jc,ln)*wallf)/b1
#endif
c
c
c     compute partial tendency of tkel
c
          tkel(i,k) = q2l(i,k,jc,nm)
     $                +tdt*(el(i,k,jc)*e1*(sprod(i,k)+e3*bprod(i,k)))
     $                -tdt*advq2l(i,k)+tdt*hdq2l(i,k)
3090    continue
3100  continue
#ifdef implicitvmix
c
c     include vertical diffusion and solve implicitly
c
      call implq (q2la, tkel, tdt, bcl, j)
#else
c
c     calculate tkel explictly add on dissipation
c     and vertical diffusion
c
      do 3200 k=1,kmm1
        do 3190 i=2,imtm1
          q2ldif(i,k) = q2l(i,k,jc,nm) - q2l(i,k+1,jc,nm)
3190    continue
3200  continue
c
c     for vertical diffusion of q2l:
c     set k=0 to bcl=0
c     set bottom level "kz" =0
c
      do 3300 i=2,imtm1
        q2ldif(i,0)        = bcl(i)
        q2ldif(i,kmt(i,j)) = c0
3300  continue
      do 3400 k=1,km
        do 3390 i=2,imtm1
          q2la(i,k) = tkel(i,k)-tdt*dissp(i,k)
     $                       +tdt*q2lzz(i,k)
3390    continue
3400  continue
#endif
      do 3500 k=1,km
        do 3490 i=1,imt
          if (q2a(i,k) .lt. small .or. q2la(i,k) .lt. small) then
            q2a(i,k)  = small
            q2la(i,k) = small*c100
          endif
3490    continue
3500  continue
c
c     compute max l  (could modify e3 instead) for stable case
c
      do 3600 k=1,km
        do 3590 i=1,imt
          elmax(i,k) = big
3590    continue
3600  continue
c
      fxb=.1
      do 3700 k=1,kmm1
        do 3690 i=1,imt
          if(drho(i,k).le.c0) then
          elmax(i,k) = sqrt(q2a(i,k))
          bprol(i,k) = abs(grav*drho(i,k)*dzwr(k))
          bprol(i,k) = sqrt(bprol(i,k))
          elmax(i,k) = q2a(i,k)*fxb*elmax(i,k)
     $                 /(bprol(i,k)+epsln)
          endif
3690    continue
3700  continue
      do 3800 k=1,km
        do 3790 i=1,imt
          if (q2la(i,k) .gt. elmax(i,k) .and. q2a(i,k) .ne. small)
     $              q2la(i,k) = elmax(i,k)
c
c       mask out land values  q2l
c
          q2la(i,k) = q2la(i,k)*fm(i,k,jc)
3790    continue
3800  continue
#endif
c
c-----------------------------------------------------------------
c      solve for km , kh & kq
c-----------------------------------------------------------------
c
      d1     = a1*(c1-3.*cc1)
      d2     = a2
      a1a16  = a1*a1*6.
      a1a112 = a1*a1*12.
      a1a29  = a1*a2*9.
      a1a26  = a1*a2*6.
      a2b23  = a2*b2*3.
      a1a212 = a1*a2*12.
c     el     = q2la/(q2a+epsln)
      do 3900 k=1,kmm1
        do 3890 i=1,imt
          gh(i,k) = sprod(i,k)*el(i,k,jc)*el(i,k,jc)/
     $            (q2(i,k,jc,nc)*vvc(i,k,jc,nc)+epsln)
3890    continue
3900  continue
c
c      the following filter on gmp1 does not change the calculated
c      results significantly but does eliminate occasional spurious
c      vertical fluctuations in km and kh
c
      do 62 i=1,imt
        gmp1(i,1) = p25*p154+p5*gh(i,1)+p25*gh(i,2)
  62  continue
      do 4000 k=2,kmm1
        do 3990 i=1,imt
          gmp1(i,k) = p25*gh(i,k-1)+p5*gh(i,k)+p25*gh(i,k+1)
3990    continue
4000  continue
      do 4100 k=1,kmm1
        do 4090 i=1,imt
          gh(i,k)   = bprod(i,k)*el(i,k,jc)*el(i,k,jc)/
     $                (q2(i,k,jc,nc)*vdc(i,k,jc,nc)+epsln)
          gh(i,k)   = amin1(gh(i,k),p032)
          gh(i,k)   = amax1(gh(i,k),-.1e9)
          gmp1(i,k) = amin1(gmp1(i,k),p48-c15*gh(i,k))
4090    continue
4100  continue
      do 4200 k=1,kmm1
        do 4190 i=1,imt
          c11     = c1+a1a16*gmp1(i,k)-a1a29*gh(i,k)
          c12     = (-a1a112-a1a29)*gh(i,k)
          c21     = a1a26*gmp1(i,k)
          c22     = c1-(a2b23+a1a212)*gh(i,k)
          denom   = c1/(c11*c22-c12*c21+epsln)
          sm(i,k) = (c22*d1-c12*d2)*denom
          sh(i,k) = (c11*d2-c21*d1)*denom
4190    continue
4200  continue
      do  4300 k=1,kmm1
        do 4290 i=1,imt
          sm(i,k) = (sm(i,k)+abs(sm(i,k)))*p5
          sh(i,k) = (sh(i,k)+abs(sh(i,k)))*p5
4290    continue
4300  continue
      do 4400 k=1,km
        do 4390 i=1,imt
          ekn(i,k,jc) = el(i,k,jc)*sqrt(q2(i,k,jc,nc))
4390    continue
4400  continue
      fx1 = sq/0.392
      do 4500 k=1,kmm1
        do 4490 i=1,imt
          vdqca(i,k) = p25*vdqc(i,k,jc,nc)
     $                +p75*(ekn(i,k,jc)*fx1*sm(i,k))
          vdca(i,k)  = p25*vdc(i,k,jc,nc)
     $                +p75*(ekn(i,k,jc)*sh(i,k))
4490    continue
4500  continue
c
c     average l*q*sm to obtain a value over u v pts
c        (at eknp should use sm at j+1-but not available)
c
      do 4600 k=1,km
        do 4590 i=1,imt
          if (j .eq. jmtm1) then
             ekn(i,k,jp) = c0
          else
            ekn(i,k,jp) = el(i,k,jp)*sqrt(q2(i,k,jp,nc))
          endif
4590    continue
4600  continue
      do 4700 k=1,kmm1
        do 4690 i=1,imtm1
          vvca(i,k) = p25*vvc(i,k,jc,nc)
     $        +p75*(p25*(ekn(i,k,jp)*sm(i,k)+ekn(i+1,k,jp)*sm(i+1,k)
     $             +ekn(i,k,jc)*sm(i,k)+ekn(i+1,k,jc)*sm(i+1,k)))
4690    continue
4700  continue
c
c     set q2=q2l=0. at kz (bottom b.c.) also vvc,vdc=0.
c
      do 4800 i=1,imt
        kz = kmt(i,j)
        if (kz .eq. 0) then
          q2a(i,kz)   = c0
#ifdef leq
          q2la(i,kz)  = c0
#endif
          vdqca(i,kz) = c0
          vdca(i,kz)  = c0
        endif
4800  continue
c
c     limit mixing coeff
c
      do 4900 k=1,km
        do 4890 i=1,imt
          if (vdqca(i,k) .ge. vdqlim) vdqca(i,k) = vdqlim
          if (vvca(i,k) .ge. vvclim) vvca(i,k)   = vvclim
          if (vdca(i,k) .ge. vdclim) vdca(i,k)   = vdclim
          if (vdqca(i,k) .lt. bvdc) vdqca(i,k)   = bvdc
          if (vvca(i,k) .lt. bvvc) vvca(i,k)     = bvvc
          if (vdca(i,k) .lt. bvdc) vdca(i,k)     = bvdc
4890    continue
4900  continue
c
c
#ifdef cyclic
      do 5600 k=1,km
        q2a(1,k)    = q2a(imtm1,k)
        q2a(imt,k)  = q2a(2,k)
#ifdef leq
        q2la(1,k)   = q2la(imtm1,k)
        q2la(imt,k) = q2la(2,k)
#endif
#endif
5600  continue
c
c     set up advection coeff for next call
c
      factor = cst(j)*dyt(j)*cstr(j+1)*dytr(j+1)
      do 5700 k=1,km
        do 5690 i=1,imt
          fvsq(i,k) = fvn(i,k)*factor
5690    continue
5700  continue
c
c     printout some diagnostics
c
      if (prntsi) then
c
      kmd2=km/2
      if (j .eq. jpr1 .or. j .eq. jpr2) then
      ii = ipr1
      if (j .eq. jpr2)   ii = ipr2
      if (jpr1 .eq. jpr2)ii = ipr1
      write(stdout,755)
      do 5800 k=1,kmd2
        tendq = (q2a(ii,k)-q2(ii,k,jc,nm))/tdt
        dissp(ii,k) = sqrt(q2(ii,k,jc,nm))*q2(ii,k,jc,nm)
        dissp(ii,k) = dissp(ii,k)/(b1*el(ii,k,jc)+epsln)
#ifdef implicitvmix
        diff = advq2(ii,k)-c2*sprod(ii,k)-c2*bprod(ii,k)+tendq
     1     +c2*dissp(ii,k)-hdq2(ii,k)
#else
        diff = q2zz(ii,k)
#endif
        rf = -bprod(ii,k)/(sprod(ii,k)+epsln)
        write(stdout,750)tendq,advq2(ii,k),diff,sprod(ii,k),bprod(ii,k)
     1         ,dissp(ii,k),vdca(ii,k),vvca(ii,k),rf,q2a(ii,k)
5800  continue
#ifndef leq
      write(stdout,777)
      do 5900 k=1,kmd2
        write(stdout,778)hdq2(ii,k)
5900  continue
#endif
#ifdef leq
      write(stdout,777)
      do 6000 k=1,kmd2
        pod = b1*(sm(ii,k)*gmp1(ii,k)+sh(ii,k)*gh(ii,k))
        rii = -gh(ii,k)/(gmp1(ii,k)+epsln)
        rif = -sh(ii,k)*gh(ii,k)/(sm(ii,k)*gmp1(ii,k)+epsln)
        write(stdout,778)hdq2(ii,k),hdq2l(ii,k),el(ii,k,jc),elmax(ii,k)
     1         ,rii,rif,pod
6000  continue
      write(stdout,767)
      do 6100 k=1,kmd2
        tendq = (q2la(ii,k)-q2l(ii,k,jc,nm))/tdt
        wallf = c1+e2*((c1/abs(zw(k))+c1/(abs(zw(k)-zw(kmt(i,j)))
     $                                    +deps)) *el(ii,k,jc)/vk)**2
        dissp(ii,k) = sqrt(q2(ii,k,jc,ln))*q2(ii,k,jc,ln)
        dissp(ii,k) = (dissp(ii,k)/b1)*wallf
        diff1 = (q2la(ii,k)-tkel(ii,k))/tdt+dissp(ii,k)
#ifdef implicitvmix
        diff2 = tendq+dissp(ii,k)-el(ii,k,jc)*e1*(sprod(ii,k)+
     $       bprod(ii,k))+advq2l(ii,k)-hdq2l(ii,k)
#else
        diff2 = q2lzz(ii,k)
#endif
        write(stdout,765)tendq,dissp(ii,k),diff1,diff2,tke(ii,k)
     $                ,vdqca(ii,k),advq2l(ii,k),q2la(ii,k),wallf
  765 format(5x,9e12.4)
  767 format(10x,'tendql=',7x,'dissp',7x,'diff1',7x,'diff2',7x,'tke '
     $      ,7x,' vdqc ',7x,'advq2l',6x,'q2la',7x,'wallf')
6100  continue
#endif
      endif
      endif
      if (diagts .and. eots) then
c
c---------------------------------------------------------------------
c       print the solution at specified latitudes on diagnostic tsteps
c---------------------------------------------------------------------
c
        do 6200 jlat=1,nlatpr
          jj = indp (prlat(jlat), yt, jmt)
          if (jj .eq. j .and. prlat(jlat) .le. yt(jmt)) then
            is  = indp (prslon(jlat), xt, imt)
            ie  = indp (prelon(jlat), xt, imt)
            ks  = indp (prsdpt(jlat), zt, km)
            ke  = indp (predpt(jlat), zt, km)
            fx  = 1.0e-2
            scl = c1
            write (stdout,9100) 'q2 ', itt
     $,       j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (q2(1,1,jc,nc), imt, is, ie, ks, ke, scl)
#ifdef leq
            scl = c1
            write (stdout,9100) 'q2l ', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (q2l(1,1,jc,nc), imt, is, ie, ks, ke, scl)
#endif
            scl = c1
            write (stdout,9100) 'kh ', itt
     $,      j, yt(j), xt(is), xt(ie), fx*zt(ks), fx*zt(ke), scl
            call matrix (vdc(1,1,jc,nc), imt, is, ie, ks, ke, scl)
          endif
6200    continue
      endif
   72 format(5x,'sm,sh,gmp1,gh,km,kh= ',6e12.4)
  750 format(5x,10e12.4)
  755 format(10x,'tendq=',7x,'advq',7x,'+diff',7x,'+prods',7x,'+prodb'
     1      ,7x,'-dissp',9x,'kh',9x,'km',9x,'rf',9x,'q2')
  777 format(10x,'hdiff ',7x,'hdiffl',7x,'   l',7x,'  lmax',7x,
     1 '  rii',7x,'   rif',7x,'   pod')
  778 format(5x,7e12.4)
9100  format(1x,a12,1x,'ts=',i10,1x,',j=',i3,', lat=',f6.2
     $,', lon:',f6.2,' ==> ',f6.2,', depth(m):',f6.1,' ==> ',f6.1
     $,', scaling=',1pg10.3)
#endif
      return
      end
#DECK theta0.f
      function theta0 (ydeg, depth)
c
c=======================================================================
c     this subroutine returns estimates of global mean potential
c     temperature for model initialization as a function of depth.
c     it is used to produce a reference thermal stratification for the
c     upper 2000m of the MOM's test case.  below 2000m, the
c     potential temperature returned is 2.0 degrees C.  surface
c     values are set slightly above 18.4 degrees C at the reference
c     latitude "reflat".
c     the estimates are produced from a 7th order ploynomial fit to
c     the annual mean world ocean potential temperature observations
c     of Levitus (1982).
c
c     input [units]:
c       a latitdue (ydeg): [degrees]
c       a zt value (depth): [centimeters]
c     output [units]:
c       potential temperature estimate (est): [degrees centigrade]
c
c     variables:
c       coeft     = coefficients for the polynomial fit of potential
c                   temperature vs. depth
c       reflat    = reference latitude at which observed surface
c                   temperatures approximately equal coeft(1)
c       factor    = the ratio of the cosine of the latitude requested
c                   ("ydeg") to the reference latitude ("reflat")
c                   used to scale the upper 2000 meters of the vertical
c                   temperature profile
c       tmin,tmax = the minumum and maximum potential temperatures
c                   allowed at the time of model initialization
c
c     reference:
c       Levitus, S., Climatological atlas of the world ocean, NOAA
c     Prof. Paper 13, US Gov't printing Office, Washington, DC, 1982.
c
      parameter (ndeg=7)
      dimension coeft(ndeg+1)
      save coeft, tmin, tmax, reflat
      data coeft / 0.184231944E+02,-0.430306621E-01, 0.607121504E-04
     $           ,-0.523806281E-07, 0.272989082E-10,-0.833224666E-14
     $           , 0.136974583E-17,-0.935923382E-22/
      data tmin, tmax, reflat /2.0, 25.0, 34.0/
c
c=======================================================================
c
      c0 = 0.0
      pi = atan(1.0) * 4.0
      refcos = abs(cos(pi*reflat/180.))
c
      coslat = abs(cos(pi*ydeg/180.))
      factor = coslat/refcos
      z = depth * 0.01
c
      if (z .gt. 2000.) then
        est = 2.0
      else
        est = c0
        do 100 nn=1,ndeg+1
          bb = 1.0
          if (nn.gt.1) bb = z**(nn-1)
          est = est + coeft(nn)*bb
100     continue
        est = est * factor
      endif
c
      if (est .gt. tmax) est = tmax
      if (est .lt. tmin) est = tmin
c
      theta0 = est
      return
      end
#DECK tmngr.F
      subroutine tmngr (dt)
c
c
c=======================================================================
c
c                      t-i-m-e      m-a-n-a-g-e-r
c
c     tmngr measures model time using a julian calendar.
c     date & time are accurate to within one second for arbitrary
c     length time steps. if a calendar with 360 days per year
c     and 30 day months is desired, set "julian" = false (see below).
c     note: the year length is arbitrary. it can be changed below.
c     computer requirements: 64 bit precision is recommended.
c
c     inputs:
c
c     itt    = current model time step (from switch.h).
c     dt     = length of time step in seconds.
c     see "switch.h" for other inputs
c
c     outputs:
c
c     itt    = itt + 1
c     see "switch.h" for other outputs
c
c=======================================================================
c
c
      logical tmnset, eomset
#include "pconst.h"
#include "ctmngr.h"
#include "switch.h"
c
      dimension dpm(12), sumpm(12,2)
c
      save dpm, sumpm, rnorm, rleap, tt0, totda0, clock0, monold
c
c     dpm = number of days per month
c
      data dpm /31.0, 28.0, 31.0, 30.0, 31.0, 30.0, 31.0, 31.0, 30.0,
     $          31.0, 30.0, 31.0/
c
c-----------------------------------------------------------------------
c     statement function
c-----------------------------------------------------------------------
c
      frac(r) = r - int(r)
c
c
c-----------------------------------------------------------------------
c     increment time step counter
c-----------------------------------------------------------------------
c
      itt = itt + 1
c
c=======================================================================
c
c     calendar initialization
c
c=======================================================================
c
c
c-----------------------------------------------------------------------
c     set year lengths, partial sums & other misc quantities
c     on the first call to tmngr
c-----------------------------------------------------------------------
c
      if (first) then
c
c       set initial time in days
c
        clock0 = hour0*r24 + minut0*r1440 + (sec0+p5)*secday
c
c       do bounds checking on initial clock parameters in "ctmngr.h"
c
        if (month0 .lt. 1 .or. month0 .gt. 12) then
          write (stdout,*) ' "month0" is out of bounds'
          stop '=>tmngr'
        endif
        if (day0 .lt. 1 .or. day0 .gt. 31) then
          write (stdout,*) ' "day0" is out of bounds'
          stop '=>tmngr'
        endif
        if (hour0 .lt. 0 .or. hour0 .gt. 23) then
          write (stdout,*) ' "hour0" is out of bounds'
          stop '=>tmngr'
        endif
        if (minut0 .lt. 0 .or. minut0 .gt. 59) then
          write (stdout,*) ' "minut0" is out of bounds'
          stop '=>tmngr'
        endif
        if (sec0 .lt. 0 .or. sec0 .gt. 59) then
          write (stdout,*) ' "sec0" is out of bounds'
          stop '=>tmngr'
        endif
        if (julian) then
c
c         set up a julian calendar
c
          yrnorm = 365.0
          yrleap = 366.0
          nleap  = 4
          write (stdout,'(/,a41,/)')
     $          ' ==> tmngr: julian calendar is in effect.'
        else
c
c         set up a simple calendar with 12 equi-length months
c         and no leap years (each year is "yrnorm" days long)
c
          yrnorm = 360.0
          yrleap = yrnorm
          nleap  = 999999
          do 100 m=1,12
            dpm(m) = yrnorm/12
100       continue
          write (stdout,'(/,a47,f9.3,a14/)')
     $     ' ==> tmngr: simple calendar is in effect using ', yrnorm
     $,    ' days per year'
        endif
c
        totday = c0
        tt0    = itt - 1.1
        rleap  = c1/yrleap
        rnorm  = c1/yrnorm
c
        sumpm(1,1) = c0
        do 200 m=2,12
          sumpm(m,1) = sumpm(m-1,1) + dpm(m-1)
          sumpm(m,2) = sumpm(m,1)
          if (m .gt. 2 .and. julian) sumpm(m,2) = sumpm(m,2) + c1
200     continue
c
c-----------------------------------------------------------------------
c       calculate time in years (time1) of model start.
c-----------------------------------------------------------------------
c
        styear = year0 + relyr
        if (mod(int(styear),nleap) .eq. 0) then
          time1 = styear + (sumpm(month0,2) + (day0-1) + clock0)/yrleap
        else
          time1 = styear + (sumpm(month0,1) + (day0-1) + clock0)/yrnorm
        endif
c
        if (julian) then
c
c         1st calc # of days ignoring leap days since 1 jan year 0
c
          totda0 = yrnorm*styear
c
c         add in leap days in years prior to the one listed in styear
c
          lpdays = int(time1 - 29.0/yrleap)/nleap
          if (mod(int(styear),nleap) .eq. 0 .and. (time1-int(time1))
     $        .gt. 29.0/yrleap) lpdays = lpdays - 1
c
c         add in leap day of styear if starting after the end of Feb,
c         year 0
c
          if (time1 .gt. (29.0/yrleap)) lpdays = lpdays + 1
c
c         add in number of days gone in the current year "thisdy"
c
          if (mod(int(styear),nleap) .eq. 0) then
            thisdy = (time1-styear)*yrleap
          else
            thisdy = (time1-styear) * yrnorm
          endif
          totda0 = totda0 + lpdays + thisdy
        else
          totda0 = yrnorm*styear
        endif
        totday = totda0 + totday
c
c-----------------------------------------------------------------------
c       set time of initial conditions
c-----------------------------------------------------------------------
c
        time0 = time1 - relyr
      endif
c
c
c
c=======================================================================
c
c     calendar calculation
c
c=======================================================================
c
c     increment day counter
c
      totday = totday + dt*secday
c
c
c-----------------------------------------------------------------------
c     increment relative year according to type of year & time within
c     the year.
c     if clearly within a normal year ... use dtnorm
c     if clearly within a leap year   ... use dtleap
c     if transitioning from a leap year to a normal year   ... use a
c     linear combination of dtleap and dtnorm
c     if transitioning from a normal year to a leap year   ... use a
c     linear combination of dtleap and dtnorm also
c-----------------------------------------------------------------------
c
      dtleap = dt*secday/yrleap
      dtnorm = dt*secday/yrnorm
      curtim = time0 + relyr
      if (mod(int(curtim),nleap) .eq. 0) then
        if (mod(int(curtim+dtleap),nleap) .eq. 0) then
          deltat = dtleap
        else
          f1 =nint(curtim) - curtim
          f2 = dtleap - f1
          deltat = (f1*dtleap + f2*dtnorm)/dtleap
        endif
      else
        if (mod(int(curtim+dtnorm),nleap) .ne. 0) then
          deltat = dtnorm
        else
          f1 = nint(curtim) - curtim
          f2 = dtnorm - f1
          deltat = (f1*dtnorm + f2*dtleap)/dtnorm
        endif
      endif
      relyr = relyr + deltat
c
c-----------------------------------------------------------------------
c     construct julian (or simple) calendar year.
c-----------------------------------------------------------------------
c
      tyear = time0 + relyr
c
c-----------------------------------------------------------------------
c     decide whether this is a leap year or normal year.
c-----------------------------------------------------------------------
c
      if (mod(int(tyear),nleap) .eq. 0) then
        ntype  = 2
        tday = frac(tyear)*yrleap
      else
        ntype  = 1
        tday = frac(tyear)*yrnorm
      endif
c
c-----------------------------------------------------------------------
c     construct month, day, hour, minute, & second using fractional
c     part of julian (or simple) year.
c-----------------------------------------------------------------------
c
      month = indp (tday, sumpm(1,ntype), 12)
      if (sumpm(month,ntype) .gt. tday) month = month-1
      if (first) then
        monold = month
      endif
      tmonth = month
      tday   = tday - sumpm(month,ntype) + 1
      thour  = frac(tday)*c24
      tmin   = frac(thour)*c60
      tsec   = frac(tmin)*c60
      tyear  = int(tyear)
      tday   = int(tday)
      thour  = int(thour)
      tmin   = int(tmin)
      tsec   = int(tsec)
      write (stamp,'(a6,i2,a1,i2,a1,i4,a8,i2,a1,i2,a1,i2)')
     $             'm/d/y=',nint(tmonth),'/',nint(tday),'/'
     $,             nint(tyear),', h:m:s:', nint(thour),':'
     $,             nint(tmin),':', nint(tsec)
c
c=======================================================================
c
c     set all time dependent logical switches in this section.
c
c=======================================================================
c
c
c-----------------------------------------------------------------------
c     is diagnosis to be done at this time ?
c-----------------------------------------------------------------------
c
c     do an diagnostic timestep when within one half of a timestep
c     of the requested time interval
c
      diagts = tmnset (dgnstc, totday, dt)
c
c-----------------------------------------------------------------------
c     is time to save a snapshot of the data ?
c-----------------------------------------------------------------------
c
c     take a snapshot (save data) when within one half of a timestep
c     of the requested time interval
c
      snapts = tmnset (snaps, totday, dt)
c
c
c-----------------------------------------------------------------------
c     are regional tracer averages to be done at this time ?
c-----------------------------------------------------------------------
c
c     do an average when within one half of a timestep
c     of the requested time interval
c
      tavgts = tmnset (travg, totday, dt)
c
c-----------------------------------------------------------------------
c     is it the end of the month ?
c-----------------------------------------------------------------------
c
      eom = eomset (monold, month)
c
c-----------------------------------------------------------------------
c     is time mixing to be done at this time ?
c-----------------------------------------------------------------------
c
      if (mod(itt,nmix) .eq. 1) then
          mixts = .true.
        else
          mixts = .false.
      endif
c
c-----------------------------------------------------------------------
c     is printing of time step information to be done at this time ?
c-----------------------------------------------------------------------
c
c     print timestep info when within one half of a timestep
c     of the requested time interval
c
      prntsi = tmnset (tsi, totday, dt)
c
c-----------------------------------------------------------------------
c     is it time to stop yet ?
c-----------------------------------------------------------------------
c
      if ((itt-tt0)*dt*secday .ge. days) then
          last = .true.
        else
          last = .false.
      endif
c
c-----------------------------------------------------------------------
c     additional logical switches for determining when to bring
c     in time dependent data should go in here.
c     (ie: monthly boundary conditions, assimilations, etc)
c     also logical switches for determining when to write out data.
c     (ie: averaging periods for data, etc)
c-----------------------------------------------------------------------
c
      return
      end
      function tmnset (days, totday, dt)
c
c=======================================================================
c     tmnset = true if current time is within 1/2 time step of desired
c              interval
c     days   = time interval between when the logical will be set to
c              true (referenced to jan 1, year 0)
c     totday = accumulated time in days from jan 1, year 0
c     dt     = time step in seconds
c=======================================================================
c
#include "pconst.h"
      logical tmnset
      close  = p5*dt
      i      = nint (totday/days)
      remain = (totday - i*days)*c60*c1440
      if ((remain .ge. c0 .and. remain .lt. close) .or.
     $    (remain .lt. c0 .and. -remain .le. close)) then
        tmnset = .true.
      else
        tmnset = .false.
      endif
      return
      end
      function eomset (oldmon, month)
c
c=======================================================================
c     eomset = true for the first time step when the month changes
c              otherwise  false.
c     oldmon = month when "first" is true
c     month  = current month
c=======================================================================
c
      integer oldmon
      logical eomset
      if (month .ne. oldmon) then
        eomset = .true.
      else
        eomset = .false.
      endif
      oldmon = month
      return
      end
      subroutine tmntrp
     $             (num, maxnum, pos, tplb, tpl, tpla, iahd, ibhd, fbhd)
c
c=======================================================================
c
c     time interpolator ... constructs indices & factor needed for
c     linearly interpolating data defined at arbitrary time intervals
c     (midpoints of years, months, days or even random intervals) to
c     the time corresponding to the current time step
c     this routine provides for a smooth, linear interpolation between
c     the midpoints of time intervals of any arbitrary length
c
c=======================================================================
c
c     inputs:
c
c     num    = index of the time interval (containing data for use in
c              interpolating) which includes the current time.
c              (ie: if data is monthly then... num is 2 if the current
c               time is in february)
c     maxnum = max number of time intervals
c              (ie: 12 if using monthly data)
c     pos    = time measured relative to the beginning of interval "num"
c              and in the same units as "tpl".
c              (ie: 14.36 days into the month of february)
c     tplb   = time period length of interval immediately before "num"
c              (ie: 31.0 days if the month is january)
c     tpl    = time period length of interval "num"
c              (ie: 28.0 days if the month is february)
c     tpla   = time period length of interval immediately after "num"
c              (ie: 31.0 days if the month is march)
c
c     outputs:
c
c     iahd   = index for pointing to the time interval with midpoint
c              after (ahead of) the current time.
c              (ie: iahd would be 3 if the current time was beyond the
c                   midpoint of {but still within} february)
c     ibhd   = index for pointing to the time interval with midpoint
c              before (behind) the current time.
c              (ie: ibhd would be 2 if the current time was beyond the
c                   midpoint of {but still within} february)
c     fbhd   = interpolation factor for defining data at the current
c              time (the weight attributed to the data from the ibhd
c              time interval)
c                  schematically the interpolation is defined by:
c              interpolated data = fbhd*data(ibhd) + (1-fbhd)*data(iahd)
c
c     variable:
c
c     rmidpt = the midpoint of the current time interval
c
#include "pconst.h"
c
      rmidpt =  p5*tpl
      if (pos .gt. rmidpt) then
        iahd = num + 1
        fbhd = c1 - c2*(pos-rmidpt)/(tpl+tpla)
      else
        iahd = num
        fbhd = c2*(rmidpt-pos)/(tpl+tplb)
      endif
      iahd = mod(iahd-1,maxnum) + 1
      ibhd = mod(iahd-2+maxnum,maxnum) + 1
c
      return
      end
      subroutine tmntr2
     $             (num, maxnum, pos, tpl, iahd, ibhd, fbhd)
c
c=======================================================================
c
c     time interpolator ... constructs indices & factor needed for
c     interpolating data defined at arbitrary time intervals (midpoints
c     of years, months, days or even random intervals) to the time
c     corresponding to the current time step.
c     this routine conducts a linear interpolation between the midpoints
c     of time intervals and the time interval boundaries.
c     at the time interval boundaries the interpolated data values are
c     defined to be the average of the mean values attributed to
c     the two time intervals that border it, regardless of their
c     relative lengths
c
c=======================================================================
c
c     inputs:
c
c     num    = index of the time interval (containing data for use in
c              interpolating) which includes the current time.
c              (ie: if data is monthly then... num is 2 if the current
c               time is in february)
c     maxnum = max number of time intervals
c              (ie: 12 if using monthly data)
c     pos    = time measured relative to the beginning of interval "num"
c              and in the same units as "tpl".
c              (ie: 14.27 days into the month of february would be the
c              designation for 6:28:48 on the morning of february 15th)
c     tpl    = time period length of interval "num"
c              (ie: 28.0 days if the month is february)
c
c     outputs:
c
c     iahd   = index for pointing to the time interval with midpoint
c              after (ahead of) the current time.
c              (ie: iahd would be 3 if the current time was beyond the
c                   midpoint of {but still within} february)
c     ibhd   = index for pointing to the time interval with midpoint
c              before (behind) the current time.
c              (ie: ibhd would be 2 if the current time was beyond the
c                   midpoint of {but still within} february)
c     fbhd   = interpolation factor for defining data at the current
c              time (the weight attributed to the data from the ibhd
c              time interval)
c                  schematically the interpolation is defined by:
c              interpolated data = fbhd*data(ibhd) + (1-fbhd)*data(iahd)
c
c     variable:
c
c     rmidpt = the midpoint of the current time interval
c
c
#include "pconst.h"
c
      rmidpt =  p5*tpl
      if (pos .gt. rmidpt) then
        iahd = mod(num, maxnum) + 1
        ibhd = num
        fbhd = c1 - abs((pos-rmidpt)/tpl)
      else
        iahd = num
        ibhd = mod(num-2+maxnum,maxnum) + 1
        fbhd = abs((pos-rmidpt)/tpl)
      endif
c
      return
      end
#DECK topog.F
      subroutine topog
c
c-----------------------------------------------------------------------
c     construct an "idealized" world ... piece by piece
c     note: this topography will map into arbitrary model resolution
c-----------------------------------------------------------------------
c
#include "param.h"
#include "coord.h"
#include "grdvar.h"
#include "levind.h"
c
c     define the model topography on the "t" grid using "kmt"
c     set maximum level everywhere except on boundary
c
      do 100 j=2,jmtm1
        do 90 i=2,imtm1
          kmt(i,j) = km
90      continue
100   continue
c
      do 200 j=1,jmt
        kmt(imt,j) = 0
        kmt(1,j) = 0
200   continue
      do 300 i=1,imt
        kmt(i,jmt) = 0
        kmt(i,1) = 0
300   continue
c
c     antarctica
c
      call setkmp (-90.0, 0.0, c360, -80.0, 0.0, c360, 0)
      call setkmp (-80.0, c360-25.0, c360, -70.0, c360, c360, 0)
      call setkmp (-80.0, 0.0, c360, -70.0, 0.0, 170.0, 0)
      call setkmp (-80.0, c360-135.0, c360-60.0, -68.0, c360-75.0,
     $              c360-60.0, 0)
      call setkmp (-70.0, 0.0, 155.0, -67.0, 50.0, 145.0, 0)
c
c     australia
c
      call setkmp (-35.0, 116.0, 120.0, -31.0, 114.0, 130.0, 0)
      call setkmp (-38.0, 140.0, 151.0, -31.0, 130.0, 151.0, 0)
      call setkmp (-31.0, 115.0, 153.0, -20.0, 113.0, 149.0, 0)
      call setkmp (-20.0, 113.0, 149.0, -11.0, 131.0, 143.0, 0)
c
c     south america
c
      call setkmp (-50.0, c360-74.0, c360-68.0, -40.0, c360-73.0,
     $              c360-62.0, 0)
      call setkmp (-40.0, c360-73.0, c360-62.0, -20.0, c360-70.0,
     $              c360-40.0, 0)
      call setkmp (-20.0, c360-70.0, c360-40.0, -16.0, c360-81.0,
     $              c360-35.0, 0)
      call setkmp (-16.0, c360-81.0, c360-35.0, 0.0, c360-80.0,
     $             c360-50.0, 0)
      call setkmp (0.0, c360-80.0, c360-50.0, 11.0, c360-75.0,
     $             c360-60.0, 0)
c
c     central america
c
      call setkmp (6.0, c360-78.0, c360-75.0, 20.0, c360-105.0,
     $             c360-97.0, 0)
      call setkmp (20.0, c360-105.0, c360-97.0, 30.0, c360-115.0,
     $             c360-94.0, 0)
c
c     north america
c
      call setkmp (25.0, c360-82.0, c360-80.0, 30.0, c360-85.0,
     $             c360-81.0, 0)
      call setkmp (30.0, c360-115.0, c360-80.0, 40.0, c360-124.0,
     $             c360-74.0, 0)
      call setkmp (40.0, c360-124.0, c360-74.0, 50.0, c360-124.0,
     $             c360-57.0, 0)
      call setkmp (50.0, c360-124.0, c360-57.0, 60.0, c360-140.0,
     $             c360-64.0, 0)
      call setkmp (60.0, c360-165.0, c360-64.0, 65.0, c360-140.0,
     $             c360-64.0, 0)
      call setkmp (65.0, c360-140.0, c360-64.0, 70.0, c360-162.0,
     $             c360-72.0, 0)
      call setkmp (70.0, c360-162.0, c360-140.0, 72.0, c360-157.0,
     $             c360-157.0, 0)
      call setkmp (70.0, c360-130.0, c360-70.0, 75.0, c360-120.0,
     $             c360-80.0, 0)
c
c     greenland
c
      call setkmp (60.0, c360-45.0, c360-45.0, 75.0, c360-58.0,
     $             c360-19.0, 0)
c
c     africa
c
      call setkmp (-35.0, 19.0, 28.0, 6.0, 8.0, 50.0, 0)
      call setkmp (6.0, 0.0, 50.0, 18.0, 0.0, 56.0, 0)
      call setkmp (18.0, 0.0, 56.0, 26.0, 0.0, 59.0, 0)
      call setkmp (6.0, c360-10.0, c360, 18.0, c360-18.0, c360, 0)
      call setkmp (18.0, c360-18.0, c360, 26.0, c360-15.0, c360, 0)
c
c     northern africa &  europe & asia
c
      call setkmp (26.0, c360-15.0, c360, 40.0, c360-7.0, c360, 0)
      call setkmp (40.0, c360-7.0, c360, 50.0, c360, c360, 0)
c
      call setkmp (26.0, 0.0, 126.0, 40.0, 0.0, 122.0, 0)
      call setkmp (40.0, 0.0, 130.0, 50.0, 0.0, 140.0, 0)
      call setkmp (50.0, 0.0, 140.0, 60.0, 8.0, 140.0, 0)
      call setkmp (60.0, 8.0, 163.0, 65.0, 13.0, 180.0, 0)
      call setkmp (65.0, 13.0, 188.0, 70.0, 20.0, 180.0, 0)
      call setkmp (70.0, 70.0, 180.0, 75.0, 90.0, 100.0, 0)
c
c     add an "idealized" ridge in the atlantic & pacific
c
      level = indp (3500.e2, zw, km)
c
      call setkmp (-20.0, c360-20.0, c360-10.0, 30.0, c360-45.0,
     $              c360-35.0, level)
      call setkmp (30.0, c360-45.0, c360-35.0, 60.0, c360-20.0,
     $              c360-30.0, level)
c
      call setkmp (-60.0,c360-100.0, c360-130.0, 40.0, c360-160.0,
     $              180.0, level)
      level = indp (2000.e2, zw, km)
      call setkmp (-50.0, c360-120.0, c360-120.0, 30.0, 190.0, 190.0,
     $             level)
#ifdef cyclic
c
c     set cyclic boundary conditions
c
      do 400 j=1,jmt
        kmt(1,j)   = kmt(imtm1,j)
        kmt(imt,j) = kmt(2,j)
400   continue
#endif
      return
      end
#DECK tracer.F
      subroutine tracer(j)
#ifdef multitasking
cfpp$ noconcur r
#endif
c
c=======================================================================
c
c     tracer computes tracer quantities at time level n+1 for row j
c
c=======================================================================
c
c
#include "param.h"
#include "accel.h"
#ifdef biharmonic
# include "cbihar.h"
#endif
#include "cdiag.h"
#include "chmix.h"
#ifdef isopycmix
#include "cisop.h"
#endif
#ifdef nlhmix
# include "cnlmix.h"
#endif
#include "cregin.h"
#include "ctask.h"
#include "cvbc.h"
#include "cvmix.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "iounit.h"
#include "levind.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
#include "temp.h"
      dimension twodt(km)
#ifndef keepterms
c
c---------------------------------------------------------------------
c     define operators using statement functions ...
c     otherwise they will be dimensioned in "slabs.h"
c---------------------------------------------------------------------
c
#include "fdift.h"
#endif
c
      if (j .eq. jsrow) then
c
c-----------------------------------------------------------------------
c       on the first row of a task:
c
c       1) compute the advective coefficients at the south face of the
c          "t" grid box for the next row (jsrow+1)
c
c       2) return
c-----------------------------------------------------------------------
c
c       calculate "fvst" this way to insure that answers do not change
c       regardless of how "ntasks" is set
c
        fxb = cstr(j)*dytr(j)*csu(j)
        do 100 k=1,km
          do 90 i=2,imt
            fvst(i,k) = (v(i,k,jc,nc)*dxu(i) + v(i-1,k,jc,nc)*dxu(i-1))
     $               *fxb*dxt4r(i)
90        continue
100     continue
        fx = cst(j)*dyt(j)*cstr(j+1)*dytr(j+1)
        do 170 k=1,km
          do 160 i=2,imt
            fvst(i,k) = fvst(i,k)*fx
160       continue
170     continue
c
        return
      else
c
c-----------------------------------------------------------------------
c       on all but the first row of a task:
c
c       1) compute the advective coefficients "fuw" at the west face of
c         the "t" grid box & "fvn" at the north face of the "t" grid box
c
c       2) initialize "w" & "tracers"
c-----------------------------------------------------------------------
c
        fxa = cstr(j)*dytr(j)
        fxb = cstr(j)*dytr(j)*csu(j)
        do 200 k=1,km
          do 180 i=2,imt
            fuw(i,k) = (u(i-1,k,jc,nc)*dyu(j) + u(i-1,k,jm,nc)*dyu(j-1))
     $               *fxa
            fvn(i,k) = (v(i  ,k,jc,nc)*dxu(i) + v(i-1,k,jc,nc)*dxu(i-1))
     $               *fxb*dxt4r(i)
180       continue
#ifdef cyclic
          fuw(imt,k) = fuw(2,k)
#else
          fuw(imt,k) = c0
#endif
c
#ifdef skipland
          do 190 i=1,imt
            w(i,k) = c0
190       continue
#endif
200     continue
c
#ifdef skipland
        do 300 m=1,nt
          do 290 k=1,km
            do 280 i=1,imt
              ta(i,k,m) = c0
280         continue
290       continue
300     continue
#endif
      endif
#ifdef nlhmix
c
c-----------------------------------------------------------------------
c     set diffusion factors for the row
c-----------------------------------------------------------------------
c
c     use pure deformation for nonlinear diffusion coeff
c
      hfact = c1
      bah   = c0
      do 250 k=1,km
        do 240 i=2,imt
          dpt1 = p25*(dpure(i,k)  + dpure(i-1,k)
     $              + dpures(i,k) + dpures(i-1,k))
          dpt2 = p25*(dpures(i,k) + dpures(i-1,k)
     $              + dpuret(i,k) + dpuret(i-1,k))
          bbtj(i,k) = (effk(i)*hfact*dpures(i,k) + bah)*bbt(j)
          cctj(i,k) = (effky(j  )*hfact*dpt1 + bah)*cct(j)
          ddtj(i,k) = (effky(j-1)*hfact*dpt2 + bah)*ddt(j)
240     continue
250   continue
#endif
#ifdef skipland
c
c-----------------------------------------------------------------------
c     solve "tracers" over longitudinal strips of ocean points
c     if skipland is not set them "istart" & "iend" are parameters
c-----------------------------------------------------------------------
c
      do 1300 lstrip=1,lseg
        istart = ist(j,lstrip)
        iend   = iet(j,lstrip)
        if (istart .ne. 0) then
#endif
c
c-----------------------------------------------------------------------
c         compute vertical velocity in t columns
c-----------------------------------------------------------------------
c
c         compute divergence of mass at each level
c
          do 400 k=1,kmm1
            do 390 i=istart,iend
              w(i,k) = c2dzt(k)*((fuw(i+1,k)-fuw (i,k))*dxt4r(i)
     $                           +fvn(i  ,k)-fvst(i,k))
390         continue
400       continue
c
c         integrate downward from the surface so vertical velocity is
c         defined at the bottom of each level
c
          do 500 k=2,kmm1
            do 490 i=istart,iend
              w(i,k) = w(i,k) + w(i,k-1)
490         continue
500       continue
c
c         set vertical velocity at the surface to zero (rigid-lid)
c         set vertical velocity at the bottom to zero also
c
          do 600 i=istart,iend
            w(i,0)        = c0
            w(i,kmt(i,j)) = c0
 600      continue
c
#ifdef isopycmix
c
c         add fk3(i,k+1,3) (the zz term from isopycnal mixing) to
c         vdc(i,k) for use in implicit mixing
c
          do 610 i=1,imt
            vdc(i,km) = c0
610       continue
c
          do 630 k=1,kmm1
            do 620 i=1,imt
              vdc(i,k) = vdc(i,k) + fk3(i,k+1,3)
620         continue
630       continue
c
#endif

          do 1200 m=1,nt
c
c-----------------------------------------------------------------------
c           calculate quantities for the computation of
c           vertical diffusion and advection of tracers
c-----------------------------------------------------------------------
c
            do 700 k=1,kmm1
              do 690 i=istart,iend
#ifdef tcvmix
                vtf(i,k) = vdc(i,k,jc,nm)*(t(i,k,jc,nm,m)
     $                                 - t(i,k+1,jc,nm,m))*dzwr(k)
#else
                vtf(i,k) = vdc(i,k)*(t(i,k,jc,nm,m) - t(i,k+1,jc,nm,m))
     $                     *dzwr(k)
#endif
                fwb1(i,k) = w(i,k)*(t(i,k,jc,nc,m) + t(i,k+1,jc,nc,m))
690           continue
700         continue
c
c           for vertical diffusion of tracers:
c           set k=0 elements to reflect surface tracer flux.
c           set bottom level "kz" to reflect insulation condition.
c           for vertical advection of tracers:
c           set k=0 elements of vertical advection array to the rigid
c           lid condition (w(0) = 0). also assume w(km)=0. If "kz" <
c           "km" and there is a bottom slope, w(kz) may be non zero.
c
c
            do 800 i=istart,iend
              fwb1(i,0)        = c0
              fwb1(i,km)       = c0
              vtf(i,0)         = stf(i,m)
              vtf(i,kmt(i,j))  = btf(i,m)
800         continue
c
c-----------------------------------------------------------------------
c           construct auxiliary arrays for statement functions to
c           prevent unnecessary computation.
c-----------------------------------------------------------------------
c
            do 900 k=1,km
              do 890 i=istart,iend+1
                aux1(i,k) = fuw(i,k)*(t(i,k,jc,nc,m)+t(i-1,k,jc,nc,m))
#if defined biharmonic && !defined isopycmix
                aux2(i,k) = dxu2r(i-1)*(del2(i,k,m,jpt2)
     $                               -  del2(i-1,k,m,jpt2))
#else
# ifndef isopycmix
                aux2(i,k) = dxu2r(i-1)*(t(i,k,jc,nm,m)-t(i-1,k,jc,nm,m))
# endif
#endif
890           continue
900         continue
c
c-----------------------------------------------------------------------
c           construct tracer source terms
c-----------------------------------------------------------------------
c
#ifdef restorst
c
c-----------------------------------------------------------------------
c           restore surface tracers to prescribed values by adding
c           newtonian damping to source term. (see "setvbc.F")
c-----------------------------------------------------------------------
c
            do 960 i=istart,iend
              sourct(i,1,m) = sourct(i,1,m) + restr(i,m)
960         continue
#endif
#ifdef isopycmix
c
c-----------------------------------------------------------------------
c           construct arrays for use in isopycnal diffusion
c           calculation
c-----------------------------------------------------------------------
c
            call isop1 (j, m)
#endif
#ifdef keepterms
c
c-----------------------------------------------------------------------
c           if terms are defined as arrays, then calculate them here
c           otherwise statement functions will be used
c-----------------------------------------------------------------------
c
            do 980 k=1,km
              do 970 i=istart,iend
#include "fdift.h"
970           continue
980         continue
#endif
c
c-----------------------------------------------------------------------
c           calculate the new tracer quantities allowing for implicit
c           treatment of vertical diffusion
c-----------------------------------------------------------------------
c
            do 1000 k=1,km
              twodt(k) = c2dtts*dtxcel(k)
              do 990 i=istart,iend
                ta(i,k,m) = (t(i,k,jc,nm,m) + twodt(k)*(
     $                       UTx(i,k) + VTy(i,k) + WTz(i,k)
#ifdef isopycmix
     $                     + Tisox(i,k) + Tisoy(i,k) + Tisoz(i,k)
#else
     $                     + Txx(i,k) +Tyy(i,k)
#endif
#if defined implicitvmix || defined isopycmix
     $                     + Tzz(i,k)*(c1-aidif)
#else
     $                     + Tzz(i,k)
#endif
     $                     + sourct(i,k,m))
     $                                   )*fm(i,k,jc)
990           continue
1000        continue
#if defined implicitvmix || defined isopycmix
c
c----------------------------------------------------------------------
c           solve vertical diffusion implicitly
c----------------------------------------------------------------------
c
c           store terms to compute implicit vertical mixing on
c           diagnostic time steps
c
            if (diagts .and. eots) then
              do 1050 k=1,km
                do 1040 i=istart,iend
                  zzi(i,k,1) = ta(i,k,m)
1040            continue
1050          continue
            endif
c
#ifdef tcvmix
            call invtri (ta(1,1,m),  stf(1,m), btf(1,m)
     $,             vdca, twodt, kmt, fm(1,1,jc), istart, iend, j)
#else
            call invtri (ta(1,1,m),  stf(1,m), btf(1,m)
     $,              vdc, twodt, kmt, fm(1,1,jc), istart, iend, j)
#endif
c
c           compute residual implicit vertical mixing
c
            if (diagts .and. eots) then
              do 1070 k=1,km
                rc2dt = c1/twodt(k)
                do 1060 i=istart,iend
                  zzi(i,k,1) = rc2dt*(ta(i,k,m) - zzi(i,k,1))
1060            continue
1070          continue
            endif
#endif
c
c-----------------------------------------------------------------------
c           do analysis of tracers on diagnostic timesteps over
c           longitudinal strips of ocean points
c-----------------------------------------------------------------------
c
            if (diagts .and. eots) then
              f1 = cst(j)*dyt(j)
              do 1100 i=istart,iend
                kz = kmt(i,j)
                if (kz .ne. 0) then
                  area       = f1*dxt(i)
                  sstf       = area*stf(i,m)
                  ssst       = area*t(i,1,jc,nc,m)
                  asst(m,0)  = asst(m,0)  + ssst
                  stflx(m,0) = stflx(m,0) + sstf
                  n          = mskhr(i,j)
                  if (n .gt. 0) then
                    stflx(m,n) = stflx(m,n) + sstf
                    asst(m,n)  = asst(m,n)  + ssst
                  endif
                  do 1080 k=1,kz
                    boxvol = area*dzt(k)
                    satwv  = boxvol*t(i,k,jc,nc,m)
                    sutx   = boxvol*UTx(i,k)
                    svty   = boxvol*VTy(i,k)
                    swtz   = boxvol*WTz(i,k)
#ifdef isopycmix
                    stxx   = boxvol*Tisox(i,k)
                    styy   = boxvol*Tisoy(i,k)
#else
                    stxx   = boxvol*Txx(i,k)
                    styy   = boxvol*Tyy(i,k)
#endif
#if defined implicitvmix || defined isopycmix
                    stzz   = boxvol*(Tzz(i,k)*(c1-aidif) + zzi(i,k,1))
# ifdef isopycmix
     $                     + boxvol*Tisoz(i,k)
# endif
#else
                    stzz   = boxvol*Tzz(i,k)
#endif
                    ssourc = boxvol*sourct(i,k,m)
c
                    n = 0
                    termbt(k,2,m,n) = termbt(k,2,m,n) + sutx
                    termbt(k,3,m,n) = termbt(k,3,m,n) + svty
                    termbt(k,4,m,n) = termbt(k,4,m,n) + swtz
                    termbt(k,5,m,n) = termbt(k,5,m,n) + stxx
                    termbt(k,6,m,n) = termbt(k,6,m,n) + styy
                    termbt(k,7,m,n) = termbt(k,7,m,n) + stzz
                    termbt(k,8,m,n) = termbt(k,8,m,n) + ssourc
                    atwv(m,n)       = atwv(m,n)       + satwv
                    n      = nhreg*(mskvr(k)-1) + mskhr(i,j)
                    if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                      termbt(k,2,m,n) = termbt(k,2,m,n) + sutx
                      termbt(k,3,m,n) = termbt(k,3,m,n) + svty
                      termbt(k,4,m,n) = termbt(k,4,m,n) + swtz
                      termbt(k,5,m,n) = termbt(k,5,m,n) + stxx
                      termbt(k,6,m,n) = termbt(k,6,m,n) + styy
                      termbt(k,7,m,n) = termbt(k,7,m,n) + stzz
                      termbt(k,8,m,n) = termbt(k,8,m,n) + ssourc
                      atwv(m,n)       = atwv(m,n)       + satwv
                    endif
1080              continue
c
                  if (m .eq. 1 .and. kz .ge. 2) then
                    fx = area*grav*p5
                    do 1090 k=2,kz
                      buoy(k) = buoy(k) - fx*dzw(k-1)*w(i,k-1)*
     $                                (rhos(i,k-1)+rhos(i,k))
1090                continue
                  endif
                endif
1100          continue
            endif
#ifdef isopycmix
c
c     save the north - central isopycnal diffusion of "e(i,k,2)"
c     (yy + zy terms ... xy is neglected) into "esav(i,k,m)" for
c     use during the next j row calculation
c
      do 1190 k=1,km
        do 1180 i=1,imt
          esav(i,k,m) = e(i,k,2)
1180    continue
1190  continue
#endif
1200      continue
#ifdef skipland
        endif
1300  continue
#endif
#ifndef implicitvmix
c
c-----------------------------------------------------------------------
c         convectively adjust water column if gravitationally unstable
c         over longitudinal strips of ocean points
c-----------------------------------------------------------------------
c
c         ncon determines number of passes through convection loop
c
c         ks=1: compare lev. 1 to 2; 3 to 4; etc.
c         ks=2: compare lev. 2 to 3; 4 to 5; etc.
c
          do 1400 n=1,ncon
            do 1390 ks=1,2
c
c             find density for entire slab for stability determination
c
              call statec (ta(1,1,1), ta(1,1,2), tempik(1,1,1), ks)
#ifdef skipland
              do 1380 lstrip=1,lseg
                istart = ist(j,lstrip)
                iend   = iet(j,lstrip)
                if (istart .ne. 0) then
#endif
c
c                 set "heavy water" in land to stop convection
c
                  dense = 1.e15
                  do 1340 i=istart,iend
                    k = kmt(i,j) + 1
                    if (k .le. km) then
                      tempik(i,k,1) = dense
                    endif
1340              continue
c
c                 if unstable,  mix tracers on adjoining levels
c
                  do 1370 m=1,nt
                    do 1360 k=ks,kmm1,2
                      do 1350 i=istart,iend
                        if (tempik(i,k,1) .gt. tempik(i,k+1,1)) then
                          ta(i,k,m) = (dztxcl(k)  *ta(i,k,m) +
     $                                 dztxcl(k+1)*ta(i,k+1,m))
     $                                 *dzwxcl(k)
                          ta(i,k+1,m) = ta(i,k,m)
                        endif
1350                  continue
1360                continue
1370              continue
#ifdef skipland
                endif
1380          continue
#endif
1390        continue
1400      continue
#endif
c
c-----------------------------------------------------------------------
c         integrate total changes in t,s and squared t,s on diagnostic
c         timesteps over longitudinal strips of ocean points
c-----------------------------------------------------------------------
c
          if (diagts .and. eots) then
            do 1500 m=1,nt
              do 1490 k=1,km
                fx = cst(j)*dyt(j)*dzt(k)/(c2dtts*dtxcel(k))
                do 1480 i=2,imtm1
                  boxfx           = fx*dxt(i)*fm(i,k,jc)
                  sddt            = (ta(i,k,m)-t(i,k,jc,nm,m))*boxfx
                  svar            = (ta(i,k,m)**2-t(i,k,jc,nm,m)**2)
     $                              *boxfx
                  n               = 0
                  termbt(k,1,m,n) = termbt(k,1,m,n) + sddt
                  tvar(k,m,n)     = tvar(k,m,n)     + svar
                  n     = nhreg*(mskvr(k)-1) + mskhr(i,j)
                  if (n .gt. 0 .and. mskhr(i,j) .gt. 0) then
                    termbt(k,1,m,n) = termbt(k,1,m,n) + sddt
                    tvar(k,m,n)     = tvar(k,m,n)     + svar
                  endif
1480            continue
1490          continue
1500        continue
          endif
c
#if defined fourfil || defined firfil
c
c-----------------------------------------------------------------------
c     fourier filter tracers at high latitudes
c-----------------------------------------------------------------------
c
#ifdef cyclic
c
c     set cyclic boundary conditions on newly computed tracers
c
      do 1600 m=1,nt
        do 1590 k=1,km
          ta(1  ,k,m) = ta(imtm1,k,m)
          ta(imt,k,m) = ta(2    ,k,m)
1590    continue
1600  continue
#endif
      call filt (j)
c
#endif
c
      if (tavgts .and. eots) then
        call region (j, iotavg, .true., .true., .true.)
      endif
c
c-----------------------------------------------------------------------
c     accumulate integrated absolute changes in tracers over
c     longitudinal strips of ocean points when printout of timestep
c     info is desired
c-----------------------------------------------------------------------
c
      if (prntsi) then
        fx1 = p5*cst(j)*dyt(j)/c2dtts
#ifdef skipland
        do 1700 lstrip=1,lseg
          istart = ist(j,lstrip)
          iend   = iet(j,lstrip)
          if (istart .ne. 0) then
#endif
            do 1690 m=1,nt
              do 1680 k=1,km
                fx = fx1/dtxcel(k)
                do 1660 i=istart,iend
                  tempik(i,k,1) = abs(ta(i,k,m)-t(i,k,jc,nm,m))*
     $                            c2dzt(k)*fx*dxt(i)*fm(i,k,jc)
1660            continue
                do 1670 i=istart,iend
                  dtabs(k,m,j) = dtabs(k,m,j) + tempik(i,k,1)
1670            continue
1680          continue
1690        continue
#ifdef skipland
          endif
1700    continue
#endif
      endif
c
c-----------------------------------------------------------------------
c     transfer quantities computed to the north of the present row
c     to be defined to the south in the computation of the next row
c-----------------------------------------------------------------------
c
      if (j .ne. jerow) then
        fx = cst(j)*dyt(j)*cstr(j+1)*dytr(j+1)
        do 1800 k=1,km
          do 1790 i=1,imt
            fvst(i,k) = fvn(i,k)*fx
            rhos(i,k) = rhon(i,k)
#ifdef nlhmix
            dtens(i,k)  = dten(i,k)
            dshers(i,k) = dshear(i,k)
            dpuret(i,k) = dpures(i,k)
            dpures(i,k) = dpure(i,k)
#endif
1790      continue
1800    continue
      endif
#ifdef cyclic
c
c     set cyclic boundary conditions on newly computed tracers
c
      do 1900 m=1,nt
        do 1890 k=1,km
          ta(1  ,k,m) = ta(imtm1,k,m)
          ta(imt,k,m) = ta(2    ,k,m)
1890    continue
1900  continue
#endif
#ifndef symmetry
c
c-----------------------------------------------------------------------
c     set new velocities at northern wall to zero since no pass through
c     clinic is made for this row
c-----------------------------------------------------------------------
c
      if (j .eq. jmtm1) then
        do 2000 k=1,km
          do 1990 i=1,imt
            ua(i,k) = c0
            va(i,k) = c0
1990      continue
2000    continue
      endif
#endif
      return
      end
#DECK vort.F
      subroutine vort
c
c=======================================================================
c
c     compute vorticity for relaxation
c
c=======================================================================
c
#include "param.h"
#include "cdiag.h"
#include "emode.h"
#include "grdvar.h"
#include "index.h"
#include "levind.h"
#include "scalar.h"
#include "slabs.h"
#include "switch.h"
#ifdef multitasking
      dimension tempik(imt,km,1)
#else
#include "temp.h"
#endif
c
c
      do 400 j=2,jmtm1
c
c-----------------------------------------------------------------------
c       form curl of time change in vertically averaged equations
c-----------------------------------------------------------------------
c
#ifdef islands
c       all vorticity pts. are computed so that those needed for the
c       line integral of hole relaxation (immediately adjacent to
c       islands will be defined).
c
        is=2
        ie=imtm1
#else
c       non-active vorticity pts. are kept at 0 for convenience in relax
c       to accomplish this, ztd is computed only between given starting
c       and ending indices.
c
        do 100 l=1,lseg
          is=isz(j,l)
          if(is.eq.0) go to 101
          ie=iez(j,l)
#endif
          do 90 i=is,ie
            ztd(i,j) = ((zu(i,j)*dxu(i) + zu(i-1,j)*dxu(i-1))*csu(j  )
     $             -(zu(i,j-1)*dxu(i) + zu(i-1,j-1)*dxu(i-1))*csu(j-1))
            ztd(i,j)=(((zv(i,j) - zv(i-1,j))*dyu(j  )
     $              +(zv(i,j-1) - zv(i-1,j-1))*dyu(j-1)
     $              -ztd(i,j))*dxt2r(i)*dytr(j))*cstr(j)
90        continue
100     continue
101     continue
c
c-----------------------------------------------------------------------
c       do analysis of external mode forcing on diagnostic timesteps
c-----------------------------------------------------------------------
c
        if (diagts .and. eots) then
          engtmp = c0
          fx = cst(j)*dyt(j)/c2dtsf
          do 200 i=2,imtm1
            tempik(i,1,1) = - p(i,j,1)*ztd(i,j)*fx*dxt(i)
200       continue
          do 300 i=2,imtm1
            engtmp = engtmp +tempik(i,1,1)
300       continue
          engext(1) = engext(1) + engtmp
        endif
c
#if defined fourfil || defined firfil
c
c-----------------------------------------------------------------------
c       filter vorticity at high latitudes
c-----------------------------------------------------------------------
c
        call filz (j)
#endif
400   continue
      return
      end


